<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/sebhildebrandt/systeminformation">systeminformation (v3.17.0)</a>
</h1>
<h4>Simple system and OS information library</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation">module systeminformation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.battery">
            function <span class="apidocSignatureSpan">systeminformation.</span>battery
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.blockDevices">
            function <span class="apidocSignatureSpan">systeminformation.</span>blockDevices
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpu
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuCache">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuCache
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuCurrentspeed">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuCurrentspeed
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuFlags">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuFlags
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuTemperature">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuTemperature
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.currentLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>currentLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.disksIO">
            function <span class="apidocSignatureSpan">systeminformation.</span>disksIO
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerAll">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerAll
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainerProcesses">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerProcesses
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainerStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerStats
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainers">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainers
            <span class="apidocSignatureSpan">(all, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerSocket">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerSocket
            <span class="apidocSignatureSpan">(all, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fsSize">
            function <span class="apidocSignatureSpan">systeminformation.</span>fsSize
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fsStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>fsStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fullLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>fullLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getAllData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getAllData
            <span class="apidocSignatureSpan">(srv, iface, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getDynamicData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getDynamicData
            <span class="apidocSignatureSpan">(srv, iface, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getStaticData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getStaticData
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.graphics">
            function <span class="apidocSignatureSpan">systeminformation.</span>graphics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.inetChecksite">
            function <span class="apidocSignatureSpan">systeminformation.</span>inetChecksite
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.inetLatency">
            function <span class="apidocSignatureSpan">systeminformation.</span>inetLatency
            <span class="apidocSignatureSpan">(host, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.mem">
            function <span class="apidocSignatureSpan">systeminformation.</span>mem
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkConnections">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkConnections
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkInterfaceDefault">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaceDefault
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkInterfaces">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaces
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkStats
            <span class="apidocSignatureSpan">(iface, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osInfo">
            function <span class="apidocSignatureSpan">systeminformation.</span>osInfo
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>processLoad
            <span class="apidocSignatureSpan">(proc, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processes">
            function <span class="apidocSignatureSpan">systeminformation.</span>processes
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.services">
            function <span class="apidocSignatureSpan">systeminformation.</span>services
            <span class="apidocSignatureSpan">(srv, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.shell">
            function <span class="apidocSignatureSpan">systeminformation.</span>shell
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.system">
            function <span class="apidocSignatureSpan">systeminformation.</span>system
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.time">
            function <span class="apidocSignatureSpan">systeminformation.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.users">
            function <span class="apidocSignatureSpan">systeminformation.</span>users
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.version">
            function <span class="apidocSignatureSpan">systeminformation.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.versions">
            function <span class="apidocSignatureSpan">systeminformation.</span>versions
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>docker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>filesystem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>internet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>network</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>osinfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.battery">module systeminformation.battery</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.battery.battery">
            function <span class="apidocSignatureSpan">systeminformation.</span>battery
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.blockDevices">module systeminformation.blockDevices</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.blockDevices.blockDevices">
            function <span class="apidocSignatureSpan">systeminformation.</span>blockDevices
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.cpu">module systeminformation.cpu</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.cpu">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpu
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.cpuCache">module systeminformation.cpuCache</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuCache.cpuCache">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuCache
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.cpuCurrentspeed">module systeminformation.cpuCurrentspeed</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuCurrentspeed.cpuCurrentspeed">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuCurrentspeed
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.cpuFlags">module systeminformation.cpuFlags</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuFlags.cpuFlags">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuFlags
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.cpuTemperature">module systeminformation.cpuTemperature</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuTemperature.cpuTemperature">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuTemperature
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.currentLoad">module systeminformation.currentLoad</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.currentLoad.currentLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>currentLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.disksIO">module systeminformation.disksIO</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.disksIO.disksIO">
            function <span class="apidocSignatureSpan">systeminformation.</span>disksIO
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.docker">module systeminformation.docker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerAll">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerAll
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerContainerProcesses">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerProcesses
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerContainerStats">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerStats
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerContainers">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainers
            <span class="apidocSignatureSpan">(all, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.dockerAll">module systeminformation.dockerAll</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerAll.dockerAll">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerAll
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.dockerContainerProcesses">module systeminformation.dockerContainerProcesses</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainerProcesses.dockerContainerProcesses">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerProcesses
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.dockerContainerStats">module systeminformation.dockerContainerStats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainerStats.dockerContainerStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerStats
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.dockerContainers">module systeminformation.dockerContainers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainers.dockerContainers">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainers
            <span class="apidocSignatureSpan">(all, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.dockerSocket">module systeminformation.dockerSocket</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerSocket.dockerSocket">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerSocket
            <span class="apidocSignatureSpan">(all, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.filesystem">module systeminformation.filesystem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.blockDevices">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>blockDevices
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.disksIO">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>disksIO
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.fsSize">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsSize
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.fsStats">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.fsSize">module systeminformation.fsSize</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fsSize.fsSize">
            function <span class="apidocSignatureSpan">systeminformation.</span>fsSize
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.fsStats">module systeminformation.fsStats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fsStats.fsStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>fsStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.fullLoad">module systeminformation.fullLoad</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fullLoad.fullLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>fullLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.getAllData">module systeminformation.getAllData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getAllData.getAllData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getAllData
            <span class="apidocSignatureSpan">(srv, iface, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.getDynamicData">module systeminformation.getDynamicData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getDynamicData.getDynamicData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getDynamicData
            <span class="apidocSignatureSpan">(srv, iface, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.getStaticData">module systeminformation.getStaticData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getStaticData.getStaticData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getStaticData
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.graphics">module systeminformation.graphics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.graphics.graphics">
            function <span class="apidocSignatureSpan">systeminformation.</span>graphics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.inetChecksite">module systeminformation.inetChecksite</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.inetChecksite.inetChecksite">
            function <span class="apidocSignatureSpan">systeminformation.</span>inetChecksite
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.inetLatency">module systeminformation.inetLatency</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.inetLatency.inetLatency">
            function <span class="apidocSignatureSpan">systeminformation.</span>inetLatency
            <span class="apidocSignatureSpan">(host, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.internet">module systeminformation.internet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.internet.inetChecksite">
            function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetChecksite
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.internet.inetLatency">
            function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetLatency
            <span class="apidocSignatureSpan">(host, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.mem">module systeminformation.mem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.mem.mem">
            function <span class="apidocSignatureSpan">systeminformation.</span>mem
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.network">module systeminformation.network</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.getDefaultNetworkInterface">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>getDefaultNetworkInterface
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkConnections">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkConnections
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkInterfaceDefault">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaceDefault
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkInterfaces">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaces
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkStats">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkStats
            <span class="apidocSignatureSpan">(iface, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.networkConnections">module systeminformation.networkConnections</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkConnections.networkConnections">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkConnections
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.networkInterfaceDefault">module systeminformation.networkInterfaceDefault</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkInterfaceDefault.networkInterfaceDefault">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaceDefault
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.networkInterfaces">module systeminformation.networkInterfaces</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkInterfaces.networkInterfaces">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaces
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.networkStats">module systeminformation.networkStats</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkStats.networkStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkStats
            <span class="apidocSignatureSpan">(iface, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.osInfo">module systeminformation.osInfo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osInfo.osInfo">
            function <span class="apidocSignatureSpan">systeminformation.</span>osInfo
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.osinfo">module systeminformation.osinfo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.osInfo">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>osInfo
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.shell">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>shell
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.time">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.versions">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>versions
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.processLoad">module systeminformation.processLoad</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processLoad.processLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>processLoad
            <span class="apidocSignatureSpan">(proc, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.processes">module systeminformation.processes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processes.processes">
            function <span class="apidocSignatureSpan">systeminformation.</span>processes
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.services">module systeminformation.services</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.services.services">
            function <span class="apidocSignatureSpan">systeminformation.</span>services
            <span class="apidocSignatureSpan">(srv, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.shell">module systeminformation.shell</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.shell.shell">
            function <span class="apidocSignatureSpan">systeminformation.</span>shell
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.system">module systeminformation.system</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.system.system">
            function <span class="apidocSignatureSpan">systeminformation.</span>system
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.time">module systeminformation.time</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.time.time">
            function <span class="apidocSignatureSpan">systeminformation.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.users">module systeminformation.users</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.users.users">
            function <span class="apidocSignatureSpan">systeminformation.</span>users
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.util">module systeminformation.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.cores">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>cores
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.isFunction">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>isFunction
            <span class="apidocSignatureSpan">(functionToCheck)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.sortByKey">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>sortByKey
            <span class="apidocSignatureSpan">(array, keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.unique">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>unique
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.version">module systeminformation.version</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.version.version">
            function <span class="apidocSignatureSpan">systeminformation.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.versions">module systeminformation.versions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.versions.versions">
            function <span class="apidocSignatureSpan">systeminformation.</span>versions
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation" id="apidoc.module.systeminformation">module systeminformation</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.battery" id="apidoc.element.systeminformation.battery">
        function <span class="apidocSignatureSpan">systeminformation.</span>battery
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">battery = function (callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        hasbattery: false,
        cyclecount: 0,
        ischarging: false,
        maxcapacity: 0,
        currentcapacity: 0,
        percent: 0
      };

      if (_linux) {
        let battery_path = '';
        if (fs.existsSync('/sys/class/power_supply/BAT1/status')) {
          battery_path = '/sys/class/power_supply/BAT1/'
        } else if (fs.existsSync('/sys/class/power_supply/BAT0/status')) {
          battery_path = '/sys/class/power_supply/BAT0/'
        }
        if (battery_path) {
          exec("cat " + battery_path + "status", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              if (lines.length &gt; 0 &amp;&amp; lines[0]) result.ischarging = (lines[0].trim().toLowerCase() == 'charging')
            }
            exec("cat " + battery_path + "cyclec_ount", function (error, stdout) {
              if (!error) {
                let lines = stdout.toString().split('\n');
                if (lines.length &gt; 0 &amp;&amp; lines[0]) result.cyclecount = parseFloat(lines[0].trim());
              }
              exec("cat " + battery_path + "charge_full", function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split('\n');
                  if (lines.length &gt; 0 &amp;&amp; lines[0]) result.maxcapacity = parseFloat(lines[0].trim());
                }
                exec("cat " + battery_path + "charge_now", function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split('\n');
                    if (lines.length &gt; 0 &amp;&amp; lines[0]) result.currentcapacity = parseFloat(lines[0].trim());
                  }
                  if (result.maxcapacity &amp;&amp; result.currentcapacity) {
                    result.hasbattery = true;
                    result.percent = 100.0 * result.currentcapacity / result.maxcapacity;
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                })
              })
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      }
      if (_darwin) {
        exec("ioreg -n AppleSmartBattery -r | grep '\"CycleCount\"';ioreg -n AppleSmartBattery -r | grep '\"IsCharging\"';ioreg -
n AppleSmartBattery -r | grep '\"MaxCapacity\"';ioreg -n AppleSmartBattery -r | grep '\"CurrentCapacity\"'", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").split('\n');
            lines.forEach(function (line) {
              if (line.indexOf('=') != -1) {
                if (line.toLowerCase().indexOf('cyclecount') != -1) result.cyclecount = parseFloat(line.split('=')[1].trim());
                if (line.toLowerCase().indexOf('ischarging') != -1) result.ischarging = (line.split('=')[1].trim().toLowerCase() == '
yes');
                if (line.toLowerCase().indexOf('maxcapacity') != -1) result.maxcapacity = parseFloat(line.split('=')[1].trim());
                if (line.toLowerCase().indexOf('currentcapacity') != -1) result.currentcapacity = parseFloat(line.split('=')[1].
trim());
              }
            });
          }
          if (result.maxcapacity &amp;&amp; result.currentcapacity) {
            result.hasbattery = true;
            result.percent = 100.0 * result.currentcapacity / result.maxcapacity;
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - used | X | X | X | used (incl. buffers/cache) |
| - active | X | X | X | used actively (excl. buffers/cache)  |
| - buffcache | X | X |  | used by buffers+cache |
| - available | X | X | X | potentially available (total - active) |
| - swaptotal | X | X |  |  |
| - swapused | X | X |  |  |
| - swapfree | X | X |  |  |
| si.<span class="apidocCodeKeywordSpan">battery</span>(cb) | X | X |  | battery information |
| - hasbattery | X | X |  | indicates presence of battery |
| - ischarging | X | X |  | indicates if battery is charging |
| - maxcapacity | X | X |  | max capacity of battery |
| - currentcapacity | X | X |  | current capacity of battery |
| - percent | X | X |  | charging level in percent |
| si.graphics(cb) | X | X |  | arrays of graphics controllers and displays |
| - controllers[0].model | X | X |  | graphics controller model |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.blockDevices" id="apidoc.element.systeminformation.blockDevices">
        function <span class="apidocSignatureSpan">systeminformation.</span>blockDevices
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function blockDevices(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_linux) {
        // see https://wiki.ubuntuusers.de/lsblk/
        // exec("lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-
IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME", function (error, stdout) {
        exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER", function (error, stdout
) {
          let data = [];
          if (!error) {
            let lines = blkStdoutToObject(stdout).split('\n');
            data = parseBlk(lines);
            if (callback) {
              callback(data)
            }
            resolve(data);
          } else {
            exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER", function (error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split('\n');
                data = parseBlk(lines);
              }
              if (callback) {
                callback(data)
              }
              resolve(data);
            });
          }
        });
      }
      if (_darwin) {
        exec("diskutil info -all", function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split('\n');
            // parse lines into temp array of devices
            data = parseDevices(lines);
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec('wmic logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber
 /format:csv', function (error, stdout) {
          if (!error) {
            let lines = stdout.split('\r\n').filter(line =&gt; line.trim() != '').filter((line, idx) =&gt; idx &gt; 0);
            lines.forEach(function (line) {
              if (line != '') {
                line = line.replace('\r', '').split(',');
                data.push({
                  name: line[7],
                  identifier: line[1],
                  type: 'disk',
                  fstype: line[5].toLowerCase(),
                  mount: line[1],
                  size: line[8],
                  physical: line[4] == '5' ? 'CD/DVD' : 'HDD',
                  uuid: line[10],
                  label: line[9],
                  model: '',
                  serial: line[10],
                  removable: line[4] == '2',
                  protocol: ''
                });
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.fsSize(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.<span class="apidocCodeKeywordSpan">blockDevices</span>(cb) | X | X | X | returns array of disks, partitions,&lt;br&gt;
raids and roms |
| - [0].name | X | X | X | name |
| - [0].type | X | X | X | type |
| - [0].fstype | X | X | X | file system type (e.g. ext4) |
| - [0].mount | X | X | X | mount point |
| - [0].size | X | X | X | size in bytes |
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu" id="apidoc.element.systeminformation.cpu">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpu
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpu(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      getCpu().then(result =&gt; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

All functions (except `version` and `time`) are implemented as asynchronous functions. Here a small example how to use them:

```
var si = require('systeminformation');

// callback style
si.<span class="apidocCodeKeywordSpan">cpu</span>(function(data) {
	console.log('CPU-Information:');
	console.log(data);
})

// promises style - new in version 3
si.cpu()
	.then(data =&gt; console.log(data))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuCache" id="apidoc.element.systeminformation.cpuCache">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuCache
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCache(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {};
      if (_linux) {
        exec("lscpu", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              let parts = line.split(':');
              if (parts[0].toUpperCase().indexOf('L1D CACHE') != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf('L1I CACHE') != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf('L2 CACHE') != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf('L3 CACHE') != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              let parts = line.split(':');
              if (parts[0].toLowerCase().indexOf('hw.l1icachesize') != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf('hw.l1dcachesize') != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf('hw.l2cachesize') != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf('hw.l3cachesize') != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.<span class="apidocCodeKeywordSpan">cpuCache</span>(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuCurrentspeed" id="apidoc.element.systeminformation.cpuCurrentspeed">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuCurrentspeed
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCurrentspeed(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = getCpuCurrentSpeedSync();
      if (result == 0 &amp;&amp; _cpu_speed != '0.00') result = parseFloat(_cpu_speed);

      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.<span class="apidocCodeKeywordSpan">cpuCurrentspeed</span>(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.cpuTemperature(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuFlags" id="apidoc.element.systeminformation.cpuFlags">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuFlags
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuFlags(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = '';
      if (_linux) {
        exec("lscpu", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              if (line.split(':')[0].toUpperCase().indexOf('FLAGS') != -1) {
                result = line.split(':')[1].trim().toLowerCase();
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec("sysctl machdep.cpu.features", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            if (lines.length &gt; 0 &amp;&amp; lines[0].indexOf('machdep.cpu.features:') != -1) {
              result = lines[0].split(':')[1].trim().toLowerCase();
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.<span class="apidocCodeKeywordSpan">cpuFlags</span>(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuTemperature" id="apidoc.element.systeminformation.cpuTemperature">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuTemperature
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuTemperature(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      let result = {
        main: -1.0,
        cores: [],
        max: -1.0
      };
      if (_linux) {
        exec("sensors", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              let regex = /\+([^]*)/g;
              let temps = line.match(regex);
              if (line.split(':')[0].toUpperCase().indexOf('PHYSICAL') != -1) {
                result.main = parseFloat(temps);
              }
              if (line.split(':')[0].toUpperCase().indexOf('CORE ') != -1) {
                result.cores.push(parseFloat(temps));
              }
            });
            if (result.cores.length &gt; 0) {
              let maxtmp = Math.max.apply(Math, result.cores);
              result.max = (maxtmp &gt; result.main) ? maxtmp : result.main;
            }
            if (callback) { callback(result) }
            resolve(result);
          } else {
            fs.stat('/sys/class/thermal/thermal_zone0/temp', function(err, stat) {
              if(err == null) {
                exec("cat /sys/class/thermal/thermal_zone0/temp", function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split('\n');
                    if (lines.length &gt; 0) {
                      result.main = parseFloat(lines[0]) / 1000.0;
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              } else {
                exec("/opt/vc/bin/vcgencmd measure_temp", function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split('\n');
                    if (lines.length &gt; 0 &amp;&amp; lines[0].indexOf('=')) {
                      result.main = parseFloat(lines[0].split("=")[1]);
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              }
            });

          }
        });
      }
      if (_darwin) {
        let smc = require('../build/Release/smc');

        let cores = ['TC0P', 'TC1C', 'TC2C', 'TC3C', 'TC4C', 'TC5C', 'TC6C', 'TC7C', 'TC8C'];
        let sum = 0;
        let id = 0;
        cores.forEach(function(key) {
          let value = smc.get(key);
          if (id == 0) {
            if (value &gt; 0) {
              result.main = value;
              result.max = value;
            }
            id = 1;
          } else {
            if (value &gt; 0) {
              result.cores.push(value);
              sum = sum + value;
              if (value &gt; result.max) result.max = value;
            }
          }
        });
        if (result.cores.length) {
          result.main = sum / result.cores.length;
        }

        if (callback) { callback(result) }
        resolve(result);
      }
      if (_windows) {
        exec("wmic /namespace:\\\\root\\wmi PATH MSAcpi_ThermalZoneTemperature get CriticalTripPoint,CurrentTemperature /value",
function (error, stdout) {
          if (!error) {
            let sum = 0;
            let lines = stdout.trim().split(/\s\s+/);
            lines.forEach(function (line) {
              if (line.match('CriticalTripPoint') &amp;&amp; !result.max)
                result.max = (parseInt(line.split('CriticalTripPoint=')[1]) - 2732) / 10;
              else if (line.match('CurrentTemperature')) {
                let value = (parseInt(line.split('CurrentTemperature=')[1]) - 2732) / 10;
                sum = sum + value;
                result.cores.push(value);
              }
            });
            if (result.cores.length) {
              result.main = sum / result.cores.length;
            }
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.<span class="apidocCodeKeywordSpan">cpuTemperature</span>(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
| si.mem(cb) | X | X | X | Memory information|
| - total | X | X | X | total memory |
| - free | X | X | X | not used |
| - used | X | X | X | used (incl. buffers/cache) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.currentLoad" id="apidoc.element.systeminformation.currentLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>currentLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function currentLoad(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      getLoad().then(result =&gt; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkConnections(cb) | X | X |  | current network network connections&lt;br&gt;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.<span class="apidocCodeKeywordSpan">currentLoad</span>(cb) | X | X |  | CPU-Load |
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.disksIO" id="apidoc.element.systeminformation.disksIO">
        function <span class="apidocSignatureSpan">systeminformation.</span>disksIO
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disksIO(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: -1,
        wIO_sec: -1,
        tIO_sec: -1,
        ms: 0
      };
      let rIO = 0;
      let wIO = 0;

      if ((_disk_io &amp;&amp; !_disk_io.ms) || (_disk_io &amp;&amp; _disk_io.ms &amp;&amp; Date.now() - _disk_io.ms &gt;= 500)) {
        if (_linux) {
          // prints Block layer statistics for all mounted volumes
          // var cmd = "for mount in `lsblk | grep / | sed -r 's/ //' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed
 -r 's/ +/;/g' | sed -r 's/^;//'; done";
          // var cmd = "for mount in `lsblk | grep / | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /
sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done";
          let cmd = "for mount in `lsblk | grep ' disk ' | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do
cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done";

          exec(cmd, function (error, stdout) {
            if (!error) {
              let lines = stdout.split('\n');
              lines.forEach(function (line) {
                // ignore empty lines
                if (!line) return;

                // sum r/wIO of all disks to compute all disks IO
                let stats = line.split(';');
                rIO += parseInt(stats[0]);
                wIO += parseInt(stats[4]);
              });
              result = calcDiskIO(rIO, wIO);

              if (callback) {
                callback(result)
              }
              resolve(result);
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          });
        }
        if (_darwin) {
          exec("ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics
' | tr -cd '01234567890,\n' | awk -F',' '{print $1, $11}'", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              lines.forEach(function (line) {
                line = line.trim();
                if (line != '') {
                  line = line.split(' ');

                  rIO += parseInt(line[1]);
                  wIO += parseInt(line[0]);
                }
              });
              result = calcDiskIO(rIO, wIO);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.rIO = _disk_io.rIO;
        result.wIO = _disk_io.wIO;
        result.tIO = _disk_io.rIO + _disk_io.wIO;
        result.ms = _disk_io.last_ms;
        result.rIO_sec = _disk_io.rIO_sec;
        result.wIO_sec = _disk_io.wIO_sec;
        result.tIO_sec = _disk_io.tIO_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">disksIO</span>(cb) | X | X |  | current transfer stats |
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerAll" id="apidoc.element.systeminformation.dockerAll">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerAll
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerAll(callback) {
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      dockerContainers(true).then(result =&gt; {
        if (result &amp;&amp; Object.prototype.toString.call(result) === '[object Array]' &amp;&amp; result.length &gt; 0) {
          let l = result.length;
          result.forEach(function (element) {
            dockerContainerStats(element.id).then(res =&gt; {
              // include stats in array
              element.mem_usage = res.mem_usage;
              element.mem_limit = res.mem_limit;
              element.mem_percent = res.mem_percent;
              element.cpu_percent = res.cpu_percent;
              element.pids = res.pids;
              element.netIO = res.netIO;
              element.blockIO = res.blockIO;
              element.cpu_stats = res.cpu_stats;
              element.precpu_stats = res.precpu_stats;
              element.memory_stats = res.memory_stats;
              element.networks = res.networks;

              dockerContainerProcesses(element.id).then(processes =&gt; {
                element.processes = processes;

                l -= 1;
                if (l == 0) {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
              // all done??
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].stat | X | X |  | process state |
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.<span class="apidocCodeKeywordSpan">dockerAll</span>(cb) | X | X |  | list of all containers including their stats&lt;br&amp;#
x3e;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainerProcesses" id="apidoc.element.systeminformation.dockerContainerProcesses">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerProcesses
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerProcesses(containerID, callback) {
  containerID = containerID || '';
  let result = [];
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getProcesses(containerID, data =&gt; {
<span class="apidocCodeCommentSpan">          /**
           * @namespace
           * @property {Array}  Titles
           * @property {Array}  Processes
           **/
</span>           try {
            if (data &amp;&amp; data.Titles &amp;&amp; data.Processes) {
              let titles = data.Titles.map(function(value) {
                return value.toUpperCase();
              });
              let pos_pid = titles.indexOf('PID');
              let pos_ppid = titles.indexOf('PPID');
              let pos_pgid = titles.indexOf('PGID');
              let pos_vsz = titles.indexOf('VSZ');
              let pos_time = titles.indexOf('TIME');
              let pos_elapsed = titles.indexOf('ELAPSED');
              let pos_ni = titles.indexOf('NI');
              let pos_ruser = titles.indexOf('RUSER');
              let pos_user = titles.indexOf('USER');
              let pos_rgroup = titles.indexOf('RGROUP');
              let pos_group = titles.indexOf('GROUP');
              let pos_stat = titles.indexOf('STAT');
              let pos_rss = titles.indexOf('RSS');
              let pos_command = titles.indexOf('COMMAND');

              data.Processes.forEach(process =&gt; {
                result.push({
                  pid_host: (pos_pid &gt;= 0 ? process[pos_pid] : ''),
                  ppid: (pos_ppid &gt;= 0 ? process[pos_ppid] : ''),
                  pgid: (pos_pgid &gt;= 0 ? process[pos_pgid] : ''),
                  user: (pos_user &gt;= 0 ? process[pos_user] : ''),
                  ruser: (pos_ruser &gt;= 0 ? process[pos_ruser] : ''),
                  group: (pos_group &gt;= 0 ? process[pos_group] : ''),
                  rgroup: (pos_rgroup &gt;= 0 ? process[pos_rgroup] : ''),
                  stat: (pos_stat &gt;= 0 ? process[pos_stat] : ''),
                  time: (pos_time &gt;= 0 ? process[pos_time] : ''),
                  elapsed: (pos_elapsed &gt;= 0 ? process[pos_elapsed] : ''),
                  nice: (pos_ni &gt;= 0 ? process[pos_ni] : ''),
                  rss: (pos_rss &gt;= 0 ? process[pos_rss] : ''),
                  vsz: (pos_vsz &gt;= 0 ? process[pos_vsz] : ''),
                  command: (pos_command &gt;= 0 ? process[pos_command] : '')
                })
              })
            }
          } catch (err) {
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - netIO.wx | X | X |  | sent bytes via network |
| - blockIO.r | X | X |  | bytes read from BlockIO |
| - blockIO.w | X | X |  | bytes written to BlockIO |
| - cpu_stats | X | X |  | detailed cpu stats |
| - percpu_stats | X | X |  | detailed per cpu stats |
| - memory_stats | X | X |  | detailed memory stats |
| - networks | X | X |  | detailed network stats per interface |
| si.<span class="apidocCodeKeywordSpan">dockerContainerProcesses</span>(id, cb) | X | X |  | array of processes inside a container
 |
| - [0].pid_host | X | X |  | process ID (host) |
| - [0].ppid | X | X |  | parent process ID |
| - [0].pgid | X | X |  | process group ID |
| - [0].user | X | X |  | effective user name |
| - [0].ruser | X | X |  | real user name |
| - [0].group | X | X |  | effective group name |
| - [0].rgroup | X | X |  | real group name |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainerStats" id="apidoc.element.systeminformation.dockerContainerStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerStats
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerStats(containerID, callback) {
  containerID = containerID || '';
  let result = {
    id: containerID,
    mem_usage: 0,
    mem_limit: 0,
    mem_percent: 0,
    cpu_percent: 0,
    pids: 0,
    netIO: {
      rx: 0,
      wx: 0
    },
    blockIO: {
      r: 0,
      w: 0
    }
  };
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getStats(containerID, data =&gt; {
          // let cmd = "curl --unix-socket /var/run/docker.sock http:/containers/" + containerID + "/stats?stream=0";
          // exec(cmd, function (error, stdout) {
          //   if (!error) {
          //     let jsonString = stdout.toString();
          try {
//              let stats = JSON.parse(jsonString);
            let stats = data;
<span class="apidocCodeCommentSpan">            /**
             * @namespace
             * @property {Object}  memory_stats
             * @property {number}  memory_stats.usage
             * @property {number}  memory_stats.limit
             * @property {Object}  cpu_stats
             * @property {Object}  pids_stats
             * @property {number}  pids_stats.current
             * @property {Object}  networks
             * @property {Object}  blkio_stats
             */
</span>
            if (!stats.message) {
              result.mem_usage = (stats.memory_stats &amp;&amp; stats.memory_stats.usage ? stats.memory_stats.usage : 0);
              result.mem_limit = (stats.memory_stats &amp;&amp; stats.memory_stats.limit ? stats.memory_stats.limit : 0);
              result.mem_percent = (stats.memory_stats &amp;&amp; stats.memory_stats.usage &amp;&amp; stats.memory_stats.limit ? stats.memory_stats
.usage / stats.memory_stats.limit * 100.0 : 0);
              result.cpu_percent = (stats.cpu_stats ? docker_calcCPUPercent(stats.cpu_stats, containerID) : 0);
              result.pids = (stats.pids_stats &amp;&amp; stats.pids_stats.current ? stats.pids_stats.current : 0);
              if (stats.networks) result.netIO = docker_calcNetworkIO(stats.networks);
              if (stats.blkio_stats) result.blockIO = docker_calcBlockIO(stats.blkio_stats);
              result.cpu_stats = (stats.cpu_stats ? stats.cpu_stats : {});
              result.precpu_stats = (stats.precpu_stats ? stats.precpu_stats : {});
              result.memory_stats = (stats.memory_stats ? stats.memory_stats : {});
              result.networks = (stats.networks ? stats.networks : {});
            }
          } catch (err) {
          }
          // }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
| - [0].ports | X | X |  | array of ports |
| - [0].mounts | X | X |  | array of mounts |
| si.<span class="apidocCodeKeywordSpan">dockerContainerStats</span>(id, cb) | X | X |  | statistics for a specific container |
| - id | X | X |  | Container ID |
| - mem_usage | X | X |  | memory usage in bytes |
| - mem_limit | X | X |  | memory limit (max mem) in bytes |
| - mem_percent | X | X |  | memory usage in percent |
| - cpu_percent | X | X |  | cpu usage in percent |
| - pids | X | X |  | number of processes |
| - netIO.rx | X | X |  | received bytes via network |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainers" id="apidoc.element.systeminformation.dockerContainers">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainers
        <span class="apidocSignatureSpan">(all, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainers(all, callback) {

  function inContainers(containers, id) {
    let filtered = containers.filter(obj =&gt; {
<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {string}  Id
       */
</span>      return (obj.Id &amp;&amp; (obj.Id == id))
    });
    return (filtered.length &gt; 0);
  }

  // fallback - if only callback is given
  if (util.isFunction(all) &amp;&amp; !callback) {
    callback = all;
    all = false;
  }

  all = all || false;
  let result = [];
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      if (!_docker_socket) {
        _docker_socket = new DockerSocket();
      }

      _docker_socket.listContainers(all, data =&gt; {
        let docker_containers = {};
        // let cmd = "curl --unix-socket /var/run/docker.sock http:/containers/json" + (all ? "?all=1" : "");
        // exec(cmd, function (error, stdout) {
        //   if (!error) {
        try {
          //       let jsonString = stdout.toString();
          //       let docker_containers = JSON.parse(jsonString);
          docker_containers = data;
          if (docker_containers &amp;&amp; Object.prototype.toString.call(docker_containers) === '[object Array]' &amp;&amp; docker_containers.length
 &gt; 0) {
            docker_containers.forEach(function (element) {
              /**
               * @namespace
               * @property {string}  Id
               * @property {string}  Name
               * @property {string}  Image
               * @property {string}  ImageID
               * @property {string}  Command
               * @property {number}  Created
               * @property {string}  State
               * @property {Array}  Names
               * @property {Array}  Ports
               * @property {Array}  Mounts
               */

              if (element.Names &amp;&amp; Object.prototype.toString.call(element.Names) === '[object Array]' &amp;&amp; element.Names.length &gt;
0) {
                element.Name = element.Names[0].replace(/^\/|\/$/g, '');
              }
              result.push({
                id: element.Id,
                name: element.Name,
                image: element.Image,
                imageID: element.ImageID,
                command: element.Command,
                created: element.Created,
                state: element.State,
                ports: element.Ports,
                mounts: element.Mounts,
                // hostconfig: element.HostConfig,
                // network: element.NetworkSettings
              })
            });
          }
        } catch (err) {
        }
        // }

        // GC in _docker_container_stats
        for (let key in _docker_container_stats) {
          if (_docker_container_stats.hasOwnProperty(key)) {
            if (!inContainers(docker_containers, key)) delete _docker_container_stats[key];
          }
        }
        if (callback) { callback(result) }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&lt;br&gt;host parameter is optional (default
 8.8.8.8)|
| si.<span class="apidocCodeKeywordSpan">dockerContainers</span>(all, cb) | X | X |  | returns array of active/all docker containers
 |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerSocket" id="apidoc.element.systeminformation.dockerSocket">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerSocket
        <span class="apidocSignatureSpan">(all, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DockerSocket {

  listContainers(all, callback) {
    try {

      let socket = net.createConnection({path: '/var/run/docker.sock'});
      let alldata = '';

      socket.on("connect", () =&gt; {
        socket.write('GET http:/containers/json' + (all ? "?all=1" : "") + ' HTTP/1.0\r\n\r\n');
      });

      socket.on("data", data =&gt; {
        alldata = alldata + data.toString();
      });

      socket.on("error", () =&gt; {
        socket = false;
        callback({});
      });

      socket.on('end', () =&gt; {
        let startbody = alldata.indexOf("\r\n\r\n");
        alldata = alldata.substring(startbody, 100000).replace(/[\n\r]/g, '');
        socket = false;
        callback(JSON.parse(alldata));
      });
    } catch (err) {
      callback({});
    }
  }

  getStats(id, callback) {
    id = id || '';
    if (id) {
      try {
        let socket = net.createConnection({path: '/var/run/docker.sock'});
        let alldata = '';

        socket.on("connect", () =&gt; {
          socket.write('GET http:/containers/' + id + '/stats?stream=0 HTTP/1.0\r\n\r\n');
        });

        socket.on("data", data =&gt; {
          alldata = alldata + data.toString();
        });

        socket.on("error", () =&gt; {
          socket = false;
          callback({});
        });

        socket.on('end', () =&gt; {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody, 100000).replace(/[\n\r]/g, '');
          socket = false;
          callback(JSON.parse(alldata));
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }

  getProcesses(id, callback) {
    id = id || '';
    if (id) {
      try {
        let socket = net.createConnection({path: '/var/run/docker.sock'});
        let alldata = '';

        socket.on("connect", () =&gt; {
          socket.write('GET http:/containers/' + id + '/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,
stat,rss,args HTTP/1.0\r\n\r\n');
        });

        socket.on("data", data =&gt; {
          alldata = alldata + data.toString();
        });

        socket.on("error", () =&gt; {
          socket = false;
          callback({});
        });

        socket.on('end', () =&gt; {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody, 100000).replace(/[\n\r]/g, '');
          socket = false;
          callback(JSON.parse(alldata));
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.fsSize" id="apidoc.element.systeminformation.fsSize">
        function <span class="apidocSignatureSpan">systeminformation.</span>fsSize
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsSize(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_linux || _darwin) {
        let cmd = (_darwin ? "df -lkP | grep ^/" : "df -lkPT | grep ^/");
        exec(cmd, function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split('\n');
            //lines.splice(0, 1);
            lines.forEach(function (line) {
              if (line != '') {
                line = line.replace(/ +/g, " ").split(' ');
                data.push({
                  'fs': line[0],
                  'type': (_linux ? line[1] : 'HFS'),
                  'size': parseInt((_linux ? line[2] : line[1])) * 1024,
                  'used': parseInt((_linux ? line[3] : line[2])) * 1024,
                  'use': parseFloat((100.0 * (_linux ? line[3] : line[2]) / (_linux ? line[2] : line[1])).toFixed(2)),
                  'mount': line[line.length - 1]
                })
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec('wmic logicaldisk get Caption,FileSystem,FreeSpace,Size', function (error, stdout) {
          let lines = stdout.split('\r\n').filter(line =&gt; line.trim() != '').filter((line, idx) =&gt; idx &gt; 0);
          lines.forEach(function (line) {
            if (line != '') {
              line = line.trim().split(/\s\s+/);
              data.push({
                'fs': line[0],
                'type': line[1],
                'size': line[3],
                'used': parseInt(line[3]) - parseInt(line[2]),
                'use': parseFloat((100.0 * (parseInt(line[3]) - parseInt(line[2]))) / parseInt(line[3])),
                'mount': line[0]
              })
            }
          });
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - displays[0].builtin | X | X |  | true if built in monitor |
| - displays[0].connection | X | X |  | e.g. DisplayPort or HDMI |
| - displays[0].resolutionx | X | X |  | pixel horizontal |
| - displays[0].resolutiony | X | X |  | pixel vertical |
| - displays[0].depth | X | X |  | color depth in bits |
| - displays[0].sizex | X | X |  | size in mm horizontal |
| - displays[0].sizey | X | X |  | size in mm vertical |
| si.<span class="apidocCodeKeywordSpan">fsSize</span>(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.blockDevices(cb) | X | X | X | returns array of disks, partitions,&lt;br&gt;raids and roms |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.fsStats" id="apidoc.element.systeminformation.fsStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>fsStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsStats(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: -1,
        wx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let rx = 0;
      let wx = 0;
      if ((_fs_speed &amp;&amp; !_fs_speed.ms) || (_fs_speed &amp;&amp; _fs_speed.ms &amp;&amp; Date.now() - _fs_speed.ms &gt;= 500)) {
        if (_linux) {
//  		  exec("df -k | grep /dev/", function(error, stdout) {
          exec("lsblk | grep /", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              let fs_filter = [];
              lines.forEach(function (line) {
                if (line != '') {
                  line = line.replace(/[]+/g, "").trim().split(' ');
                  if (fs_filter.indexOf(line[0]) == -1) fs_filter.push(line[0])
                }
              });

              let output = fs_filter.join('|');
              exec("cat /proc/diskstats | egrep '" + output + "'", function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split('\n');
                  lines.forEach(function (line) {
                    line = line.trim();
                    if (line != '') {
                      line = line.replace(/ +/g, " ").split(' ');

                      rx += parseInt(line[5]) * 512;
                      wx += parseInt(line[9]) * 512;
                    }
                  });
                  result = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result)
                }
                resolve(result);
              })
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          })
        }
        if (_darwin) {
          exec("ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics
' | tr -cd '01234567890,\n' | awk -F',' '{print $3, $10}'", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              lines.forEach(function (line) {
                line = line.trim();
                if (line != '') {
                  line = line.split(' ');

                  rx += parseInt(line[0]);
                  wx += parseInt(line[1]);
                }
              });
              result = calcFsSpeed(rx, wx);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.ms = _fs_speed.last_ms;
        result.rx = _fs_speed.bytes_read;
        result.wx = _fs_speed.bytes_write;
        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
        result.rx_sec = _fs_speed.rx_sec;
        result.wx_sec = _fs_speed.wx_sec;
        result.tx_sec = _fs_speed.tx_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
| - [0].label | X | X | X | label |
| - [0].model | X | X |  | model |
| - [0].serial | X |  | X | serial |
| - [0].removable | X | X | X | serial |
| - [0].protocol | X | X |  | protocol (SATA, PCI-Express, ...) |
| si.<span class="apidocCodeKeywordSpan">fsStats</span>(cb) | X | X |  | current transfer stats |
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.fullLoad" id="apidoc.element.systeminformation.fullLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>fullLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fullLoad(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      getFullLoad().then(result =&gt; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.<span class="apidocCodeKeywordSpan">fullLoad</span>(cb) | X | X |  | CPU-full load since bootup in % |
| si.services('mysql, apache2', cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.getAllData" id="apidoc.element.systeminformation.getAllData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getAllData
        <span class="apidocSignatureSpan">(srv, iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAllData(srv, iface, callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let data = {};

      getStaticData().then(res =&gt; {
        data = res;
        getDynamicData(srv, iface).then(res =&gt; {
          for (let key in res) {
            if (res.hasOwnProperty(key)) {
              data[key] = res[key];
            }
          }
          if (callback) { callback(data) }
          resolve(data);
        });
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&lt;br&gt;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.<span class="apidocCodeKeywordSpan">getAllData</span>(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:

**Callback Style**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.getDynamicData" id="apidoc.element.systeminformation.getDynamicData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getDynamicData
        <span class="apidocSignatureSpan">(srv, iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDynamicData(srv, iface, callback) {

  if (util.isFunction(iface)) {
    callback = iface;
    iface = '';
  }
  if (util.isFunction(srv)) {
    callback = srv;
    srv = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      iface = iface || network.getDefaultNetworkInterface();
      srv = srv || '';

      // use closure to track  completion
      let functionProcessed = (function () {
        let totalFunctions = 14;

        return function () {
          if (--totalFunctions === 0) {
            if (callback) { callback(data) }
            resolve(data);
          }
        };
      })();

      // var totalFunctions = 14;
      // function functionProcessed() {
      //   if (--totalFunctions === 0) {
      //     if (callback) { callback(data) }
      //     resolve(data);
      //   }
      // }

      let data = {};

      // get time
      data.time = osInfo.time();

<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {Object}  versions
       * @property {string}  versions.node
       * @property {string}  versions.v8
       */
</span>      data.node = process.versions.node;
      data.v8 = process.versions.v8;

      cpu.cpuCurrentspeed().then(res =&gt; {
        data.cpuCurrentspeed = res;
        functionProcessed();
      });

      users.users().then(res =&gt; {
        data.users = res;
        functionProcessed();
      });

      processes.processes().then(res =&gt; {
        data.processes = res;
        functionProcessed();
      });

      cpu.currentLoad().then(res =&gt; {
        data.currentLoad = res;
        functionProcessed();
      });

      cpu.cpuTemperature().then(res =&gt; {
        data.temp = res;
        functionProcessed();
      });

      network.networkStats(iface).then(res =&gt; {
        data.networkStats = res;
        functionProcessed();
      });

      network.networkConnections().then(res =&gt; {
        data.networkConnections = res;
        functionProcessed();
      });

      mem().then(res =&gt; {
        data.mem = res;
        functionProcessed();
      });

      battery().then(res =&gt; {
        data.battery = res;
        functionProcessed();
      });

      processes.services(srv).then(res =&gt; {
        data.services = res;
        functionProcessed();
      });

      filesystem.fsSize().then(res =&gt; {
        data.fsSize = res;
        functionProcessed();
      });

      filesystem.fsStats().then(res =&gt; {
        data.fsStats = res;
        functionProcessed();
      });

      filesystem.disksIO().then(res =&gt; {
        data.disksIO = res;
        functionProcessed();
      });

      internet.inetLatency().then(res =&gt; {
        data.inetLatency = res;
        functionProcessed();
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&lt;br&gt;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.<span class="apidocCodeKeywordSpan">getDynamicData</span>(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:

**Callback Style**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.getStaticData" id="apidoc.element.systeminformation.getStaticData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getStaticData
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStaticData(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let data = {};

      data.version = version();

      system().then(res =&gt; {
        data.system = res;
        osInfo.osInfo().then(res =&gt; {
          data.os = res;
          osInfo.versions().then(res =&gt; {
            data.versions = res;
            cpu.cpu().then(res =&gt; {
              data.cpu = res;
              graphics.graphics().then(res =&gt; {
                data.graphics = res;
                network.networkInterfaces().then(res =&gt; {
                  data.net = res;
                  if (callback) { callback(data) }
                  resolve(data);
                })
              })
            })
          })
        })
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&lt;br&gt;and processes in one single array |
| si.<span class="apidocCodeKeywordSpan">getStaticData</span>(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.graphics" id="apidoc.element.systeminformation.graphics">
        function <span class="apidocSignatureSpan">systeminformation.</span>graphics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function graphics(callback) {

  function parseLinesDarwin(lines) {
    let starts = [];
    let level = -1;
    let lastlevel = -1;
    let controllers = [];
    let displays = [];
    let currentController = {};
    let currentDisplay = {};
    for (let i = 0; i &lt; lines.length; i++) {
      if ('' != lines[i].trim()) {
        let start = lines[i].search(/\S|$/);
        if (-1 == starts.indexOf(start)) {
          starts.push(start);
        }
        level = starts.indexOf(start);
        if (level &lt; lastlevel) {
          if (Object.keys(currentController).length &gt; 0) {// just changed to Displays
            controllers.push(currentController);
            currentController = {};
          }
          if (Object.keys(currentDisplay).length &gt; 0) {// just changed to Displays
            displays.push(currentDisplay);
            currentDisplay = {};
          }
        }
        lastlevel = level;
        let parts = lines[i].split(':');
        if (2 == level) {       // grafics controller level
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('chipsetmodel') != -1) currentController.model
 = parts[1].trim();
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('bus') != -1) currentController.bus = parts[
1].trim();
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('vendor') != -1) currentController.vendor =
parts[1].split('(')[0].trim();
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('vram(total)') != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = false;
          }
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('vram(dynamic,max)') != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = true;
          }
        }
        if (3 == level) {       // display controller level
          if (parts.length &gt; 1 &amp;&amp; '' == parts[1]) {
            currentDisplay.model = parts[0].trim();
            currentDisplay.main = false;
            currentDisplay.builtin = false;
            currentDisplay.connection = '';
            currentDisplay.sizex = -1;
            currentDisplay.sizey = -1;
          }
        }
        if (4 == level) {       // display controller details level
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('resolution') != -1) {
            let resolution = parts[1].split('x');
            currentDisplay.resolutionx = (resolution.length &gt; 1 ? parseInt(resolution[0]) : 0);
            currentDisplay.resolutiony = (resolution.length &gt; 1 ? parseInt(resolution[1]) : 0);
          }
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('pixeldepth') != -1) currentDisplay.pixeldepth
 = parseInt(parts[1]); // in BIT
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('maindisplay') != -1 &amp;&amp; parts[1].replace(/ +/
g, "").toLowerCase() == 'yes') currentDisplay.main = true;
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('built-in') != -1 &amp;&amp; parts[1].replace(/ +/g, "").
toLowerCase() == 'yes') {
            currentDisplay.builtin = true;
            currentDisplay.connection = '';
          }
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('connectiontype') != -1) {
            currentDisplay.builtin = false;
            currentDisplay.connection = parts[1].trim();
          }
        }
      }
    }
    if (Object.keys(currentController).length &gt; 0) {// just changed to Displays
      controllers.push(currentController);
    }
    if (Object.keys(currentDisplay).length &gt; 0) {// just changed to Displays
      displays.push(currentDisplay);
    }
    return ({
      controllers: controllers,
      displays: displays
    })
  }

  function parseLinesLinuxControllers(lines) {
    let controllers = [];
    let currentController = {};
    let is_vga = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - swapfree | X | X |  |  |
| si.battery(cb) | X | X |  | battery information |
| - hasbattery | X | X |  | indicates presence of battery |
| - ischarging | X | X |  | indicates if battery is charging |
| - maxcapacity | X | X |  | max capacity of battery |
| - currentcapacity | X | X |  | current capacity of battery |
| - percent | X | X |  | charging level in percent |
| si.<span class="apidocCodeKeywordSpan">graphics</span>(cb) | X | X |  | arrays of graphics controllers and displays |
| - controllers[0].model | X | X |  | graphics controller model |
| - controllers[0].vendor | X | X |  | e.g. ATI |
| - controllers[0].bus | X | X |  | on which bus (e.g. PCIe) |
| - controllers[0].vram | X | X |  | VRAM size (in MB) |
| - controllers[0].vramDynamic | X | X |  | true if dynamicly allocated ram |
| - displays[0].model | X | X |  | Monitor/Display Model |
| - displays[0].main | X | X |  | true if main monitor |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.inetChecksite" id="apidoc.element.systeminformation.inetChecksite">
        function <span class="apidocSignatureSpan">systeminformation.</span>inetChecksite
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetChecksite(url, callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        url: url,
        ok: false,
        status: 404,
        ms: -1
      };
      if (url) {
        let t = Date.now();
        let args = " -I --connect-timeout 5 -m 5 " + url + " 2&gt;/dev/null | head -n 1 | cut -d ' ' -f2";
        let cmd = "curl";
        exec(cmd + args, function (error, stdout) {
          let statusCode = parseInt(stdout.toString());
          result.status = statusCode || 404;
          result.ok = !error &amp;&amp; (statusCode == 200 || statusCode == 301 || statusCode == 302 || statusCode == 304);
          result.ms = (result.ok ? Date.now() - t : -1);
          if (callback) { callback(result) }
          resolve(result);
        })
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.<span class="apidocCodeKeywordSpan">inetChecksite</span>(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&lt;br&gt;host parameter is optional (default
 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.inetLatency" id="apidoc.element.systeminformation.inetLatency">
        function <span class="apidocSignatureSpan">systeminformation.</span>inetLatency
        <span class="apidocSignatureSpan">(host, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetLatency(host, callback) {

  // fallback - if only callback is given
  if (util.isFunction(host) &amp;&amp; !callback) {
    callback = host;
    host = '';
  }

  host = host || '8.8.8.8';

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let t = Date.now();
      let cmd;
      if (_linux) {
        cmd = "ping -c 2 -w 3 " + host + " | grep rtt | cut -d'/' -f4 | awk '{ print $3 }'";
      }
      if (_darwin) {
        cmd = "ping -c 2 -t 3 " + host + " | grep avg | cut -d'/' -f4 | awk '{ print $3 }'";
      }

      exec(cmd, function (error, stdout) {
        let result = -1;
        if (!error) {
          result = parseFloat(stdout.toString());
        }
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.<span class="apidocCodeKeywordSpan">inetLatency</span>(host, cb) | X | X |  | response-time (ms) to external resource&lt;
br&gt;host parameter is optional (default 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.mem" id="apidoc.element.systeminformation.mem">
        function <span class="apidocSignatureSpan">systeminformation.</span>mem
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mem = function (callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {

      let result = {
        total: os.totalmem(),
        free: os.freemem(),
        used: os.totalmem() - os.freemem(),

        active: os.totalmem() - os.freemem(),     // temporarily (fallback)
        available: os.freemem(),                  // temporarily (fallback)
        buffcache: 0,

        swaptotal: 0,
        swapused: 0,
        swapfree: 0
      };

      if (_linux) {
        exec("free -b", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');

            let mem = lines[1].replace(/ +/g, " ").split(' ');
            result.total = parseInt(mem[1]);
            result.free = parseInt(mem[3]);

            if (lines.length === 4) {                   // free (since free von procps-ng 3.3.10)
              result.buffcache = parseInt(mem[5]);
              result.available = parseInt(mem[6]);
              mem = lines[2].replace(/ +/g, " ").split(' ');
            } else {                                    // free (older versions)
              result.buffcache = parseInt(mem[5]) + parseInt(mem[6]);
              result.available = result.free + result.buffcache;
              mem = lines[3].replace(/ +/g, " ").split(' ');
            }
            result.active = result.total - result.free - result.buffcache;

            result.swaptotal = parseInt(mem[1]);
            result.swapfree = parseInt(mem[3]);
            result.swapused = parseInt(mem[2]);

          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec("vm_stat | grep 'Pages active'", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');

            result.active = parseInt(lines[0].split(':')[1]) * 4096;
            result.buffcache = result.used - result.active;
            result.available = result.free + result.buffcache;
          }
          exec("sysctl -n vm.swapusage", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              if (lines.length &gt; 0) {
                let line = lines[0].replace(/,/g, ".").replace(/M/g, "");
                line = line.trim().split('  ');
                for (let i = 0; i &lt; line.length; i++) {
                  if (line[i].toLowerCase().indexOf('total') != -1) result.swaptotal = parseFloat(line[i].split('=')[1].trim()) *
1024 * 1024;
                  if (line[i].toLowerCase().indexOf('used') != -1) result.swapused = parseFloat(line[i].split('=')[1].trim()) *
1024 * 1024;
                  if (line[i].toLowerCase().indexOf('free') != -1) result.swapfree = parseFloat(line[i].split('=')[1].trim()) *
1024 * 1024;

                }
              }
            }
            if (callback) { callback(result) }
            resolve(result);
          });
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.cpuTemperature(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
| si.<span class="apidocCodeKeywordSpan">mem</span>(cb) | X | X | X | Memory information|
| - total | X | X | X | total memory |
| - free | X | X | X | not used |
| - used | X | X | X | used (incl. buffers/cache) |
| - active | X | X | X | used actively (excl. buffers/cache)  |
| - buffcache | X | X |  | used by buffers+cache |
| - available | X | X | X | potentially available (total - active) |
| - swaptotal | X | X |  |  |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkConnections" id="apidoc.element.systeminformation.networkConnections">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkConnections
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkConnections(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];
      if (_linux) {
        let cmd = "netstat -tuna | grep 'ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN\\|VERBUNDEN'";
        exec(cmd, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              line = line.replace(/ +/g, " ").split(' ');
              if (line.length &gt;= 6) {
                let localip = line[3];
                let localport = '';
                let localaddress = line[3].split(':');
                if (localaddress.length &gt; 1) {
                  localport = localaddress[localaddress.length - 1];
                  localaddress.pop();
                  localip = localaddress.join(':');
                }
                let peerip = line[4];
                let peerport = '';
                let peeraddress = line[4].split(':');
                if (peeraddress.length &gt; 1) {
                  peerport = peeraddress[peeraddress.length - 1];
                  peeraddress.pop();
                  peerip = peeraddress.join(':');
                }
                let connstate = line[5];
                if (connstate == 'VERBUNDEN') connstate = 'ESTABLISHED';
                if (connstate) {
                  result.push({
                    protocol: line[0],
                    localaddress: localip,
                    localport: localport,
                    peeraddress: peerip,
                    peerport: peerport,
                    state: connstate
                  })
                }
              }
            });
            if (callback) {
              callback(result)
            }
            resolve(result);
          } else {
            cmd = "ss -tuna | grep 'ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-
ACK\\|LISTEN\\|CLOSING'";
            exec(cmd, function (error, stdout) {

              if (!error) {
                let lines = stdout.toString().split('\n');
                lines.forEach(function (line) {
                  line = line.replace(/ +/g, " ").split(' ');
                  if (line.length &gt;= 6) {
                    let localip = line[4];
                    let localport = '';
                    let localaddress = line[4].split(':');
                    if (localaddress.length &gt; 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(':');
                    }
                    let peerip = line[5];
                    let peerport = '';
                    let peeraddress = line[5].split(':');
                    if (peeraddress.length &gt; 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(':');
                    }
                    let connstate = line[1];
                    if (connstate == 'ESTAB') connstate = 'ESTABLISHED';
                    if (connstate == 'TIME-WAIT') connstate = 'TIME_WAIT';
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localaddress: localip,
                        localport: localport,
                        peeraddress: peerip,
                        peerport: peerport,
                        state: connstate
                      })
                    }
                  }
                });
              }
              if (callback) {
                callback(result)
              }
              resolve(result);
            })
          }
        })
      }
      if (_darwin) {
        l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkConnections</span>(cb) | X | X |  | current network network connections&lt;br&amp;#
x3e;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.currentLoad(cb) | X | X |  | CPU-Load |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkInterfaceDefault" id="apidoc.element.systeminformation.networkInterfaceDefault">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaceDefault
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaceDefault(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = getDefaultNetworkInterface();
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ms | X | X |  | interval length (for per second values) |
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.<span class="apidocCodeKeywordSpan">networkInterfaceDefault</span>(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&lt;br&gt;iface parameter is optional&lt;
br&gt;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkInterfaces" id="apidoc.element.systeminformation.networkInterfaces">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaces
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaces(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let ifaces = os.networkInterfaces();
      let result = [];

      for (let dev in ifaces) {
        let ip4 = '';
        let ip6 = '';
        let mac = '';
        if (ifaces.hasOwnProperty(dev)) {
          ifaces[dev].forEach(function (details) {
            if (details.family == 'IPv4') {
              ip4 = details.address
            }
            if (details.family == 'IPv6') {
              ip6 = details.address
            }
            mac = details.mac
          });
          let internal = (ifaces[dev] &amp;&amp; ifaces[dev][0]) ? ifaces[dev][0].internal : null;
          result.push({ iface: dev, ip4: ip4, ip6: ip6, mac: mac, internal: internal })
        }
      }
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkInterfaces</span>(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&lt;br&gt;iface parameter is optional&lt;
br&gt;defaults to first external network interface|
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkStats" id="apidoc.element.systeminformation.networkStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkStats
        <span class="apidocSignatureSpan">(iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkStats(iface, callback) {

  // fallback - if only callback is given
  if (util.isFunction(iface) &amp;&amp; !callback) {
    callback = iface;
    iface = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      _default_iface = _default_iface || getDefaultNetworkInterface();
      iface = iface || _default_iface; // (_darwin ? 'en0' : 'eth0');

      let result = {
        iface: iface,
        operstate: 'unknown',
        rx: 0,
        tx: 0,
        rx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let operstate = 'unknown';
      let rx = 0;
      let tx = 0;

      let cmd, lines, stats;
      if (!_network[iface] || (_network[iface] &amp;&amp; !_network[iface].ms) || (_network[iface] &amp;&amp; _network[iface].ms &amp;&amp; Date.now() -
_network[iface].ms &gt;= 500)) {
        if (_linux) {
          if (fs.existsSync('/sys/class/net/' + iface)) {
            cmd =
              "cat /sys/class/net/" + iface + "/operstate; " +
              "cat /sys/class/net/" + iface + "/statistics/rx_bytes; " +
              "cat /sys/class/net/" + iface + "/statistics/tx_bytes; ";
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split('\n');
                operstate = lines[0].trim();
                rx = parseInt(lines[1]);
                tx = parseInt(lines[2]);

                result = calcNetworkSpeed(iface, rx, tx, operstate);

              }
              if (callback) { callback(result) }
              resolve(result);
            });
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        }
        if (_darwin) {
          cmd = "ifconfig " + iface + " | grep 'status'";
          exec(cmd, function (error, stdout) {
            result.operstate = (stdout.toString().split(':')[1] || '').trim();
            result.operstate = (result.operstate || '').toLowerCase();
            result.operstate = (result.operstate == 'active' ? 'up' : (result.operstate == 'inactive' ? 'down' : 'unknown'));
            cmd = "netstat -bI " + iface;
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split('\n');
                // if there is less than 2 lines, no information for this interface was found
                if (lines.length &gt; 1 &amp;&amp; lines[1].trim() != '') {
                  // skip header line
                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address
                  stats = lines[1].replace(/ +/g, " ").split(' ');
                  rx = parseInt(stats[6]);
                  tx = parseInt(stats[9]);

                  result = calcNetworkSpeed(iface, rx, tx, operstate);
                }
              }
              if (callback) { callback(result) }
              resolve(result);
            });
          });
        }
      } else {
        result.rx = _network[iface].rx;
        result.tx = _network[iface].tx;
        result.rx_sec = _network[iface].rx_sec;
        result.tx_sec = _network[iface].tx_sec;
        result.ms = _network[iface].last_ms;
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.<span class="apidocCodeKeywordSpan">networkStats</span>(iface,cb) | X | X |  | current network stats of given interface&lt;
;br&gt;iface parameter is optional&lt;br&gt;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osInfo" id="apidoc.element.systeminformation.osInfo">
        function <span class="apidocSignatureSpan">systeminformation.</span>osInfo
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function osInfo(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = {

        platform: (_platform == 'Windows_NT' ? 'Windows' : _platform),
        distro: 'unknown',
        release: 'unknown',
        codename: '',
        kernel: os.release(),
        arch: os.arch(),
        hostname: os.hostname(),
        logofile: ''
      };

      if (_linux) {

        exec("cat /etc<span class="apidocCodeCommentSpan">/*-release", function (error, stdout) {
          //if (!error) {
          /**
           * @namespace
           * @property {string}  DISTRIB_ID
           * @property {string}  NAME
           * @property {string}  DISTRIB_RELEASE
           * @property {string}  VERSION_ID
           * @property {string}  DISTRIB_CODENAME
           */
</span>          let release = {};
          let lines = stdout.toString().split('\n');
          lines.forEach(function (line) {
            if (line.indexOf('=') != -1) {
              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();
            }
          });
          result.distro = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/"/g, '');
          result.logofile = getLogoFile(result.distro);
          result.release = (release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/"/g, '');
          result.codename = (release.DISTRIB_CODENAME || '').replace(/"/g, '');
          //}
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_darwin) {
        exec("sw_vers", function (error, stdout) {
          let lines = stdout.toString().split('\n');
          lines.forEach(function (line) {
            if (line.indexOf('ProductName') != -1) {
              result.distro = line.split(':')[1].trim();
              result.logofile = getLogoFile(result.distro);
            }
            if (line.indexOf('ProductVersion') != -1) result.release = line.split(':')[1].trim();
          });
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_windows) {
        result.logofile = getLogoFile();
        result.release = result.kernel;
        exec("wmic os get Caption", function (error, stdout) {
          result.distro = result.codename = stdout.slice(stdout.indexOf('\r\n') + 2).trim();
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.<span class="apidocCodeKeywordSpan">osInfo</span>(cb) | X | X | X | OS information |
| - platform   | X | X | X | 'Linux', 'Darwin', 'Windows' |
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.processLoad" id="apidoc.element.systeminformation.processLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>processLoad
        <span class="apidocSignatureSpan">(proc, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processLoad(proc, callback) {

  // fallback - if only callback is given
  if (util.isFunction(proc) &amp;&amp; !callback) {
    callback = proc;
    proc = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        'proc': proc,
        'pid': -1,
        'cpu': 0,
        'mem': 0
      };

      if (proc) {
        exec("ps aux | grep " + proc + " | grep -v grep", function (error, stdout) {
          if (!error) {
            let data = stdout.replace(/ +/g, " ").split(' ');

            if (data.length &gt; 2) {
              result = {
                'proc': proc,
                'pid': data[1],
                'cpu': parseFloat(data[2].replace(',', '.')),
                'mem': parseFloat(data[3].replace(',', '.'))
              }
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].priority | X | X |  | process priotity |
| - ...[0].mem_vsz | X | X |  | process virtual memory size |
| - ...[0].mem_rss | X | X |  | process mem resident set size |
| - ...[0].nice | X | X |  | process nice value |
| - ...[0].started | X | X |  | process start time |
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.<span class="apidocCodeKeywordSpan">processLoad</span>('apache2',cb) | X | X |  | detailed information about given
 process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.processes" id="apidoc.element.systeminformation.processes">
        function <span class="apidocSignatureSpan">systeminformation.</span>processes
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processes(callback) {

  let parsedhead = [];

  function parseHead(head, rights) {
    let space = (rights &gt; 0);
    let count = 1;
    let from = 0;
    let to = 0;
    let result = [];
    for (let i = 0; i &lt; head.length; i++) {
      if (count &lt;= rights) {
        if (head[i] == ' ' &amp;&amp; !space) {
          to = i - 1;
          result.push({
            from: from,
            to: to + 1,
            cap: head.substring(from, to + 1)
          });
          from = to + 2;
          count++;
        }
        space = head[i] == ' ';
      } else {
        if (head[i] != ' ' &amp;&amp; space) {
          to = i - 1;
          if (from &lt; to) {
            result.push({
              from: from,
              to: to,
              cap: head.substring(from, to)
            });
          }
          from = to + 1;
          count++;
        }
        space = head[i] == ' ';
      }
    }
    to = 1000;
    result.push({
      from: from,
      to: to,
      cap: head.substring(from, to)
    });
    return result;

  }

  function parseLine(line) {
    let pid = parseInt(line.substring(parsedhead[0].from, parsedhead[0].to));
    let pcpu = parseFloat(line.substring(parsedhead[1].from, parsedhead[1].to).replace(/,/g, "."));
    let pmem = parseFloat(line.substring(parsedhead[2].from, parsedhead[2].to).replace(/,/g, "."));
    let priority = parseInt(line.substring(parsedhead[3].from, parsedhead[3].to));
    let vsz = parseInt(line.substring(parsedhead[4].from, parsedhead[4].to));
    let rss = parseInt(line.substring(parsedhead[5].from, parsedhead[5].to));
    let nice = parseInt(line.substring(parsedhead[6].from, parsedhead[6].to));
    let started = line.substring(parsedhead[7].from, parsedhead[7].to).trim();
    let state = line.substring(parsedhead[8].from, parsedhead[8].to).trim();
    state = (state[0] == 'R' ? 'running' : (state[0] == 'S' ? 'sleeping' : (state[0] == 'T' ? 'stopped' : (state[0] == 'W' ? 'paging
' : (state[0] == 'X' ? 'dead' : (state[0] == 'Z' ? 'zombie' : ((state[0] == 'D' || state[0] == 'U') ? 'blocked' : 'unknown')))))));
    let tty = line.substring(parsedhead[9].from, parsedhead[9].to).trim();
    if (tty == '?' || tty == '??') tty = '';
    let user = line.substring(parsedhead[10].from, parsedhead[10].to).trim();
    let command = line.substring(parsedhead[11].from, parsedhead[11].to).trim().replace(/\[/g, "").replace(/]/g, "");

    return ({
      pid: pid,
      pcpu: pcpu,
      pcpuu: 0,
      pcpus: 0,
      pmem: pmem,
      priority: priority,
      mem_vsz: vsz,
      mem_rss: rss,
      nice: nice,
      started: started,
      state: state,
      tty: tty,
      user: user,
      command: command
    })
  }

  function parseProcesses(lines) {
    let result = [];
    if (lines.length &gt; 1) {
      let head = lines[0];
      parsedhead = parseHead(head, 7);
      lines.shift();
      lines.forEach(function (line) {
        if (line.trim() != '') {
          result.push(parseLine(line));
        }
      });
    }
    return result;
  }

  function parseProcStat(line) {
    let parts = line.replace(/ +/g, " ").split(' ');
    let user = (parts.length &gt;= 2 ? parseInt(parts[1]) : 0);
    let nice = (parts.length &gt;= 3 ? parseInt(parts[2]) : 0);
    let system = (parts.length &gt;= 4 ? parseInt(parts[3]) : 0);
    let idle = (parts.length &gt;= 5 ? parseInt(parts[4]) : 0);
    let iowait = (parts.length &gt;= 6 ? parseInt(parts[5]) : 0);
    let irq = (parts.length &gt;= 7 ? parseInt(parts[6]) : 0);
    let softirq = (parts.length &gt;= 8 ? parseInt(parts[7]) : 0);
    let steal = (parts.length &gt;= 9 ? parseInt(parts[8]) : 0);
    let guest = (parts.length &gt;= 10 ? parseInt(parts[9]) : 0);
    let guest_nice = (parts.length &gt;= 11 ? parseInt(parts[10]) : 0);
    return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
  }

  function parseProcPidStat(line, all) {
    let statparts = line.replace(/ +/g, " ").split(')');
    if (statparts.length &gt;= 2) {
      let parts = statparts[1].split(' ');
      if (parts.length &gt;= 16) {
        let pid = parseInt(statparts[0].split(' ')[0]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.services('mysql, apache2', cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">processes</span>(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
| - blocked | X | X |  | # of all processes blocked |
| - sleeping | X | X |  | # of all processes sleeping |
| - list[] | X | X |  | list of all processes incl. details |
| - ...[0].pid | X | X |  | process PID |
| - ...[0].pcpu | X | X |  | process % CPU usage |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.services" id="apidoc.element.systeminformation.services">
        function <span class="apidocSignatureSpan">systeminformation.</span>services
        <span class="apidocSignatureSpan">(srv, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function services(srv, callback) {

  // fallback - if only callback is given
  if (util.isFunction(srv) &amp;&amp; !callback) {
    callback = srv;
    srv = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      srv = srv.trim().replace(/,+/g, " ").replace(/  +/g, " ").replace(/ +/g, "|");
      let srvs = srv.split('|');
      let comm = (_darwin) ? "ps -caxm -o pcpu,pmem,comm" : "ps axo pcpu,pmem,comm";
      let data = [];
      if (srv != '' &amp;&amp; srvs.length &gt; 0) {
        exec(comm + " | grep -v grep | egrep '" + srv + "'", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/ +/g, " ").replace(/,+/g, ".").split('\n');
            srvs.forEach(function (srv) {
              let ps = lines.filter(function (e) {
                return e.indexOf(srv) != -1
              });
              data.push({
                'name': srv,
                'running': ps.length &gt; 0,
                'pcpu': parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(' ')[0]);
                }, 0)).toFixed(2)),
                'pmem': parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(' ')[1]);
                }, 0)).toFixed(2))
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          } else {
            srvs.forEach(function (srv) {
              data.push({
                'name': srv,
                'running': false,
                'pcpu': 0,
                'pmem': 0
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          }
        });
      } else {
        if (callback) { callback(data) }
        resolve(data);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.<span class="apidocCodeKeywordSpan">services</span>('mysql, apache2', cb) | X | X |  | pass comma separated string
 of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.shell" id="apidoc.element.systeminformation.shell">
        function <span class="apidocSignatureSpan">systeminformation.</span>shell
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shell(callback) {
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = '';
      exec("echo $SHELL", function (error, stdout) {
        if (!error) {
          result = stdout.toString().split('\n')[0];
        }
        if (callback) {
          callback(result)
        }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. 'apple', 'debian', 'fedora', ... |
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.<span class="apidocCodeKeywordSpan">shell</span>(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.system" id="apidoc.element.systeminformation.system">
        function <span class="apidocSignatureSpan">systeminformation.</span>system
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">system = function (callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {

      let result = {
        manufacturer: '',
        model: 'Computer',
        version: '',
        serial: '-',
        uuid: '-'
      };

      if (_linux) {
        exec("dmidecode -t system", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              if (line.indexOf(':') != -1) {
                if (line.toLowerCase().indexOf('manufacturer') != -1) result.manufacturer = result.manufacturer || line.split(':')[
1].trim();
                if (line.toLowerCase().indexOf('product name') != -1) result.model = line.split(':')[1].trim();
                if (line.toLowerCase().indexOf('version') != -1) result.version = result.version || line.split(':')[1].trim();
                if (line.toLowerCase().indexOf('serial number') != -1) result.serial = line.split(':')[1].trim();
                if (line.toLowerCase().indexOf('uuid') != -1) result.uuid = line.split(':')[1].trim();
              }
            });
            if (result.serial.toLowerCase().indexOf('o.e.m.') != -1) result.serial = '-';
            if (result.manufacturer.toLowerCase().indexOf('o.e.m.') != -1) result.manufacturer = '';
            if (result.model.toLowerCase().indexOf('o.e.m.') != -1) result.model = 'Computer';
            if (result.version.toLowerCase().indexOf('o.e.m.') != -1) result.version = '-';

            if (result.manufacturer == '' &amp;&amp; result.model == 'Computer' &amp;&amp; result.version == '-') {
              // Check Raspberry Pi
              exec("grep Hardware /proc/cpuinfo; grep Serial /proc/cpuinfo; grep Revision /proc/cpuinfo", function (error, stdout
) {
                if (!error) {
                  let lines = stdout.toString().split('\n');
                  lines.forEach(function (line) {
                    if (line.indexOf(':') != -1) {
                      if (line.toLowerCase().indexOf('hardware') != -1) result.model = line.split(':')[1].trim();
                      if (line.toLowerCase().indexOf('revision') != -1) result.version = line.split(':')[1].trim();
                      if (line.toLowerCase().indexOf('serial') != -1) result.serial = line.split(':')[1].trim();
                    }
                  });
                  if (result.model == 'BCM2709') {
                    result.manufacturer = 'Raspberry Pi Foundation';
                    result.model = result.model + ' - Pi 2 Model B';
                    if (['a01041', 'a21041'].indexOf(result.version) &gt;= 0) {
                      result.version = result.version + ' - Rev. 1.1'
                    }
                  }
                  if (result.model == 'BCM2708') {
                    result.manufacturer = 'Raspberry Pi Foundation';
                    if (['0002', '0003'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model B';
                      result.version = result.version + ' - Rev 1.0';
                    }
                    if (['0007', '0008', '0009'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model A';
                      result.version = result.version + ' - Rev 2.0';
                    }
                    if (['0004', '0005', '0006', '000d', '000e', '000f'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model B';
                      result.version = result.version + ' - Rev 2.0';
                    }
                    if (['0012'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model A+';
                      result.version = result.version + ' - Rev 1.0';
                    }
                    if (['0010'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model B+';
                      result.version = result.version + ' - Rev 1.0';
                    }
                    if (['0013'].indexOf(result.ver ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.time() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.<span class="apidocCodeKeywordSpan">system</span>(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.osInfo(cb) | X | X | X | OS information |
| - platform   | X | X | X | 'Linux', 'Darwin', 'Windows' |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.time" id="apidoc.element.systeminformation.time">
        function <span class="apidocSignatureSpan">systeminformation.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time() {
  return {
    current: Date.now(),
    uptime: os.uptime()
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.<span class="apidocCodeKeywordSpan">time</span>() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.users" id="apidoc.element.systeminformation.users">
        function <span class="apidocSignatureSpan">systeminformation.</span>users
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function users(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];

      // linux
      if (_linux) {
        exec("who --ips; echo '---'; w | tail -n +2", function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split('\n');
            result = parseUsers1(lines);
            if (result.length == 0) {
              exec("who; echo '---'; w | tail -n +2", function (error, stdout) {
                if (!error) {
                  // lines / split
                  lines = stdout.toString().split('\n');
                  result = parseUsers1(lines);
                  if (callback) { callback(result) }
                  resolve(result);
                } else {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
            } else {
              if (callback) { callback(result) }
              resolve(result);
            }
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

      if (_darwin) {
        exec("who; echo '---'; w -ih", function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split('\n');
            result = parseUsers2(lines);

            if (callback) { callback(result) }
            resolve(result);
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.processLoad('apache2',cb) | X | X |  | detailed information about given process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">users</span>(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.version" id="apidoc.element.systeminformation.version">
        function <span class="apidocSignatureSpan">systeminformation.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function version() {
  return lib_version;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
11. Docker
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.<span class="apidocCodeKeywordSpan">version</span>() | X | X | X | library version (no callback/promise) |
| si.time() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.versions" id="apidoc.element.systeminformation.versions">
        function <span class="apidocSignatureSpan">systeminformation.</span>versions
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function versions(callback) {
  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = {
        kernel: os.release(),
        node: process.versions.node,
        v8: process.versions.v8,
        npm: '',
        pm2: '',
        openssl: process.versions.openssl
      };
      let lines = [];
      exec("npm -v", function (error, stdout) {
        if (!error) {
          result.npm = stdout.toString().split('\n')[0];
        }
        exec("pm2 -v", function (error, stdout) {
          if (!error) {
            lines = stdout.toString().split('\n');
            if (lines.length &gt;= 2) {
              result.pm2 = lines[lines.length - 2];
            }
          }
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. 'apple', 'debian', 'fedora', ... |
| si.<span class="apidocCodeKeywordSpan">versions</span>(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.battery" id="apidoc.module.systeminformation.battery">module systeminformation.battery</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.battery.battery" id="apidoc.element.systeminformation.battery.battery">
        function <span class="apidocSignatureSpan">systeminformation.</span>battery
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">battery = function (callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        hasbattery: false,
        cyclecount: 0,
        ischarging: false,
        maxcapacity: 0,
        currentcapacity: 0,
        percent: 0
      };

      if (_linux) {
        let battery_path = '';
        if (fs.existsSync('/sys/class/power_supply/BAT1/status')) {
          battery_path = '/sys/class/power_supply/BAT1/'
        } else if (fs.existsSync('/sys/class/power_supply/BAT0/status')) {
          battery_path = '/sys/class/power_supply/BAT0/'
        }
        if (battery_path) {
          exec("cat " + battery_path + "status", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              if (lines.length &gt; 0 &amp;&amp; lines[0]) result.ischarging = (lines[0].trim().toLowerCase() == 'charging')
            }
            exec("cat " + battery_path + "cyclec_ount", function (error, stdout) {
              if (!error) {
                let lines = stdout.toString().split('\n');
                if (lines.length &gt; 0 &amp;&amp; lines[0]) result.cyclecount = parseFloat(lines[0].trim());
              }
              exec("cat " + battery_path + "charge_full", function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split('\n');
                  if (lines.length &gt; 0 &amp;&amp; lines[0]) result.maxcapacity = parseFloat(lines[0].trim());
                }
                exec("cat " + battery_path + "charge_now", function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split('\n');
                    if (lines.length &gt; 0 &amp;&amp; lines[0]) result.currentcapacity = parseFloat(lines[0].trim());
                  }
                  if (result.maxcapacity &amp;&amp; result.currentcapacity) {
                    result.hasbattery = true;
                    result.percent = 100.0 * result.currentcapacity / result.maxcapacity;
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                })
              })
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      }
      if (_darwin) {
        exec("ioreg -n AppleSmartBattery -r | grep '\"CycleCount\"';ioreg -n AppleSmartBattery -r | grep '\"IsCharging\"';ioreg -
n AppleSmartBattery -r | grep '\"MaxCapacity\"';ioreg -n AppleSmartBattery -r | grep '\"CurrentCapacity\"'", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").split('\n');
            lines.forEach(function (line) {
              if (line.indexOf('=') != -1) {
                if (line.toLowerCase().indexOf('cyclecount') != -1) result.cyclecount = parseFloat(line.split('=')[1].trim());
                if (line.toLowerCase().indexOf('ischarging') != -1) result.ischarging = (line.split('=')[1].trim().toLowerCase() == '
yes');
                if (line.toLowerCase().indexOf('maxcapacity') != -1) result.maxcapacity = parseFloat(line.split('=')[1].trim());
                if (line.toLowerCase().indexOf('currentcapacity') != -1) result.currentcapacity = parseFloat(line.split('=')[1].
trim());
              }
            });
          }
          if (result.maxcapacity &amp;&amp; result.currentcapacity) {
            result.hasbattery = true;
            result.percent = 100.0 * result.currentcapacity / result.maxcapacity;
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - used | X | X | X | used (incl. buffers/cache) |
| - active | X | X | X | used actively (excl. buffers/cache)  |
| - buffcache | X | X |  | used by buffers+cache |
| - available | X | X | X | potentially available (total - active) |
| - swaptotal | X | X |  |  |
| - swapused | X | X |  |  |
| - swapfree | X | X |  |  |
| si.<span class="apidocCodeKeywordSpan">battery</span>(cb) | X | X |  | battery information |
| - hasbattery | X | X |  | indicates presence of battery |
| - ischarging | X | X |  | indicates if battery is charging |
| - maxcapacity | X | X |  | max capacity of battery |
| - currentcapacity | X | X |  | current capacity of battery |
| - percent | X | X |  | charging level in percent |
| si.graphics(cb) | X | X |  | arrays of graphics controllers and displays |
| - controllers[0].model | X | X |  | graphics controller model |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.blockDevices" id="apidoc.module.systeminformation.blockDevices">module systeminformation.blockDevices</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.blockDevices.blockDevices" id="apidoc.element.systeminformation.blockDevices.blockDevices">
        function <span class="apidocSignatureSpan">systeminformation.</span>blockDevices
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function blockDevices(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_linux) {
        // see https://wiki.ubuntuusers.de/lsblk/
        // exec("lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-
IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME", function (error, stdout) {
        exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER", function (error, stdout
) {
          let data = [];
          if (!error) {
            let lines = blkStdoutToObject(stdout).split('\n');
            data = parseBlk(lines);
            if (callback) {
              callback(data)
            }
            resolve(data);
          } else {
            exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER", function (error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split('\n');
                data = parseBlk(lines);
              }
              if (callback) {
                callback(data)
              }
              resolve(data);
            });
          }
        });
      }
      if (_darwin) {
        exec("diskutil info -all", function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split('\n');
            // parse lines into temp array of devices
            data = parseDevices(lines);
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec('wmic logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber
 /format:csv', function (error, stdout) {
          if (!error) {
            let lines = stdout.split('\r\n').filter(line =&gt; line.trim() != '').filter((line, idx) =&gt; idx &gt; 0);
            lines.forEach(function (line) {
              if (line != '') {
                line = line.replace('\r', '').split(',');
                data.push({
                  name: line[7],
                  identifier: line[1],
                  type: 'disk',
                  fstype: line[5].toLowerCase(),
                  mount: line[1],
                  size: line[8],
                  physical: line[4] == '5' ? 'CD/DVD' : 'HDD',
                  uuid: line[10],
                  label: line[9],
                  model: '',
                  serial: line[10],
                  removable: line[4] == '2',
                  protocol: ''
                });
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.fsSize(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.<span class="apidocCodeKeywordSpan">blockDevices</span>(cb) | X | X | X | returns array of disks, partitions,&lt;br&gt;
raids and roms |
| - [0].name | X | X | X | name |
| - [0].type | X | X | X | type |
| - [0].fstype | X | X | X | file system type (e.g. ext4) |
| - [0].mount | X | X | X | mount point |
| - [0].size | X | X | X | size in bytes |
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.cpu" id="apidoc.module.systeminformation.cpu">module systeminformation.cpu</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.cpu.cpu" id="apidoc.element.systeminformation.cpu.cpu">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpu
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpu(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      getCpu().then(result =&gt; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

All functions (except `version` and `time`) are implemented as asynchronous functions. Here a small example how to use them:

```
var si = require('systeminformation');

// callback style
si.<span class="apidocCodeKeywordSpan">cpu</span>(function(data) {
	console.log('CPU-Information:');
	console.log(data);
})

// promises style - new in version 3
si.cpu()
	.then(data =&gt; console.log(data))
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.cpuCache" id="apidoc.module.systeminformation.cpuCache">module systeminformation.cpuCache</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.cpuCache.cpuCache" id="apidoc.element.systeminformation.cpuCache.cpuCache">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuCache
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCache(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {};
      if (_linux) {
        exec("lscpu", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              let parts = line.split(':');
              if (parts[0].toUpperCase().indexOf('L1D CACHE') != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf('L1I CACHE') != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf('L2 CACHE') != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf('L3 CACHE') != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              let parts = line.split(':');
              if (parts[0].toLowerCase().indexOf('hw.l1icachesize') != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf('hw.l1dcachesize') != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf('hw.l2cachesize') != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf('hw.l3cachesize') != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf('K') != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.<span class="apidocCodeKeywordSpan">cpuCache</span>(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.cpuCurrentspeed" id="apidoc.module.systeminformation.cpuCurrentspeed">module systeminformation.cpuCurrentspeed</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.cpuCurrentspeed.cpuCurrentspeed" id="apidoc.element.systeminformation.cpuCurrentspeed.cpuCurrentspeed">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuCurrentspeed
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCurrentspeed(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = getCpuCurrentSpeedSync();
      if (result == 0 &amp;&amp; _cpu_speed != '0.00') result = parseFloat(_cpu_speed);

      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.<span class="apidocCodeKeywordSpan">cpuCurrentspeed</span>(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.cpuTemperature(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.cpuFlags" id="apidoc.module.systeminformation.cpuFlags">module systeminformation.cpuFlags</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.cpuFlags.cpuFlags" id="apidoc.element.systeminformation.cpuFlags.cpuFlags">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuFlags
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuFlags(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = '';
      if (_linux) {
        exec("lscpu", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              if (line.split(':')[0].toUpperCase().indexOf('FLAGS') != -1) {
                result = line.split(':')[1].trim().toLowerCase();
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec("sysctl machdep.cpu.features", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            if (lines.length &gt; 0 &amp;&amp; lines[0].indexOf('machdep.cpu.features:') != -1) {
              result = lines[0].split(':')[1].trim().toLowerCase();
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.<span class="apidocCodeKeywordSpan">cpuFlags</span>(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.cpuTemperature" id="apidoc.module.systeminformation.cpuTemperature">module systeminformation.cpuTemperature</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.cpuTemperature.cpuTemperature" id="apidoc.element.systeminformation.cpuTemperature.cpuTemperature">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuTemperature
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuTemperature(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      let result = {
        main: -1.0,
        cores: [],
        max: -1.0
      };
      if (_linux) {
        exec("sensors", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              let regex = /\+([^]*)/g;
              let temps = line.match(regex);
              if (line.split(':')[0].toUpperCase().indexOf('PHYSICAL') != -1) {
                result.main = parseFloat(temps);
              }
              if (line.split(':')[0].toUpperCase().indexOf('CORE ') != -1) {
                result.cores.push(parseFloat(temps));
              }
            });
            if (result.cores.length &gt; 0) {
              let maxtmp = Math.max.apply(Math, result.cores);
              result.max = (maxtmp &gt; result.main) ? maxtmp : result.main;
            }
            if (callback) { callback(result) }
            resolve(result);
          } else {
            fs.stat('/sys/class/thermal/thermal_zone0/temp', function(err, stat) {
              if(err == null) {
                exec("cat /sys/class/thermal/thermal_zone0/temp", function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split('\n');
                    if (lines.length &gt; 0) {
                      result.main = parseFloat(lines[0]) / 1000.0;
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              } else {
                exec("/opt/vc/bin/vcgencmd measure_temp", function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split('\n');
                    if (lines.length &gt; 0 &amp;&amp; lines[0].indexOf('=')) {
                      result.main = parseFloat(lines[0].split("=")[1]);
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              }
            });

          }
        });
      }
      if (_darwin) {
        let smc = require('../build/Release/smc');

        let cores = ['TC0P', 'TC1C', 'TC2C', 'TC3C', 'TC4C', 'TC5C', 'TC6C', 'TC7C', 'TC8C'];
        let sum = 0;
        let id = 0;
        cores.forEach(function(key) {
          let value = smc.get(key);
          if (id == 0) {
            if (value &gt; 0) {
              result.main = value;
              result.max = value;
            }
            id = 1;
          } else {
            if (value &gt; 0) {
              result.cores.push(value);
              sum = sum + value;
              if (value &gt; result.max) result.max = value;
            }
          }
        });
        if (result.cores.length) {
          result.main = sum / result.cores.length;
        }

        if (callback) { callback(result) }
        resolve(result);
      }
      if (_windows) {
        exec("wmic /namespace:\\\\root\\wmi PATH MSAcpi_ThermalZoneTemperature get CriticalTripPoint,CurrentTemperature /value",
function (error, stdout) {
          if (!error) {
            let sum = 0;
            let lines = stdout.trim().split(/\s\s+/);
            lines.forEach(function (line) {
              if (line.match('CriticalTripPoint') &amp;&amp; !result.max)
                result.max = (parseInt(line.split('CriticalTripPoint=')[1]) - 2732) / 10;
              else if (line.match('CurrentTemperature')) {
                let value = (parseInt(line.split('CurrentTemperature=')[1]) - 2732) / 10;
                sum = sum + value;
                result.cores.push(value);
              }
            });
            if (result.cores.length) {
              result.main = sum / result.cores.length;
            }
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.<span class="apidocCodeKeywordSpan">cpuTemperature</span>(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
| si.mem(cb) | X | X | X | Memory information|
| - total | X | X | X | total memory |
| - free | X | X | X | not used |
| - used | X | X | X | used (incl. buffers/cache) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.currentLoad" id="apidoc.module.systeminformation.currentLoad">module systeminformation.currentLoad</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.currentLoad.currentLoad" id="apidoc.element.systeminformation.currentLoad.currentLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>currentLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function currentLoad(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      getLoad().then(result =&gt; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkConnections(cb) | X | X |  | current network network connections&lt;br&gt;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.<span class="apidocCodeKeywordSpan">currentLoad</span>(cb) | X | X |  | CPU-Load |
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.disksIO" id="apidoc.module.systeminformation.disksIO">module systeminformation.disksIO</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.disksIO.disksIO" id="apidoc.element.systeminformation.disksIO.disksIO">
        function <span class="apidocSignatureSpan">systeminformation.</span>disksIO
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disksIO(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: -1,
        wIO_sec: -1,
        tIO_sec: -1,
        ms: 0
      };
      let rIO = 0;
      let wIO = 0;

      if ((_disk_io &amp;&amp; !_disk_io.ms) || (_disk_io &amp;&amp; _disk_io.ms &amp;&amp; Date.now() - _disk_io.ms &gt;= 500)) {
        if (_linux) {
          // prints Block layer statistics for all mounted volumes
          // var cmd = "for mount in `lsblk | grep / | sed -r 's/ //' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed
 -r 's/ +/;/g' | sed -r 's/^;//'; done";
          // var cmd = "for mount in `lsblk | grep / | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /
sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done";
          let cmd = "for mount in `lsblk | grep ' disk ' | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do
cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done";

          exec(cmd, function (error, stdout) {
            if (!error) {
              let lines = stdout.split('\n');
              lines.forEach(function (line) {
                // ignore empty lines
                if (!line) return;

                // sum r/wIO of all disks to compute all disks IO
                let stats = line.split(';');
                rIO += parseInt(stats[0]);
                wIO += parseInt(stats[4]);
              });
              result = calcDiskIO(rIO, wIO);

              if (callback) {
                callback(result)
              }
              resolve(result);
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          });
        }
        if (_darwin) {
          exec("ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics
' | tr -cd '01234567890,\n' | awk -F',' '{print $1, $11}'", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              lines.forEach(function (line) {
                line = line.trim();
                if (line != '') {
                  line = line.split(' ');

                  rIO += parseInt(line[1]);
                  wIO += parseInt(line[0]);
                }
              });
              result = calcDiskIO(rIO, wIO);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.rIO = _disk_io.rIO;
        result.wIO = _disk_io.wIO;
        result.tIO = _disk_io.rIO + _disk_io.wIO;
        result.ms = _disk_io.last_ms;
        result.rIO_sec = _disk_io.rIO_sec;
        result.wIO_sec = _disk_io.wIO_sec;
        result.tIO_sec = _disk_io.tIO_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">disksIO</span>(cb) | X | X |  | current transfer stats |
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.docker" id="apidoc.module.systeminformation.docker">module systeminformation.docker</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerAll" id="apidoc.element.systeminformation.docker.dockerAll">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerAll
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerAll(callback) {
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      dockerContainers(true).then(result =&gt; {
        if (result &amp;&amp; Object.prototype.toString.call(result) === '[object Array]' &amp;&amp; result.length &gt; 0) {
          let l = result.length;
          result.forEach(function (element) {
            dockerContainerStats(element.id).then(res =&gt; {
              // include stats in array
              element.mem_usage = res.mem_usage;
              element.mem_limit = res.mem_limit;
              element.mem_percent = res.mem_percent;
              element.cpu_percent = res.cpu_percent;
              element.pids = res.pids;
              element.netIO = res.netIO;
              element.blockIO = res.blockIO;
              element.cpu_stats = res.cpu_stats;
              element.precpu_stats = res.precpu_stats;
              element.memory_stats = res.memory_stats;
              element.networks = res.networks;

              dockerContainerProcesses(element.id).then(processes =&gt; {
                element.processes = processes;

                l -= 1;
                if (l == 0) {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
              // all done??
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].stat | X | X |  | process state |
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.<span class="apidocCodeKeywordSpan">dockerAll</span>(cb) | X | X |  | list of all containers including their stats&lt;br&amp;#
x3e;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerContainerProcesses" id="apidoc.element.systeminformation.docker.dockerContainerProcesses">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerProcesses
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerProcesses(containerID, callback) {
  containerID = containerID || '';
  let result = [];
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getProcesses(containerID, data =&gt; {
<span class="apidocCodeCommentSpan">          /**
           * @namespace
           * @property {Array}  Titles
           * @property {Array}  Processes
           **/
</span>           try {
            if (data &amp;&amp; data.Titles &amp;&amp; data.Processes) {
              let titles = data.Titles.map(function(value) {
                return value.toUpperCase();
              });
              let pos_pid = titles.indexOf('PID');
              let pos_ppid = titles.indexOf('PPID');
              let pos_pgid = titles.indexOf('PGID');
              let pos_vsz = titles.indexOf('VSZ');
              let pos_time = titles.indexOf('TIME');
              let pos_elapsed = titles.indexOf('ELAPSED');
              let pos_ni = titles.indexOf('NI');
              let pos_ruser = titles.indexOf('RUSER');
              let pos_user = titles.indexOf('USER');
              let pos_rgroup = titles.indexOf('RGROUP');
              let pos_group = titles.indexOf('GROUP');
              let pos_stat = titles.indexOf('STAT');
              let pos_rss = titles.indexOf('RSS');
              let pos_command = titles.indexOf('COMMAND');

              data.Processes.forEach(process =&gt; {
                result.push({
                  pid_host: (pos_pid &gt;= 0 ? process[pos_pid] : ''),
                  ppid: (pos_ppid &gt;= 0 ? process[pos_ppid] : ''),
                  pgid: (pos_pgid &gt;= 0 ? process[pos_pgid] : ''),
                  user: (pos_user &gt;= 0 ? process[pos_user] : ''),
                  ruser: (pos_ruser &gt;= 0 ? process[pos_ruser] : ''),
                  group: (pos_group &gt;= 0 ? process[pos_group] : ''),
                  rgroup: (pos_rgroup &gt;= 0 ? process[pos_rgroup] : ''),
                  stat: (pos_stat &gt;= 0 ? process[pos_stat] : ''),
                  time: (pos_time &gt;= 0 ? process[pos_time] : ''),
                  elapsed: (pos_elapsed &gt;= 0 ? process[pos_elapsed] : ''),
                  nice: (pos_ni &gt;= 0 ? process[pos_ni] : ''),
                  rss: (pos_rss &gt;= 0 ? process[pos_rss] : ''),
                  vsz: (pos_vsz &gt;= 0 ? process[pos_vsz] : ''),
                  command: (pos_command &gt;= 0 ? process[pos_command] : '')
                })
              })
            }
          } catch (err) {
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - netIO.wx | X | X |  | sent bytes via network |
| - blockIO.r | X | X |  | bytes read from BlockIO |
| - blockIO.w | X | X |  | bytes written to BlockIO |
| - cpu_stats | X | X |  | detailed cpu stats |
| - percpu_stats | X | X |  | detailed per cpu stats |
| - memory_stats | X | X |  | detailed memory stats |
| - networks | X | X |  | detailed network stats per interface |
| si.<span class="apidocCodeKeywordSpan">dockerContainerProcesses</span>(id, cb) | X | X |  | array of processes inside a container
 |
| - [0].pid_host | X | X |  | process ID (host) |
| - [0].ppid | X | X |  | parent process ID |
| - [0].pgid | X | X |  | process group ID |
| - [0].user | X | X |  | effective user name |
| - [0].ruser | X | X |  | real user name |
| - [0].group | X | X |  | effective group name |
| - [0].rgroup | X | X |  | real group name |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerContainerStats" id="apidoc.element.systeminformation.docker.dockerContainerStats">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerStats
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerStats(containerID, callback) {
  containerID = containerID || '';
  let result = {
    id: containerID,
    mem_usage: 0,
    mem_limit: 0,
    mem_percent: 0,
    cpu_percent: 0,
    pids: 0,
    netIO: {
      rx: 0,
      wx: 0
    },
    blockIO: {
      r: 0,
      w: 0
    }
  };
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getStats(containerID, data =&gt; {
          // let cmd = "curl --unix-socket /var/run/docker.sock http:/containers/" + containerID + "/stats?stream=0";
          // exec(cmd, function (error, stdout) {
          //   if (!error) {
          //     let jsonString = stdout.toString();
          try {
//              let stats = JSON.parse(jsonString);
            let stats = data;
<span class="apidocCodeCommentSpan">            /**
             * @namespace
             * @property {Object}  memory_stats
             * @property {number}  memory_stats.usage
             * @property {number}  memory_stats.limit
             * @property {Object}  cpu_stats
             * @property {Object}  pids_stats
             * @property {number}  pids_stats.current
             * @property {Object}  networks
             * @property {Object}  blkio_stats
             */
</span>
            if (!stats.message) {
              result.mem_usage = (stats.memory_stats &amp;&amp; stats.memory_stats.usage ? stats.memory_stats.usage : 0);
              result.mem_limit = (stats.memory_stats &amp;&amp; stats.memory_stats.limit ? stats.memory_stats.limit : 0);
              result.mem_percent = (stats.memory_stats &amp;&amp; stats.memory_stats.usage &amp;&amp; stats.memory_stats.limit ? stats.memory_stats
.usage / stats.memory_stats.limit * 100.0 : 0);
              result.cpu_percent = (stats.cpu_stats ? docker_calcCPUPercent(stats.cpu_stats, containerID) : 0);
              result.pids = (stats.pids_stats &amp;&amp; stats.pids_stats.current ? stats.pids_stats.current : 0);
              if (stats.networks) result.netIO = docker_calcNetworkIO(stats.networks);
              if (stats.blkio_stats) result.blockIO = docker_calcBlockIO(stats.blkio_stats);
              result.cpu_stats = (stats.cpu_stats ? stats.cpu_stats : {});
              result.precpu_stats = (stats.precpu_stats ? stats.precpu_stats : {});
              result.memory_stats = (stats.memory_stats ? stats.memory_stats : {});
              result.networks = (stats.networks ? stats.networks : {});
            }
          } catch (err) {
          }
          // }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
| - [0].ports | X | X |  | array of ports |
| - [0].mounts | X | X |  | array of mounts |
| si.<span class="apidocCodeKeywordSpan">dockerContainerStats</span>(id, cb) | X | X |  | statistics for a specific container |
| - id | X | X |  | Container ID |
| - mem_usage | X | X |  | memory usage in bytes |
| - mem_limit | X | X |  | memory limit (max mem) in bytes |
| - mem_percent | X | X |  | memory usage in percent |
| - cpu_percent | X | X |  | cpu usage in percent |
| - pids | X | X |  | number of processes |
| - netIO.rx | X | X |  | received bytes via network |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerContainers" id="apidoc.element.systeminformation.docker.dockerContainers">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainers
        <span class="apidocSignatureSpan">(all, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainers(all, callback) {

  function inContainers(containers, id) {
    let filtered = containers.filter(obj =&gt; {
<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {string}  Id
       */
</span>      return (obj.Id &amp;&amp; (obj.Id == id))
    });
    return (filtered.length &gt; 0);
  }

  // fallback - if only callback is given
  if (util.isFunction(all) &amp;&amp; !callback) {
    callback = all;
    all = false;
  }

  all = all || false;
  let result = [];
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      if (!_docker_socket) {
        _docker_socket = new DockerSocket();
      }

      _docker_socket.listContainers(all, data =&gt; {
        let docker_containers = {};
        // let cmd = "curl --unix-socket /var/run/docker.sock http:/containers/json" + (all ? "?all=1" : "");
        // exec(cmd, function (error, stdout) {
        //   if (!error) {
        try {
          //       let jsonString = stdout.toString();
          //       let docker_containers = JSON.parse(jsonString);
          docker_containers = data;
          if (docker_containers &amp;&amp; Object.prototype.toString.call(docker_containers) === '[object Array]' &amp;&amp; docker_containers.length
 &gt; 0) {
            docker_containers.forEach(function (element) {
              /**
               * @namespace
               * @property {string}  Id
               * @property {string}  Name
               * @property {string}  Image
               * @property {string}  ImageID
               * @property {string}  Command
               * @property {number}  Created
               * @property {string}  State
               * @property {Array}  Names
               * @property {Array}  Ports
               * @property {Array}  Mounts
               */

              if (element.Names &amp;&amp; Object.prototype.toString.call(element.Names) === '[object Array]' &amp;&amp; element.Names.length &gt;
0) {
                element.Name = element.Names[0].replace(/^\/|\/$/g, '');
              }
              result.push({
                id: element.Id,
                name: element.Name,
                image: element.Image,
                imageID: element.ImageID,
                command: element.Command,
                created: element.Created,
                state: element.State,
                ports: element.Ports,
                mounts: element.Mounts,
                // hostconfig: element.HostConfig,
                // network: element.NetworkSettings
              })
            });
          }
        } catch (err) {
        }
        // }

        // GC in _docker_container_stats
        for (let key in _docker_container_stats) {
          if (_docker_container_stats.hasOwnProperty(key)) {
            if (!inContainers(docker_containers, key)) delete _docker_container_stats[key];
          }
        }
        if (callback) { callback(result) }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&lt;br&gt;host parameter is optional (default
 8.8.8.8)|
| si.<span class="apidocCodeKeywordSpan">dockerContainers</span>(all, cb) | X | X |  | returns array of active/all docker containers
 |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.dockerAll" id="apidoc.module.systeminformation.dockerAll">module systeminformation.dockerAll</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.dockerAll.dockerAll" id="apidoc.element.systeminformation.dockerAll.dockerAll">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerAll
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerAll(callback) {
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      dockerContainers(true).then(result =&gt; {
        if (result &amp;&amp; Object.prototype.toString.call(result) === '[object Array]' &amp;&amp; result.length &gt; 0) {
          let l = result.length;
          result.forEach(function (element) {
            dockerContainerStats(element.id).then(res =&gt; {
              // include stats in array
              element.mem_usage = res.mem_usage;
              element.mem_limit = res.mem_limit;
              element.mem_percent = res.mem_percent;
              element.cpu_percent = res.cpu_percent;
              element.pids = res.pids;
              element.netIO = res.netIO;
              element.blockIO = res.blockIO;
              element.cpu_stats = res.cpu_stats;
              element.precpu_stats = res.precpu_stats;
              element.memory_stats = res.memory_stats;
              element.networks = res.networks;

              dockerContainerProcesses(element.id).then(processes =&gt; {
                element.processes = processes;

                l -= 1;
                if (l == 0) {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
              // all done??
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].stat | X | X |  | process state |
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.<span class="apidocCodeKeywordSpan">dockerAll</span>(cb) | X | X |  | list of all containers including their stats&lt;br&amp;#
x3e;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.dockerContainerProcesses" id="apidoc.module.systeminformation.dockerContainerProcesses">module systeminformation.dockerContainerProcesses</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainerProcesses.dockerContainerProcesses" id="apidoc.element.systeminformation.dockerContainerProcesses.dockerContainerProcesses">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerProcesses
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerProcesses(containerID, callback) {
  containerID = containerID || '';
  let result = [];
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getProcesses(containerID, data =&gt; {
<span class="apidocCodeCommentSpan">          /**
           * @namespace
           * @property {Array}  Titles
           * @property {Array}  Processes
           **/
</span>           try {
            if (data &amp;&amp; data.Titles &amp;&amp; data.Processes) {
              let titles = data.Titles.map(function(value) {
                return value.toUpperCase();
              });
              let pos_pid = titles.indexOf('PID');
              let pos_ppid = titles.indexOf('PPID');
              let pos_pgid = titles.indexOf('PGID');
              let pos_vsz = titles.indexOf('VSZ');
              let pos_time = titles.indexOf('TIME');
              let pos_elapsed = titles.indexOf('ELAPSED');
              let pos_ni = titles.indexOf('NI');
              let pos_ruser = titles.indexOf('RUSER');
              let pos_user = titles.indexOf('USER');
              let pos_rgroup = titles.indexOf('RGROUP');
              let pos_group = titles.indexOf('GROUP');
              let pos_stat = titles.indexOf('STAT');
              let pos_rss = titles.indexOf('RSS');
              let pos_command = titles.indexOf('COMMAND');

              data.Processes.forEach(process =&gt; {
                result.push({
                  pid_host: (pos_pid &gt;= 0 ? process[pos_pid] : ''),
                  ppid: (pos_ppid &gt;= 0 ? process[pos_ppid] : ''),
                  pgid: (pos_pgid &gt;= 0 ? process[pos_pgid] : ''),
                  user: (pos_user &gt;= 0 ? process[pos_user] : ''),
                  ruser: (pos_ruser &gt;= 0 ? process[pos_ruser] : ''),
                  group: (pos_group &gt;= 0 ? process[pos_group] : ''),
                  rgroup: (pos_rgroup &gt;= 0 ? process[pos_rgroup] : ''),
                  stat: (pos_stat &gt;= 0 ? process[pos_stat] : ''),
                  time: (pos_time &gt;= 0 ? process[pos_time] : ''),
                  elapsed: (pos_elapsed &gt;= 0 ? process[pos_elapsed] : ''),
                  nice: (pos_ni &gt;= 0 ? process[pos_ni] : ''),
                  rss: (pos_rss &gt;= 0 ? process[pos_rss] : ''),
                  vsz: (pos_vsz &gt;= 0 ? process[pos_vsz] : ''),
                  command: (pos_command &gt;= 0 ? process[pos_command] : '')
                })
              })
            }
          } catch (err) {
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - netIO.wx | X | X |  | sent bytes via network |
| - blockIO.r | X | X |  | bytes read from BlockIO |
| - blockIO.w | X | X |  | bytes written to BlockIO |
| - cpu_stats | X | X |  | detailed cpu stats |
| - percpu_stats | X | X |  | detailed per cpu stats |
| - memory_stats | X | X |  | detailed memory stats |
| - networks | X | X |  | detailed network stats per interface |
| si.<span class="apidocCodeKeywordSpan">dockerContainerProcesses</span>(id, cb) | X | X |  | array of processes inside a container
 |
| - [0].pid_host | X | X |  | process ID (host) |
| - [0].ppid | X | X |  | parent process ID |
| - [0].pgid | X | X |  | process group ID |
| - [0].user | X | X |  | effective user name |
| - [0].ruser | X | X |  | real user name |
| - [0].group | X | X |  | effective group name |
| - [0].rgroup | X | X |  | real group name |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.dockerContainerStats" id="apidoc.module.systeminformation.dockerContainerStats">module systeminformation.dockerContainerStats</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainerStats.dockerContainerStats" id="apidoc.element.systeminformation.dockerContainerStats.dockerContainerStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerStats
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerStats(containerID, callback) {
  containerID = containerID || '';
  let result = {
    id: containerID,
    mem_usage: 0,
    mem_limit: 0,
    mem_percent: 0,
    cpu_percent: 0,
    pids: 0,
    netIO: {
      rx: 0,
      wx: 0
    },
    blockIO: {
      r: 0,
      w: 0
    }
  };
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getStats(containerID, data =&gt; {
          // let cmd = "curl --unix-socket /var/run/docker.sock http:/containers/" + containerID + "/stats?stream=0";
          // exec(cmd, function (error, stdout) {
          //   if (!error) {
          //     let jsonString = stdout.toString();
          try {
//              let stats = JSON.parse(jsonString);
            let stats = data;
<span class="apidocCodeCommentSpan">            /**
             * @namespace
             * @property {Object}  memory_stats
             * @property {number}  memory_stats.usage
             * @property {number}  memory_stats.limit
             * @property {Object}  cpu_stats
             * @property {Object}  pids_stats
             * @property {number}  pids_stats.current
             * @property {Object}  networks
             * @property {Object}  blkio_stats
             */
</span>
            if (!stats.message) {
              result.mem_usage = (stats.memory_stats &amp;&amp; stats.memory_stats.usage ? stats.memory_stats.usage : 0);
              result.mem_limit = (stats.memory_stats &amp;&amp; stats.memory_stats.limit ? stats.memory_stats.limit : 0);
              result.mem_percent = (stats.memory_stats &amp;&amp; stats.memory_stats.usage &amp;&amp; stats.memory_stats.limit ? stats.memory_stats
.usage / stats.memory_stats.limit * 100.0 : 0);
              result.cpu_percent = (stats.cpu_stats ? docker_calcCPUPercent(stats.cpu_stats, containerID) : 0);
              result.pids = (stats.pids_stats &amp;&amp; stats.pids_stats.current ? stats.pids_stats.current : 0);
              if (stats.networks) result.netIO = docker_calcNetworkIO(stats.networks);
              if (stats.blkio_stats) result.blockIO = docker_calcBlockIO(stats.blkio_stats);
              result.cpu_stats = (stats.cpu_stats ? stats.cpu_stats : {});
              result.precpu_stats = (stats.precpu_stats ? stats.precpu_stats : {});
              result.memory_stats = (stats.memory_stats ? stats.memory_stats : {});
              result.networks = (stats.networks ? stats.networks : {});
            }
          } catch (err) {
          }
          // }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
| - [0].ports | X | X |  | array of ports |
| - [0].mounts | X | X |  | array of mounts |
| si.<span class="apidocCodeKeywordSpan">dockerContainerStats</span>(id, cb) | X | X |  | statistics for a specific container |
| - id | X | X |  | Container ID |
| - mem_usage | X | X |  | memory usage in bytes |
| - mem_limit | X | X |  | memory limit (max mem) in bytes |
| - mem_percent | X | X |  | memory usage in percent |
| - cpu_percent | X | X |  | cpu usage in percent |
| - pids | X | X |  | number of processes |
| - netIO.rx | X | X |  | received bytes via network |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.dockerContainers" id="apidoc.module.systeminformation.dockerContainers">module systeminformation.dockerContainers</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainers.dockerContainers" id="apidoc.element.systeminformation.dockerContainers.dockerContainers">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainers
        <span class="apidocSignatureSpan">(all, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainers(all, callback) {

  function inContainers(containers, id) {
    let filtered = containers.filter(obj =&gt; {
<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {string}  Id
       */
</span>      return (obj.Id &amp;&amp; (obj.Id == id))
    });
    return (filtered.length &gt; 0);
  }

  // fallback - if only callback is given
  if (util.isFunction(all) &amp;&amp; !callback) {
    callback = all;
    all = false;
  }

  all = all || false;
  let result = [];
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      if (!_docker_socket) {
        _docker_socket = new DockerSocket();
      }

      _docker_socket.listContainers(all, data =&gt; {
        let docker_containers = {};
        // let cmd = "curl --unix-socket /var/run/docker.sock http:/containers/json" + (all ? "?all=1" : "");
        // exec(cmd, function (error, stdout) {
        //   if (!error) {
        try {
          //       let jsonString = stdout.toString();
          //       let docker_containers = JSON.parse(jsonString);
          docker_containers = data;
          if (docker_containers &amp;&amp; Object.prototype.toString.call(docker_containers) === '[object Array]' &amp;&amp; docker_containers.length
 &gt; 0) {
            docker_containers.forEach(function (element) {
              /**
               * @namespace
               * @property {string}  Id
               * @property {string}  Name
               * @property {string}  Image
               * @property {string}  ImageID
               * @property {string}  Command
               * @property {number}  Created
               * @property {string}  State
               * @property {Array}  Names
               * @property {Array}  Ports
               * @property {Array}  Mounts
               */

              if (element.Names &amp;&amp; Object.prototype.toString.call(element.Names) === '[object Array]' &amp;&amp; element.Names.length &gt;
0) {
                element.Name = element.Names[0].replace(/^\/|\/$/g, '');
              }
              result.push({
                id: element.Id,
                name: element.Name,
                image: element.Image,
                imageID: element.ImageID,
                command: element.Command,
                created: element.Created,
                state: element.State,
                ports: element.Ports,
                mounts: element.Mounts,
                // hostconfig: element.HostConfig,
                // network: element.NetworkSettings
              })
            });
          }
        } catch (err) {
        }
        // }

        // GC in _docker_container_stats
        for (let key in _docker_container_stats) {
          if (_docker_container_stats.hasOwnProperty(key)) {
            if (!inContainers(docker_containers, key)) delete _docker_container_stats[key];
          }
        }
        if (callback) { callback(result) }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&lt;br&gt;host parameter is optional (default
 8.8.8.8)|
| si.<span class="apidocCodeKeywordSpan">dockerContainers</span>(all, cb) | X | X |  | returns array of active/all docker containers
 |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.dockerSocket" id="apidoc.module.systeminformation.dockerSocket">module systeminformation.dockerSocket</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.dockerSocket.dockerSocket" id="apidoc.element.systeminformation.dockerSocket.dockerSocket">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerSocket
        <span class="apidocSignatureSpan">(all, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class DockerSocket {

  listContainers(all, callback) {
    try {

      let socket = net.createConnection({path: '/var/run/docker.sock'});
      let alldata = '';

      socket.on("connect", () =&gt; {
        socket.write('GET http:/containers/json' + (all ? "?all=1" : "") + ' HTTP/1.0\r\n\r\n');
      });

      socket.on("data", data =&gt; {
        alldata = alldata + data.toString();
      });

      socket.on("error", () =&gt; {
        socket = false;
        callback({});
      });

      socket.on('end', () =&gt; {
        let startbody = alldata.indexOf("\r\n\r\n");
        alldata = alldata.substring(startbody, 100000).replace(/[\n\r]/g, '');
        socket = false;
        callback(JSON.parse(alldata));
      });
    } catch (err) {
      callback({});
    }
  }

  getStats(id, callback) {
    id = id || '';
    if (id) {
      try {
        let socket = net.createConnection({path: '/var/run/docker.sock'});
        let alldata = '';

        socket.on("connect", () =&gt; {
          socket.write('GET http:/containers/' + id + '/stats?stream=0 HTTP/1.0\r\n\r\n');
        });

        socket.on("data", data =&gt; {
          alldata = alldata + data.toString();
        });

        socket.on("error", () =&gt; {
          socket = false;
          callback({});
        });

        socket.on('end', () =&gt; {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody, 100000).replace(/[\n\r]/g, '');
          socket = false;
          callback(JSON.parse(alldata));
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }

  getProcesses(id, callback) {
    id = id || '';
    if (id) {
      try {
        let socket = net.createConnection({path: '/var/run/docker.sock'});
        let alldata = '';

        socket.on("connect", () =&gt; {
          socket.write('GET http:/containers/' + id + '/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,
stat,rss,args HTTP/1.0\r\n\r\n');
        });

        socket.on("data", data =&gt; {
          alldata = alldata + data.toString();
        });

        socket.on("error", () =&gt; {
          socket = false;
          callback({});
        });

        socket.on('end', () =&gt; {
          let startbody = alldata.indexOf("\r\n\r\n");
          alldata = alldata.substring(startbody, 100000).replace(/[\n\r]/g, '');
          socket = false;
          callback(JSON.parse(alldata));
        });
      } catch (err) {
        callback({});
      }
    } else {
      callback({});
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.filesystem" id="apidoc.module.systeminformation.filesystem">module systeminformation.filesystem</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.blockDevices" id="apidoc.element.systeminformation.filesystem.blockDevices">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>blockDevices
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function blockDevices(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_linux) {
        // see https://wiki.ubuntuusers.de/lsblk/
        // exec("lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-
IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME", function (error, stdout) {
        exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER", function (error, stdout
) {
          let data = [];
          if (!error) {
            let lines = blkStdoutToObject(stdout).split('\n');
            data = parseBlk(lines);
            if (callback) {
              callback(data)
            }
            resolve(data);
          } else {
            exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER", function (error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split('\n');
                data = parseBlk(lines);
              }
              if (callback) {
                callback(data)
              }
              resolve(data);
            });
          }
        });
      }
      if (_darwin) {
        exec("diskutil info -all", function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split('\n');
            // parse lines into temp array of devices
            data = parseDevices(lines);
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec('wmic logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber
 /format:csv', function (error, stdout) {
          if (!error) {
            let lines = stdout.split('\r\n').filter(line =&gt; line.trim() != '').filter((line, idx) =&gt; idx &gt; 0);
            lines.forEach(function (line) {
              if (line != '') {
                line = line.replace('\r', '').split(',');
                data.push({
                  name: line[7],
                  identifier: line[1],
                  type: 'disk',
                  fstype: line[5].toLowerCase(),
                  mount: line[1],
                  size: line[8],
                  physical: line[4] == '5' ? 'CD/DVD' : 'HDD',
                  uuid: line[10],
                  label: line[9],
                  model: '',
                  serial: line[10],
                  removable: line[4] == '2',
                  protocol: ''
                });
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.fsSize(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.<span class="apidocCodeKeywordSpan">blockDevices</span>(cb) | X | X | X | returns array of disks, partitions,&lt;br&gt;
raids and roms |
| - [0].name | X | X | X | name |
| - [0].type | X | X | X | type |
| - [0].fstype | X | X | X | file system type (e.g. ext4) |
| - [0].mount | X | X | X | mount point |
| - [0].size | X | X | X | size in bytes |
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.disksIO" id="apidoc.element.systeminformation.filesystem.disksIO">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>disksIO
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disksIO(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: -1,
        wIO_sec: -1,
        tIO_sec: -1,
        ms: 0
      };
      let rIO = 0;
      let wIO = 0;

      if ((_disk_io &amp;&amp; !_disk_io.ms) || (_disk_io &amp;&amp; _disk_io.ms &amp;&amp; Date.now() - _disk_io.ms &gt;= 500)) {
        if (_linux) {
          // prints Block layer statistics for all mounted volumes
          // var cmd = "for mount in `lsblk | grep / | sed -r 's/ //' | cut -d ' ' -f 1`; do cat /sys/block/$mount/stat | sed
 -r 's/ +/;/g' | sed -r 's/^;//'; done";
          // var cmd = "for mount in `lsblk | grep / | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do cat /
sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done";
          let cmd = "for mount in `lsblk | grep ' disk ' | sed 's/[]//g' | awk '{$1=$1};1' | cut -d ' ' -f 1 | sort -u`; do
cat /sys/block/$mount/stat | sed -r 's/ +/;/g' | sed -r 's/^;//'; done";

          exec(cmd, function (error, stdout) {
            if (!error) {
              let lines = stdout.split('\n');
              lines.forEach(function (line) {
                // ignore empty lines
                if (!line) return;

                // sum r/wIO of all disks to compute all disks IO
                let stats = line.split(';');
                rIO += parseInt(stats[0]);
                wIO += parseInt(stats[4]);
              });
              result = calcDiskIO(rIO, wIO);

              if (callback) {
                callback(result)
              }
              resolve(result);
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          });
        }
        if (_darwin) {
          exec("ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics
' | tr -cd '01234567890,\n' | awk -F',' '{print $1, $11}'", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              lines.forEach(function (line) {
                line = line.trim();
                if (line != '') {
                  line = line.split(' ');

                  rIO += parseInt(line[1]);
                  wIO += parseInt(line[0]);
                }
              });
              result = calcDiskIO(rIO, wIO);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.rIO = _disk_io.rIO;
        result.wIO = _disk_io.wIO;
        result.tIO = _disk_io.rIO + _disk_io.wIO;
        result.ms = _disk_io.last_ms;
        result.rIO_sec = _disk_io.rIO_sec;
        result.wIO_sec = _disk_io.wIO_sec;
        result.tIO_sec = _disk_io.tIO_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">disksIO</span>(cb) | X | X |  | current transfer stats |
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.fsSize" id="apidoc.element.systeminformation.filesystem.fsSize">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsSize
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsSize(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_linux || _darwin) {
        let cmd = (_darwin ? "df -lkP | grep ^/" : "df -lkPT | grep ^/");
        exec(cmd, function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split('\n');
            //lines.splice(0, 1);
            lines.forEach(function (line) {
              if (line != '') {
                line = line.replace(/ +/g, " ").split(' ');
                data.push({
                  'fs': line[0],
                  'type': (_linux ? line[1] : 'HFS'),
                  'size': parseInt((_linux ? line[2] : line[1])) * 1024,
                  'used': parseInt((_linux ? line[3] : line[2])) * 1024,
                  'use': parseFloat((100.0 * (_linux ? line[3] : line[2]) / (_linux ? line[2] : line[1])).toFixed(2)),
                  'mount': line[line.length - 1]
                })
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec('wmic logicaldisk get Caption,FileSystem,FreeSpace,Size', function (error, stdout) {
          let lines = stdout.split('\r\n').filter(line =&gt; line.trim() != '').filter((line, idx) =&gt; idx &gt; 0);
          lines.forEach(function (line) {
            if (line != '') {
              line = line.trim().split(/\s\s+/);
              data.push({
                'fs': line[0],
                'type': line[1],
                'size': line[3],
                'used': parseInt(line[3]) - parseInt(line[2]),
                'use': parseFloat((100.0 * (parseInt(line[3]) - parseInt(line[2]))) / parseInt(line[3])),
                'mount': line[0]
              })
            }
          });
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - displays[0].builtin | X | X |  | true if built in monitor |
| - displays[0].connection | X | X |  | e.g. DisplayPort or HDMI |
| - displays[0].resolutionx | X | X |  | pixel horizontal |
| - displays[0].resolutiony | X | X |  | pixel vertical |
| - displays[0].depth | X | X |  | color depth in bits |
| - displays[0].sizex | X | X |  | size in mm horizontal |
| - displays[0].sizey | X | X |  | size in mm vertical |
| si.<span class="apidocCodeKeywordSpan">fsSize</span>(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.blockDevices(cb) | X | X | X | returns array of disks, partitions,&lt;br&gt;raids and roms |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.fsStats" id="apidoc.element.systeminformation.filesystem.fsStats">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsStats(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: -1,
        wx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let rx = 0;
      let wx = 0;
      if ((_fs_speed &amp;&amp; !_fs_speed.ms) || (_fs_speed &amp;&amp; _fs_speed.ms &amp;&amp; Date.now() - _fs_speed.ms &gt;= 500)) {
        if (_linux) {
//  		  exec("df -k | grep /dev/", function(error, stdout) {
          exec("lsblk | grep /", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              let fs_filter = [];
              lines.forEach(function (line) {
                if (line != '') {
                  line = line.replace(/[]+/g, "").trim().split(' ');
                  if (fs_filter.indexOf(line[0]) == -1) fs_filter.push(line[0])
                }
              });

              let output = fs_filter.join('|');
              exec("cat /proc/diskstats | egrep '" + output + "'", function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split('\n');
                  lines.forEach(function (line) {
                    line = line.trim();
                    if (line != '') {
                      line = line.replace(/ +/g, " ").split(' ');

                      rx += parseInt(line[5]) * 512;
                      wx += parseInt(line[9]) * 512;
                    }
                  });
                  result = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result)
                }
                resolve(result);
              })
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          })
        }
        if (_darwin) {
          exec("ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics
' | tr -cd '01234567890,\n' | awk -F',' '{print $3, $10}'", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              lines.forEach(function (line) {
                line = line.trim();
                if (line != '') {
                  line = line.split(' ');

                  rx += parseInt(line[0]);
                  wx += parseInt(line[1]);
                }
              });
              result = calcFsSpeed(rx, wx);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.ms = _fs_speed.last_ms;
        result.rx = _fs_speed.bytes_read;
        result.wx = _fs_speed.bytes_write;
        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
        result.rx_sec = _fs_speed.rx_sec;
        result.wx_sec = _fs_speed.wx_sec;
        result.tx_sec = _fs_speed.tx_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
| - [0].label | X | X | X | label |
| - [0].model | X | X |  | model |
| - [0].serial | X |  | X | serial |
| - [0].removable | X | X | X | serial |
| - [0].protocol | X | X |  | protocol (SATA, PCI-Express, ...) |
| si.<span class="apidocCodeKeywordSpan">fsStats</span>(cb) | X | X |  | current transfer stats |
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.fsSize" id="apidoc.module.systeminformation.fsSize">module systeminformation.fsSize</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.fsSize.fsSize" id="apidoc.element.systeminformation.fsSize.fsSize">
        function <span class="apidocSignatureSpan">systeminformation.</span>fsSize
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsSize(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_linux || _darwin) {
        let cmd = (_darwin ? "df -lkP | grep ^/" : "df -lkPT | grep ^/");
        exec(cmd, function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split('\n');
            //lines.splice(0, 1);
            lines.forEach(function (line) {
              if (line != '') {
                line = line.replace(/ +/g, " ").split(' ');
                data.push({
                  'fs': line[0],
                  'type': (_linux ? line[1] : 'HFS'),
                  'size': parseInt((_linux ? line[2] : line[1])) * 1024,
                  'used': parseInt((_linux ? line[3] : line[2])) * 1024,
                  'use': parseFloat((100.0 * (_linux ? line[3] : line[2]) / (_linux ? line[2] : line[1])).toFixed(2)),
                  'mount': line[line.length - 1]
                })
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec('wmic logicaldisk get Caption,FileSystem,FreeSpace,Size', function (error, stdout) {
          let lines = stdout.split('\r\n').filter(line =&gt; line.trim() != '').filter((line, idx) =&gt; idx &gt; 0);
          lines.forEach(function (line) {
            if (line != '') {
              line = line.trim().split(/\s\s+/);
              data.push({
                'fs': line[0],
                'type': line[1],
                'size': line[3],
                'used': parseInt(line[3]) - parseInt(line[2]),
                'use': parseFloat((100.0 * (parseInt(line[3]) - parseInt(line[2]))) / parseInt(line[3])),
                'mount': line[0]
              })
            }
          });
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - displays[0].builtin | X | X |  | true if built in monitor |
| - displays[0].connection | X | X |  | e.g. DisplayPort or HDMI |
| - displays[0].resolutionx | X | X |  | pixel horizontal |
| - displays[0].resolutiony | X | X |  | pixel vertical |
| - displays[0].depth | X | X |  | color depth in bits |
| - displays[0].sizex | X | X |  | size in mm horizontal |
| - displays[0].sizey | X | X |  | size in mm vertical |
| si.<span class="apidocCodeKeywordSpan">fsSize</span>(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.blockDevices(cb) | X | X | X | returns array of disks, partitions,&lt;br&gt;raids and roms |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.fsStats" id="apidoc.module.systeminformation.fsStats">module systeminformation.fsStats</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.fsStats.fsStats" id="apidoc.element.systeminformation.fsStats.fsStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>fsStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsStats(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: -1,
        wx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let rx = 0;
      let wx = 0;
      if ((_fs_speed &amp;&amp; !_fs_speed.ms) || (_fs_speed &amp;&amp; _fs_speed.ms &amp;&amp; Date.now() - _fs_speed.ms &gt;= 500)) {
        if (_linux) {
//  		  exec("df -k | grep /dev/", function(error, stdout) {
          exec("lsblk | grep /", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              let fs_filter = [];
              lines.forEach(function (line) {
                if (line != '') {
                  line = line.replace(/[]+/g, "").trim().split(' ');
                  if (fs_filter.indexOf(line[0]) == -1) fs_filter.push(line[0])
                }
              });

              let output = fs_filter.join('|');
              exec("cat /proc/diskstats | egrep '" + output + "'", function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split('\n');
                  lines.forEach(function (line) {
                    line = line.trim();
                    if (line != '') {
                      line = line.replace(/ +/g, " ").split(' ');

                      rx += parseInt(line[5]) * 512;
                      wx += parseInt(line[9]) * 512;
                    }
                  });
                  result = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result)
                }
                resolve(result);
              })
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          })
        }
        if (_darwin) {
          exec("ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n '/IOBlockStorageDriver/,/Statistics/p' | grep 'Statistics
' | tr -cd '01234567890,\n' | awk -F',' '{print $3, $10}'", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              lines.forEach(function (line) {
                line = line.trim();
                if (line != '') {
                  line = line.split(' ');

                  rx += parseInt(line[0]);
                  wx += parseInt(line[1]);
                }
              });
              result = calcFsSpeed(rx, wx);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.ms = _fs_speed.last_ms;
        result.rx = _fs_speed.bytes_read;
        result.wx = _fs_speed.bytes_write;
        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
        result.rx_sec = _fs_speed.rx_sec;
        result.wx_sec = _fs_speed.wx_sec;
        result.tx_sec = _fs_speed.tx_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
| - [0].label | X | X | X | label |
| - [0].model | X | X |  | model |
| - [0].serial | X |  | X | serial |
| - [0].removable | X | X | X | serial |
| - [0].protocol | X | X |  | protocol (SATA, PCI-Express, ...) |
| si.<span class="apidocCodeKeywordSpan">fsStats</span>(cb) | X | X |  | current transfer stats |
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.fullLoad" id="apidoc.module.systeminformation.fullLoad">module systeminformation.fullLoad</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.fullLoad.fullLoad" id="apidoc.element.systeminformation.fullLoad.fullLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>fullLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fullLoad(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      getFullLoad().then(result =&gt; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.<span class="apidocCodeKeywordSpan">fullLoad</span>(cb) | X | X |  | CPU-full load since bootup in % |
| si.services('mysql, apache2', cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.getAllData" id="apidoc.module.systeminformation.getAllData">module systeminformation.getAllData</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.getAllData.getAllData" id="apidoc.element.systeminformation.getAllData.getAllData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getAllData
        <span class="apidocSignatureSpan">(srv, iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAllData(srv, iface, callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let data = {};

      getStaticData().then(res =&gt; {
        data = res;
        getDynamicData(srv, iface).then(res =&gt; {
          for (let key in res) {
            if (res.hasOwnProperty(key)) {
              data[key] = res[key];
            }
          }
          if (callback) { callback(data) }
          resolve(data);
        });
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&lt;br&gt;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.<span class="apidocCodeKeywordSpan">getAllData</span>(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:

**Callback Style**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.getDynamicData" id="apidoc.module.systeminformation.getDynamicData">module systeminformation.getDynamicData</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.getDynamicData.getDynamicData" id="apidoc.element.systeminformation.getDynamicData.getDynamicData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getDynamicData
        <span class="apidocSignatureSpan">(srv, iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDynamicData(srv, iface, callback) {

  if (util.isFunction(iface)) {
    callback = iface;
    iface = '';
  }
  if (util.isFunction(srv)) {
    callback = srv;
    srv = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      iface = iface || network.getDefaultNetworkInterface();
      srv = srv || '';

      // use closure to track  completion
      let functionProcessed = (function () {
        let totalFunctions = 14;

        return function () {
          if (--totalFunctions === 0) {
            if (callback) { callback(data) }
            resolve(data);
          }
        };
      })();

      // var totalFunctions = 14;
      // function functionProcessed() {
      //   if (--totalFunctions === 0) {
      //     if (callback) { callback(data) }
      //     resolve(data);
      //   }
      // }

      let data = {};

      // get time
      data.time = osInfo.time();

<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {Object}  versions
       * @property {string}  versions.node
       * @property {string}  versions.v8
       */
</span>      data.node = process.versions.node;
      data.v8 = process.versions.v8;

      cpu.cpuCurrentspeed().then(res =&gt; {
        data.cpuCurrentspeed = res;
        functionProcessed();
      });

      users.users().then(res =&gt; {
        data.users = res;
        functionProcessed();
      });

      processes.processes().then(res =&gt; {
        data.processes = res;
        functionProcessed();
      });

      cpu.currentLoad().then(res =&gt; {
        data.currentLoad = res;
        functionProcessed();
      });

      cpu.cpuTemperature().then(res =&gt; {
        data.temp = res;
        functionProcessed();
      });

      network.networkStats(iface).then(res =&gt; {
        data.networkStats = res;
        functionProcessed();
      });

      network.networkConnections().then(res =&gt; {
        data.networkConnections = res;
        functionProcessed();
      });

      mem().then(res =&gt; {
        data.mem = res;
        functionProcessed();
      });

      battery().then(res =&gt; {
        data.battery = res;
        functionProcessed();
      });

      processes.services(srv).then(res =&gt; {
        data.services = res;
        functionProcessed();
      });

      filesystem.fsSize().then(res =&gt; {
        data.fsSize = res;
        functionProcessed();
      });

      filesystem.fsStats().then(res =&gt; {
        data.fsStats = res;
        functionProcessed();
      });

      filesystem.disksIO().then(res =&gt; {
        data.disksIO = res;
        functionProcessed();
      });

      internet.inetLatency().then(res =&gt; {
        data.inetLatency = res;
        functionProcessed();
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&lt;br&gt;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.<span class="apidocCodeKeywordSpan">getDynamicData</span>(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:

**Callback Style**
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.getStaticData" id="apidoc.module.systeminformation.getStaticData">module systeminformation.getStaticData</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.getStaticData.getStaticData" id="apidoc.element.systeminformation.getStaticData.getStaticData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getStaticData
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStaticData(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let data = {};

      data.version = version();

      system().then(res =&gt; {
        data.system = res;
        osInfo.osInfo().then(res =&gt; {
          data.os = res;
          osInfo.versions().then(res =&gt; {
            data.versions = res;
            cpu.cpu().then(res =&gt; {
              data.cpu = res;
              graphics.graphics().then(res =&gt; {
                data.graphics = res;
                network.networkInterfaces().then(res =&gt; {
                  data.net = res;
                  if (callback) { callback(data) }
                  resolve(data);
                })
              })
            })
          })
        })
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&lt;br&gt;and processes in one single array |
| si.<span class="apidocCodeKeywordSpan">getStaticData</span>(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.graphics" id="apidoc.module.systeminformation.graphics">module systeminformation.graphics</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.graphics.graphics" id="apidoc.element.systeminformation.graphics.graphics">
        function <span class="apidocSignatureSpan">systeminformation.</span>graphics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function graphics(callback) {

  function parseLinesDarwin(lines) {
    let starts = [];
    let level = -1;
    let lastlevel = -1;
    let controllers = [];
    let displays = [];
    let currentController = {};
    let currentDisplay = {};
    for (let i = 0; i &lt; lines.length; i++) {
      if ('' != lines[i].trim()) {
        let start = lines[i].search(/\S|$/);
        if (-1 == starts.indexOf(start)) {
          starts.push(start);
        }
        level = starts.indexOf(start);
        if (level &lt; lastlevel) {
          if (Object.keys(currentController).length &gt; 0) {// just changed to Displays
            controllers.push(currentController);
            currentController = {};
          }
          if (Object.keys(currentDisplay).length &gt; 0) {// just changed to Displays
            displays.push(currentDisplay);
            currentDisplay = {};
          }
        }
        lastlevel = level;
        let parts = lines[i].split(':');
        if (2 == level) {       // grafics controller level
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('chipsetmodel') != -1) currentController.model
 = parts[1].trim();
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('bus') != -1) currentController.bus = parts[
1].trim();
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('vendor') != -1) currentController.vendor =
parts[1].split('(')[0].trim();
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('vram(total)') != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = false;
          }
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('vram(dynamic,max)') != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = true;
          }
        }
        if (3 == level) {       // display controller level
          if (parts.length &gt; 1 &amp;&amp; '' == parts[1]) {
            currentDisplay.model = parts[0].trim();
            currentDisplay.main = false;
            currentDisplay.builtin = false;
            currentDisplay.connection = '';
            currentDisplay.sizex = -1;
            currentDisplay.sizey = -1;
          }
        }
        if (4 == level) {       // display controller details level
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('resolution') != -1) {
            let resolution = parts[1].split('x');
            currentDisplay.resolutionx = (resolution.length &gt; 1 ? parseInt(resolution[0]) : 0);
            currentDisplay.resolutiony = (resolution.length &gt; 1 ? parseInt(resolution[1]) : 0);
          }
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('pixeldepth') != -1) currentDisplay.pixeldepth
 = parseInt(parts[1]); // in BIT
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('maindisplay') != -1 &amp;&amp; parts[1].replace(/ +/
g, "").toLowerCase() == 'yes') currentDisplay.main = true;
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('built-in') != -1 &amp;&amp; parts[1].replace(/ +/g, "").
toLowerCase() == 'yes') {
            currentDisplay.builtin = true;
            currentDisplay.connection = '';
          }
          if (parts.length &gt; 1 &amp;&amp; parts[0].replace(/ +/g, "").toLowerCase().indexOf('connectiontype') != -1) {
            currentDisplay.builtin = false;
            currentDisplay.connection = parts[1].trim();
          }
        }
      }
    }
    if (Object.keys(currentController).length &gt; 0) {// just changed to Displays
      controllers.push(currentController);
    }
    if (Object.keys(currentDisplay).length &gt; 0) {// just changed to Displays
      displays.push(currentDisplay);
    }
    return ({
      controllers: controllers,
      displays: displays
    })
  }

  function parseLinesLinuxControllers(lines) {
    let controllers = [];
    let currentController = {};
    let is_vga = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - swapfree | X | X |  |  |
| si.battery(cb) | X | X |  | battery information |
| - hasbattery | X | X |  | indicates presence of battery |
| - ischarging | X | X |  | indicates if battery is charging |
| - maxcapacity | X | X |  | max capacity of battery |
| - currentcapacity | X | X |  | current capacity of battery |
| - percent | X | X |  | charging level in percent |
| si.<span class="apidocCodeKeywordSpan">graphics</span>(cb) | X | X |  | arrays of graphics controllers and displays |
| - controllers[0].model | X | X |  | graphics controller model |
| - controllers[0].vendor | X | X |  | e.g. ATI |
| - controllers[0].bus | X | X |  | on which bus (e.g. PCIe) |
| - controllers[0].vram | X | X |  | VRAM size (in MB) |
| - controllers[0].vramDynamic | X | X |  | true if dynamicly allocated ram |
| - displays[0].model | X | X |  | Monitor/Display Model |
| - displays[0].main | X | X |  | true if main monitor |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.inetChecksite" id="apidoc.module.systeminformation.inetChecksite">module systeminformation.inetChecksite</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.inetChecksite.inetChecksite" id="apidoc.element.systeminformation.inetChecksite.inetChecksite">
        function <span class="apidocSignatureSpan">systeminformation.</span>inetChecksite
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetChecksite(url, callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        url: url,
        ok: false,
        status: 404,
        ms: -1
      };
      if (url) {
        let t = Date.now();
        let args = " -I --connect-timeout 5 -m 5 " + url + " 2&gt;/dev/null | head -n 1 | cut -d ' ' -f2";
        let cmd = "curl";
        exec(cmd + args, function (error, stdout) {
          let statusCode = parseInt(stdout.toString());
          result.status = statusCode || 404;
          result.ok = !error &amp;&amp; (statusCode == 200 || statusCode == 301 || statusCode == 302 || statusCode == 304);
          result.ms = (result.ok ? Date.now() - t : -1);
          if (callback) { callback(result) }
          resolve(result);
        })
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.<span class="apidocCodeKeywordSpan">inetChecksite</span>(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&lt;br&gt;host parameter is optional (default
 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.inetLatency" id="apidoc.module.systeminformation.inetLatency">module systeminformation.inetLatency</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.inetLatency.inetLatency" id="apidoc.element.systeminformation.inetLatency.inetLatency">
        function <span class="apidocSignatureSpan">systeminformation.</span>inetLatency
        <span class="apidocSignatureSpan">(host, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetLatency(host, callback) {

  // fallback - if only callback is given
  if (util.isFunction(host) &amp;&amp; !callback) {
    callback = host;
    host = '';
  }

  host = host || '8.8.8.8';

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let t = Date.now();
      let cmd;
      if (_linux) {
        cmd = "ping -c 2 -w 3 " + host + " | grep rtt | cut -d'/' -f4 | awk '{ print $3 }'";
      }
      if (_darwin) {
        cmd = "ping -c 2 -t 3 " + host + " | grep avg | cut -d'/' -f4 | awk '{ print $3 }'";
      }

      exec(cmd, function (error, stdout) {
        let result = -1;
        if (!error) {
          result = parseFloat(stdout.toString());
        }
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.<span class="apidocCodeKeywordSpan">inetLatency</span>(host, cb) | X | X |  | response-time (ms) to external resource&lt;
br&gt;host parameter is optional (default 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.internet" id="apidoc.module.systeminformation.internet">module systeminformation.internet</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.internet.inetChecksite" id="apidoc.element.systeminformation.internet.inetChecksite">
        function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetChecksite
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetChecksite(url, callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        url: url,
        ok: false,
        status: 404,
        ms: -1
      };
      if (url) {
        let t = Date.now();
        let args = " -I --connect-timeout 5 -m 5 " + url + " 2&gt;/dev/null | head -n 1 | cut -d ' ' -f2";
        let cmd = "curl";
        exec(cmd + args, function (error, stdout) {
          let statusCode = parseInt(stdout.toString());
          result.status = statusCode || 404;
          result.ok = !error &amp;&amp; (statusCode == 200 || statusCode == 301 || statusCode == 302 || statusCode == 304);
          result.ms = (result.ok ? Date.now() - t : -1);
          if (callback) { callback(result) }
          resolve(result);
        })
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.<span class="apidocCodeKeywordSpan">inetChecksite</span>(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&lt;br&gt;host parameter is optional (default
 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.internet.inetLatency" id="apidoc.element.systeminformation.internet.inetLatency">
        function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetLatency
        <span class="apidocSignatureSpan">(host, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetLatency(host, callback) {

  // fallback - if only callback is given
  if (util.isFunction(host) &amp;&amp; !callback) {
    callback = host;
    host = '';
  }

  host = host || '8.8.8.8';

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let t = Date.now();
      let cmd;
      if (_linux) {
        cmd = "ping -c 2 -w 3 " + host + " | grep rtt | cut -d'/' -f4 | awk '{ print $3 }'";
      }
      if (_darwin) {
        cmd = "ping -c 2 -t 3 " + host + " | grep avg | cut -d'/' -f4 | awk '{ print $3 }'";
      }

      exec(cmd, function (error, stdout) {
        let result = -1;
        if (!error) {
          result = parseFloat(stdout.toString());
        }
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.<span class="apidocCodeKeywordSpan">inetLatency</span>(host, cb) | X | X |  | response-time (ms) to external resource&lt;
br&gt;host parameter is optional (default 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.mem" id="apidoc.module.systeminformation.mem">module systeminformation.mem</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.mem.mem" id="apidoc.element.systeminformation.mem.mem">
        function <span class="apidocSignatureSpan">systeminformation.</span>mem
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mem = function (callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {

      let result = {
        total: os.totalmem(),
        free: os.freemem(),
        used: os.totalmem() - os.freemem(),

        active: os.totalmem() - os.freemem(),     // temporarily (fallback)
        available: os.freemem(),                  // temporarily (fallback)
        buffcache: 0,

        swaptotal: 0,
        swapused: 0,
        swapfree: 0
      };

      if (_linux) {
        exec("free -b", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');

            let mem = lines[1].replace(/ +/g, " ").split(' ');
            result.total = parseInt(mem[1]);
            result.free = parseInt(mem[3]);

            if (lines.length === 4) {                   // free (since free von procps-ng 3.3.10)
              result.buffcache = parseInt(mem[5]);
              result.available = parseInt(mem[6]);
              mem = lines[2].replace(/ +/g, " ").split(' ');
            } else {                                    // free (older versions)
              result.buffcache = parseInt(mem[5]) + parseInt(mem[6]);
              result.available = result.free + result.buffcache;
              mem = lines[3].replace(/ +/g, " ").split(' ');
            }
            result.active = result.total - result.free - result.buffcache;

            result.swaptotal = parseInt(mem[1]);
            result.swapfree = parseInt(mem[3]);
            result.swapused = parseInt(mem[2]);

          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec("vm_stat | grep 'Pages active'", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');

            result.active = parseInt(lines[0].split(':')[1]) * 4096;
            result.buffcache = result.used - result.active;
            result.available = result.free + result.buffcache;
          }
          exec("sysctl -n vm.swapusage", function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split('\n');
              if (lines.length &gt; 0) {
                let line = lines[0].replace(/,/g, ".").replace(/M/g, "");
                line = line.trim().split('  ');
                for (let i = 0; i &lt; line.length; i++) {
                  if (line[i].toLowerCase().indexOf('total') != -1) result.swaptotal = parseFloat(line[i].split('=')[1].trim()) *
1024 * 1024;
                  if (line[i].toLowerCase().indexOf('used') != -1) result.swapused = parseFloat(line[i].split('=')[1].trim()) *
1024 * 1024;
                  if (line[i].toLowerCase().indexOf('free') != -1) result.swapfree = parseFloat(line[i].split('=')[1].trim()) *
1024 * 1024;

                }
              }
            }
            if (callback) { callback(result) }
            resolve(result);
          });
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.cpuTemperature(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
| si.<span class="apidocCodeKeywordSpan">mem</span>(cb) | X | X | X | Memory information|
| - total | X | X | X | total memory |
| - free | X | X | X | not used |
| - used | X | X | X | used (incl. buffers/cache) |
| - active | X | X | X | used actively (excl. buffers/cache)  |
| - buffcache | X | X |  | used by buffers+cache |
| - available | X | X | X | potentially available (total - active) |
| - swaptotal | X | X |  |  |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.network" id="apidoc.module.systeminformation.network">module systeminformation.network</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.network.getDefaultNetworkInterface" id="apidoc.element.systeminformation.network.getDefaultNetworkInterface">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>getDefaultNetworkInterface
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultNetworkInterface() {

  if (!_default_iface) {
    let ifacename = '';
    let cmd = (_linux ? "route 2&gt;/dev/null | grep default | awk '{print $8}'" : "route get 0.0.0.0 2&gt;/dev/null | grep interface: |
awk '{print $2}'");
    let result = execSync(cmd);
    ifacename = result.toString().split('\n')[0];

    if (!ifacename) {         // fallback - "first" external interface
      const sortObject = o =&gt; Object.keys(o).sort().reduce((r, k) =&gt; (r[k] = o[k], r), {});

      let ifaces = sortObject(os.networkInterfaces());

      for (let dev in ifaces) {
        if (ifaces.hasOwnProperty(dev)) {
          ifaces[dev].forEach(function (details) {
            if (details &amp;&amp; details.internal == false) {
              ifacename = ifacename || dev;
            }
          })
        }
      }
    }
    if (ifacename) _default_iface = ifacename;
  }
  return _default_iface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkConnections" id="apidoc.element.systeminformation.network.networkConnections">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkConnections
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkConnections(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];
      if (_linux) {
        let cmd = "netstat -tuna | grep 'ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN\\|VERBUNDEN'";
        exec(cmd, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              line = line.replace(/ +/g, " ").split(' ');
              if (line.length &gt;= 6) {
                let localip = line[3];
                let localport = '';
                let localaddress = line[3].split(':');
                if (localaddress.length &gt; 1) {
                  localport = localaddress[localaddress.length - 1];
                  localaddress.pop();
                  localip = localaddress.join(':');
                }
                let peerip = line[4];
                let peerport = '';
                let peeraddress = line[4].split(':');
                if (peeraddress.length &gt; 1) {
                  peerport = peeraddress[peeraddress.length - 1];
                  peeraddress.pop();
                  peerip = peeraddress.join(':');
                }
                let connstate = line[5];
                if (connstate == 'VERBUNDEN') connstate = 'ESTABLISHED';
                if (connstate) {
                  result.push({
                    protocol: line[0],
                    localaddress: localip,
                    localport: localport,
                    peeraddress: peerip,
                    peerport: peerport,
                    state: connstate
                  })
                }
              }
            });
            if (callback) {
              callback(result)
            }
            resolve(result);
          } else {
            cmd = "ss -tuna | grep 'ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-
ACK\\|LISTEN\\|CLOSING'";
            exec(cmd, function (error, stdout) {

              if (!error) {
                let lines = stdout.toString().split('\n');
                lines.forEach(function (line) {
                  line = line.replace(/ +/g, " ").split(' ');
                  if (line.length &gt;= 6) {
                    let localip = line[4];
                    let localport = '';
                    let localaddress = line[4].split(':');
                    if (localaddress.length &gt; 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(':');
                    }
                    let peerip = line[5];
                    let peerport = '';
                    let peeraddress = line[5].split(':');
                    if (peeraddress.length &gt; 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(':');
                    }
                    let connstate = line[1];
                    if (connstate == 'ESTAB') connstate = 'ESTABLISHED';
                    if (connstate == 'TIME-WAIT') connstate = 'TIME_WAIT';
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localaddress: localip,
                        localport: localport,
                        peeraddress: peerip,
                        peerport: peerport,
                        state: connstate
                      })
                    }
                  }
                });
              }
              if (callback) {
                callback(result)
              }
              resolve(result);
            })
          }
        })
      }
      if (_darwin) {
        l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkConnections</span>(cb) | X | X |  | current network network connections&lt;br&amp;#
x3e;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.currentLoad(cb) | X | X |  | CPU-Load |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkInterfaceDefault" id="apidoc.element.systeminformation.network.networkInterfaceDefault">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaceDefault
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaceDefault(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = getDefaultNetworkInterface();
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ms | X | X |  | interval length (for per second values) |
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.<span class="apidocCodeKeywordSpan">networkInterfaceDefault</span>(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&lt;br&gt;iface parameter is optional&lt;
br&gt;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkInterfaces" id="apidoc.element.systeminformation.network.networkInterfaces">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaces
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaces(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let ifaces = os.networkInterfaces();
      let result = [];

      for (let dev in ifaces) {
        let ip4 = '';
        let ip6 = '';
        let mac = '';
        if (ifaces.hasOwnProperty(dev)) {
          ifaces[dev].forEach(function (details) {
            if (details.family == 'IPv4') {
              ip4 = details.address
            }
            if (details.family == 'IPv6') {
              ip6 = details.address
            }
            mac = details.mac
          });
          let internal = (ifaces[dev] &amp;&amp; ifaces[dev][0]) ? ifaces[dev][0].internal : null;
          result.push({ iface: dev, ip4: ip4, ip6: ip6, mac: mac, internal: internal })
        }
      }
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkInterfaces</span>(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&lt;br&gt;iface parameter is optional&lt;
br&gt;defaults to first external network interface|
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkStats" id="apidoc.element.systeminformation.network.networkStats">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkStats
        <span class="apidocSignatureSpan">(iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkStats(iface, callback) {

  // fallback - if only callback is given
  if (util.isFunction(iface) &amp;&amp; !callback) {
    callback = iface;
    iface = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      _default_iface = _default_iface || getDefaultNetworkInterface();
      iface = iface || _default_iface; // (_darwin ? 'en0' : 'eth0');

      let result = {
        iface: iface,
        operstate: 'unknown',
        rx: 0,
        tx: 0,
        rx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let operstate = 'unknown';
      let rx = 0;
      let tx = 0;

      let cmd, lines, stats;
      if (!_network[iface] || (_network[iface] &amp;&amp; !_network[iface].ms) || (_network[iface] &amp;&amp; _network[iface].ms &amp;&amp; Date.now() -
_network[iface].ms &gt;= 500)) {
        if (_linux) {
          if (fs.existsSync('/sys/class/net/' + iface)) {
            cmd =
              "cat /sys/class/net/" + iface + "/operstate; " +
              "cat /sys/class/net/" + iface + "/statistics/rx_bytes; " +
              "cat /sys/class/net/" + iface + "/statistics/tx_bytes; ";
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split('\n');
                operstate = lines[0].trim();
                rx = parseInt(lines[1]);
                tx = parseInt(lines[2]);

                result = calcNetworkSpeed(iface, rx, tx, operstate);

              }
              if (callback) { callback(result) }
              resolve(result);
            });
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        }
        if (_darwin) {
          cmd = "ifconfig " + iface + " | grep 'status'";
          exec(cmd, function (error, stdout) {
            result.operstate = (stdout.toString().split(':')[1] || '').trim();
            result.operstate = (result.operstate || '').toLowerCase();
            result.operstate = (result.operstate == 'active' ? 'up' : (result.operstate == 'inactive' ? 'down' : 'unknown'));
            cmd = "netstat -bI " + iface;
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split('\n');
                // if there is less than 2 lines, no information for this interface was found
                if (lines.length &gt; 1 &amp;&amp; lines[1].trim() != '') {
                  // skip header line
                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address
                  stats = lines[1].replace(/ +/g, " ").split(' ');
                  rx = parseInt(stats[6]);
                  tx = parseInt(stats[9]);

                  result = calcNetworkSpeed(iface, rx, tx, operstate);
                }
              }
              if (callback) { callback(result) }
              resolve(result);
            });
          });
        }
      } else {
        result.rx = _network[iface].rx;
        result.tx = _network[iface].tx;
        result.rx_sec = _network[iface].rx_sec;
        result.tx_sec = _network[iface].tx_sec;
        result.ms = _network[iface].last_ms;
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.<span class="apidocCodeKeywordSpan">networkStats</span>(iface,cb) | X | X |  | current network stats of given interface&lt;
;br&gt;iface parameter is optional&lt;br&gt;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.networkConnections" id="apidoc.module.systeminformation.networkConnections">module systeminformation.networkConnections</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.networkConnections.networkConnections" id="apidoc.element.systeminformation.networkConnections.networkConnections">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkConnections
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkConnections(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];
      if (_linux) {
        let cmd = "netstat -tuna | grep 'ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN\\|VERBUNDEN'";
        exec(cmd, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              line = line.replace(/ +/g, " ").split(' ');
              if (line.length &gt;= 6) {
                let localip = line[3];
                let localport = '';
                let localaddress = line[3].split(':');
                if (localaddress.length &gt; 1) {
                  localport = localaddress[localaddress.length - 1];
                  localaddress.pop();
                  localip = localaddress.join(':');
                }
                let peerip = line[4];
                let peerport = '';
                let peeraddress = line[4].split(':');
                if (peeraddress.length &gt; 1) {
                  peerport = peeraddress[peeraddress.length - 1];
                  peeraddress.pop();
                  peerip = peeraddress.join(':');
                }
                let connstate = line[5];
                if (connstate == 'VERBUNDEN') connstate = 'ESTABLISHED';
                if (connstate) {
                  result.push({
                    protocol: line[0],
                    localaddress: localip,
                    localport: localport,
                    peeraddress: peerip,
                    peerport: peerport,
                    state: connstate
                  })
                }
              }
            });
            if (callback) {
              callback(result)
            }
            resolve(result);
          } else {
            cmd = "ss -tuna | grep 'ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-
ACK\\|LISTEN\\|CLOSING'";
            exec(cmd, function (error, stdout) {

              if (!error) {
                let lines = stdout.toString().split('\n');
                lines.forEach(function (line) {
                  line = line.replace(/ +/g, " ").split(' ');
                  if (line.length &gt;= 6) {
                    let localip = line[4];
                    let localport = '';
                    let localaddress = line[4].split(':');
                    if (localaddress.length &gt; 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(':');
                    }
                    let peerip = line[5];
                    let peerport = '';
                    let peeraddress = line[5].split(':');
                    if (peeraddress.length &gt; 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(':');
                    }
                    let connstate = line[1];
                    if (connstate == 'ESTAB') connstate = 'ESTABLISHED';
                    if (connstate == 'TIME-WAIT') connstate = 'TIME_WAIT';
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localaddress: localip,
                        localport: localport,
                        peeraddress: peerip,
                        peerport: peerport,
                        state: connstate
                      })
                    }
                  }
                });
              }
              if (callback) {
                callback(result)
              }
              resolve(result);
            })
          }
        })
      }
      if (_darwin) {
        l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkConnections</span>(cb) | X | X |  | current network network connections&lt;br&amp;#
x3e;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.currentLoad(cb) | X | X |  | CPU-Load |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.networkInterfaceDefault" id="apidoc.module.systeminformation.networkInterfaceDefault">module systeminformation.networkInterfaceDefault</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.networkInterfaceDefault.networkInterfaceDefault" id="apidoc.element.systeminformation.networkInterfaceDefault.networkInterfaceDefault">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaceDefault
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaceDefault(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = getDefaultNetworkInterface();
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ms | X | X |  | interval length (for per second values) |
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.<span class="apidocCodeKeywordSpan">networkInterfaceDefault</span>(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&lt;br&gt;iface parameter is optional&lt;
br&gt;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.networkInterfaces" id="apidoc.module.systeminformation.networkInterfaces">module systeminformation.networkInterfaces</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.networkInterfaces.networkInterfaces" id="apidoc.element.systeminformation.networkInterfaces.networkInterfaces">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaces
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaces(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let ifaces = os.networkInterfaces();
      let result = [];

      for (let dev in ifaces) {
        let ip4 = '';
        let ip6 = '';
        let mac = '';
        if (ifaces.hasOwnProperty(dev)) {
          ifaces[dev].forEach(function (details) {
            if (details.family == 'IPv4') {
              ip4 = details.address
            }
            if (details.family == 'IPv6') {
              ip6 = details.address
            }
            mac = details.mac
          });
          let internal = (ifaces[dev] &amp;&amp; ifaces[dev][0]) ? ifaces[dev][0].internal : null;
          result.push({ iface: dev, ip4: ip4, ip6: ip6, mac: mac, internal: internal })
        }
      }
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkInterfaces</span>(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&lt;br&gt;iface parameter is optional&lt;
br&gt;defaults to first external network interface|
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.networkStats" id="apidoc.module.systeminformation.networkStats">module systeminformation.networkStats</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.networkStats.networkStats" id="apidoc.element.systeminformation.networkStats.networkStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkStats
        <span class="apidocSignatureSpan">(iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkStats(iface, callback) {

  // fallback - if only callback is given
  if (util.isFunction(iface) &amp;&amp; !callback) {
    callback = iface;
    iface = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      _default_iface = _default_iface || getDefaultNetworkInterface();
      iface = iface || _default_iface; // (_darwin ? 'en0' : 'eth0');

      let result = {
        iface: iface,
        operstate: 'unknown',
        rx: 0,
        tx: 0,
        rx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let operstate = 'unknown';
      let rx = 0;
      let tx = 0;

      let cmd, lines, stats;
      if (!_network[iface] || (_network[iface] &amp;&amp; !_network[iface].ms) || (_network[iface] &amp;&amp; _network[iface].ms &amp;&amp; Date.now() -
_network[iface].ms &gt;= 500)) {
        if (_linux) {
          if (fs.existsSync('/sys/class/net/' + iface)) {
            cmd =
              "cat /sys/class/net/" + iface + "/operstate; " +
              "cat /sys/class/net/" + iface + "/statistics/rx_bytes; " +
              "cat /sys/class/net/" + iface + "/statistics/tx_bytes; ";
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split('\n');
                operstate = lines[0].trim();
                rx = parseInt(lines[1]);
                tx = parseInt(lines[2]);

                result = calcNetworkSpeed(iface, rx, tx, operstate);

              }
              if (callback) { callback(result) }
              resolve(result);
            });
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        }
        if (_darwin) {
          cmd = "ifconfig " + iface + " | grep 'status'";
          exec(cmd, function (error, stdout) {
            result.operstate = (stdout.toString().split(':')[1] || '').trim();
            result.operstate = (result.operstate || '').toLowerCase();
            result.operstate = (result.operstate == 'active' ? 'up' : (result.operstate == 'inactive' ? 'down' : 'unknown'));
            cmd = "netstat -bI " + iface;
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split('\n');
                // if there is less than 2 lines, no information for this interface was found
                if (lines.length &gt; 1 &amp;&amp; lines[1].trim() != '') {
                  // skip header line
                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address
                  stats = lines[1].replace(/ +/g, " ").split(' ');
                  rx = parseInt(stats[6]);
                  tx = parseInt(stats[9]);

                  result = calcNetworkSpeed(iface, rx, tx, operstate);
                }
              }
              if (callback) { callback(result) }
              resolve(result);
            });
          });
        }
      } else {
        result.rx = _network[iface].rx;
        result.tx = _network[iface].tx;
        result.rx_sec = _network[iface].rx_sec;
        result.tx_sec = _network[iface].tx_sec;
        result.ms = _network[iface].last_ms;
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.<span class="apidocCodeKeywordSpan">networkStats</span>(iface,cb) | X | X |  | current network stats of given interface&lt;
;br&gt;iface parameter is optional&lt;br&gt;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.osInfo" id="apidoc.module.systeminformation.osInfo">module systeminformation.osInfo</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.osInfo.osInfo" id="apidoc.element.systeminformation.osInfo.osInfo">
        function <span class="apidocSignatureSpan">systeminformation.</span>osInfo
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function osInfo(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = {

        platform: (_platform == 'Windows_NT' ? 'Windows' : _platform),
        distro: 'unknown',
        release: 'unknown',
        codename: '',
        kernel: os.release(),
        arch: os.arch(),
        hostname: os.hostname(),
        logofile: ''
      };

      if (_linux) {

        exec("cat /etc<span class="apidocCodeCommentSpan">/*-release", function (error, stdout) {
          //if (!error) {
          /**
           * @namespace
           * @property {string}  DISTRIB_ID
           * @property {string}  NAME
           * @property {string}  DISTRIB_RELEASE
           * @property {string}  VERSION_ID
           * @property {string}  DISTRIB_CODENAME
           */
</span>          let release = {};
          let lines = stdout.toString().split('\n');
          lines.forEach(function (line) {
            if (line.indexOf('=') != -1) {
              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();
            }
          });
          result.distro = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/"/g, '');
          result.logofile = getLogoFile(result.distro);
          result.release = (release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/"/g, '');
          result.codename = (release.DISTRIB_CODENAME || '').replace(/"/g, '');
          //}
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_darwin) {
        exec("sw_vers", function (error, stdout) {
          let lines = stdout.toString().split('\n');
          lines.forEach(function (line) {
            if (line.indexOf('ProductName') != -1) {
              result.distro = line.split(':')[1].trim();
              result.logofile = getLogoFile(result.distro);
            }
            if (line.indexOf('ProductVersion') != -1) result.release = line.split(':')[1].trim();
          });
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_windows) {
        result.logofile = getLogoFile();
        result.release = result.kernel;
        exec("wmic os get Caption", function (error, stdout) {
          result.distro = result.codename = stdout.slice(stdout.indexOf('\r\n') + 2).trim();
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.<span class="apidocCodeKeywordSpan">osInfo</span>(cb) | X | X | X | OS information |
| - platform   | X | X | X | 'Linux', 'Darwin', 'Windows' |
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.osinfo" id="apidoc.module.systeminformation.osinfo">module systeminformation.osinfo</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.osInfo" id="apidoc.element.systeminformation.osinfo.osInfo">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>osInfo
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function osInfo(callback) {

  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = {

        platform: (_platform == 'Windows_NT' ? 'Windows' : _platform),
        distro: 'unknown',
        release: 'unknown',
        codename: '',
        kernel: os.release(),
        arch: os.arch(),
        hostname: os.hostname(),
        logofile: ''
      };

      if (_linux) {

        exec("cat /etc<span class="apidocCodeCommentSpan">/*-release", function (error, stdout) {
          //if (!error) {
          /**
           * @namespace
           * @property {string}  DISTRIB_ID
           * @property {string}  NAME
           * @property {string}  DISTRIB_RELEASE
           * @property {string}  VERSION_ID
           * @property {string}  DISTRIB_CODENAME
           */
</span>          let release = {};
          let lines = stdout.toString().split('\n');
          lines.forEach(function (line) {
            if (line.indexOf('=') != -1) {
              release[line.split('=')[0].trim().toUpperCase()] = line.split('=')[1].trim();
            }
          });
          result.distro = (release.DISTRIB_ID || release.NAME || 'unknown').replace(/"/g, '');
          result.logofile = getLogoFile(result.distro);
          result.release = (release.DISTRIB_RELEASE || release.VERSION_ID || 'unknown').replace(/"/g, '');
          result.codename = (release.DISTRIB_CODENAME || '').replace(/"/g, '');
          //}
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_darwin) {
        exec("sw_vers", function (error, stdout) {
          let lines = stdout.toString().split('\n');
          lines.forEach(function (line) {
            if (line.indexOf('ProductName') != -1) {
              result.distro = line.split(':')[1].trim();
              result.logofile = getLogoFile(result.distro);
            }
            if (line.indexOf('ProductVersion') != -1) result.release = line.split(':')[1].trim();
          });
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_windows) {
        result.logofile = getLogoFile();
        result.release = result.kernel;
        exec("wmic os get Caption", function (error, stdout) {
          result.distro = result.codename = stdout.slice(stdout.indexOf('\r\n') + 2).trim();
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.<span class="apidocCodeKeywordSpan">osInfo</span>(cb) | X | X | X | OS information |
| - platform   | X | X | X | 'Linux', 'Darwin', 'Windows' |
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.shell" id="apidoc.element.systeminformation.osinfo.shell">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>shell
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shell(callback) {
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = '';
      exec("echo $SHELL", function (error, stdout) {
        if (!error) {
          result = stdout.toString().split('\n')[0];
        }
        if (callback) {
          callback(result)
        }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. 'apple', 'debian', 'fedora', ... |
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.<span class="apidocCodeKeywordSpan">shell</span>(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.time" id="apidoc.element.systeminformation.osinfo.time">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time() {
  return {
    current: Date.now(),
    uptime: os.uptime()
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.<span class="apidocCodeKeywordSpan">time</span>() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.versions" id="apidoc.element.systeminformation.osinfo.versions">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>versions
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function versions(callback) {
  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = {
        kernel: os.release(),
        node: process.versions.node,
        v8: process.versions.v8,
        npm: '',
        pm2: '',
        openssl: process.versions.openssl
      };
      let lines = [];
      exec("npm -v", function (error, stdout) {
        if (!error) {
          result.npm = stdout.toString().split('\n')[0];
        }
        exec("pm2 -v", function (error, stdout) {
          if (!error) {
            lines = stdout.toString().split('\n');
            if (lines.length &gt;= 2) {
              result.pm2 = lines[lines.length - 2];
            }
          }
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. 'apple', 'debian', 'fedora', ... |
| si.<span class="apidocCodeKeywordSpan">versions</span>(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.processLoad" id="apidoc.module.systeminformation.processLoad">module systeminformation.processLoad</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.processLoad.processLoad" id="apidoc.element.systeminformation.processLoad.processLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>processLoad
        <span class="apidocSignatureSpan">(proc, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processLoad(proc, callback) {

  // fallback - if only callback is given
  if (util.isFunction(proc) &amp;&amp; !callback) {
    callback = proc;
    proc = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        'proc': proc,
        'pid': -1,
        'cpu': 0,
        'mem': 0
      };

      if (proc) {
        exec("ps aux | grep " + proc + " | grep -v grep", function (error, stdout) {
          if (!error) {
            let data = stdout.replace(/ +/g, " ").split(' ');

            if (data.length &gt; 2) {
              result = {
                'proc': proc,
                'pid': data[1],
                'cpu': parseFloat(data[2].replace(',', '.')),
                'mem': parseFloat(data[3].replace(',', '.'))
              }
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].priority | X | X |  | process priotity |
| - ...[0].mem_vsz | X | X |  | process virtual memory size |
| - ...[0].mem_rss | X | X |  | process mem resident set size |
| - ...[0].nice | X | X |  | process nice value |
| - ...[0].started | X | X |  | process start time |
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.<span class="apidocCodeKeywordSpan">processLoad</span>('apache2',cb) | X | X |  | detailed information about given
 process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.processes" id="apidoc.module.systeminformation.processes">module systeminformation.processes</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.processes.processes" id="apidoc.element.systeminformation.processes.processes">
        function <span class="apidocSignatureSpan">systeminformation.</span>processes
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processes(callback) {

  let parsedhead = [];

  function parseHead(head, rights) {
    let space = (rights &gt; 0);
    let count = 1;
    let from = 0;
    let to = 0;
    let result = [];
    for (let i = 0; i &lt; head.length; i++) {
      if (count &lt;= rights) {
        if (head[i] == ' ' &amp;&amp; !space) {
          to = i - 1;
          result.push({
            from: from,
            to: to + 1,
            cap: head.substring(from, to + 1)
          });
          from = to + 2;
          count++;
        }
        space = head[i] == ' ';
      } else {
        if (head[i] != ' ' &amp;&amp; space) {
          to = i - 1;
          if (from &lt; to) {
            result.push({
              from: from,
              to: to,
              cap: head.substring(from, to)
            });
          }
          from = to + 1;
          count++;
        }
        space = head[i] == ' ';
      }
    }
    to = 1000;
    result.push({
      from: from,
      to: to,
      cap: head.substring(from, to)
    });
    return result;

  }

  function parseLine(line) {
    let pid = parseInt(line.substring(parsedhead[0].from, parsedhead[0].to));
    let pcpu = parseFloat(line.substring(parsedhead[1].from, parsedhead[1].to).replace(/,/g, "."));
    let pmem = parseFloat(line.substring(parsedhead[2].from, parsedhead[2].to).replace(/,/g, "."));
    let priority = parseInt(line.substring(parsedhead[3].from, parsedhead[3].to));
    let vsz = parseInt(line.substring(parsedhead[4].from, parsedhead[4].to));
    let rss = parseInt(line.substring(parsedhead[5].from, parsedhead[5].to));
    let nice = parseInt(line.substring(parsedhead[6].from, parsedhead[6].to));
    let started = line.substring(parsedhead[7].from, parsedhead[7].to).trim();
    let state = line.substring(parsedhead[8].from, parsedhead[8].to).trim();
    state = (state[0] == 'R' ? 'running' : (state[0] == 'S' ? 'sleeping' : (state[0] == 'T' ? 'stopped' : (state[0] == 'W' ? 'paging
' : (state[0] == 'X' ? 'dead' : (state[0] == 'Z' ? 'zombie' : ((state[0] == 'D' || state[0] == 'U') ? 'blocked' : 'unknown')))))));
    let tty = line.substring(parsedhead[9].from, parsedhead[9].to).trim();
    if (tty == '?' || tty == '??') tty = '';
    let user = line.substring(parsedhead[10].from, parsedhead[10].to).trim();
    let command = line.substring(parsedhead[11].from, parsedhead[11].to).trim().replace(/\[/g, "").replace(/]/g, "");

    return ({
      pid: pid,
      pcpu: pcpu,
      pcpuu: 0,
      pcpus: 0,
      pmem: pmem,
      priority: priority,
      mem_vsz: vsz,
      mem_rss: rss,
      nice: nice,
      started: started,
      state: state,
      tty: tty,
      user: user,
      command: command
    })
  }

  function parseProcesses(lines) {
    let result = [];
    if (lines.length &gt; 1) {
      let head = lines[0];
      parsedhead = parseHead(head, 7);
      lines.shift();
      lines.forEach(function (line) {
        if (line.trim() != '') {
          result.push(parseLine(line));
        }
      });
    }
    return result;
  }

  function parseProcStat(line) {
    let parts = line.replace(/ +/g, " ").split(' ');
    let user = (parts.length &gt;= 2 ? parseInt(parts[1]) : 0);
    let nice = (parts.length &gt;= 3 ? parseInt(parts[2]) : 0);
    let system = (parts.length &gt;= 4 ? parseInt(parts[3]) : 0);
    let idle = (parts.length &gt;= 5 ? parseInt(parts[4]) : 0);
    let iowait = (parts.length &gt;= 6 ? parseInt(parts[5]) : 0);
    let irq = (parts.length &gt;= 7 ? parseInt(parts[6]) : 0);
    let softirq = (parts.length &gt;= 8 ? parseInt(parts[7]) : 0);
    let steal = (parts.length &gt;= 9 ? parseInt(parts[8]) : 0);
    let guest = (parts.length &gt;= 10 ? parseInt(parts[9]) : 0);
    let guest_nice = (parts.length &gt;= 11 ? parseInt(parts[10]) : 0);
    return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
  }

  function parseProcPidStat(line, all) {
    let statparts = line.replace(/ +/g, " ").split(')');
    if (statparts.length &gt;= 2) {
      let parts = statparts[1].split(' ');
      if (parts.length &gt;= 16) {
        let pid = parseInt(statparts[0].split(' ')[0]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.services('mysql, apache2', cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">processes</span>(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
| - blocked | X | X |  | # of all processes blocked |
| - sleeping | X | X |  | # of all processes sleeping |
| - list[] | X | X |  | list of all processes incl. details |
| - ...[0].pid | X | X |  | process PID |
| - ...[0].pcpu | X | X |  | process % CPU usage |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.services" id="apidoc.module.systeminformation.services">module systeminformation.services</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.services.services" id="apidoc.element.systeminformation.services.services">
        function <span class="apidocSignatureSpan">systeminformation.</span>services
        <span class="apidocSignatureSpan">(srv, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function services(srv, callback) {

  // fallback - if only callback is given
  if (util.isFunction(srv) &amp;&amp; !callback) {
    callback = srv;
    srv = '';
  }

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      srv = srv.trim().replace(/,+/g, " ").replace(/  +/g, " ").replace(/ +/g, "|");
      let srvs = srv.split('|');
      let comm = (_darwin) ? "ps -caxm -o pcpu,pmem,comm" : "ps axo pcpu,pmem,comm";
      let data = [];
      if (srv != '' &amp;&amp; srvs.length &gt; 0) {
        exec(comm + " | grep -v grep | egrep '" + srv + "'", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/ +/g, " ").replace(/,+/g, ".").split('\n');
            srvs.forEach(function (srv) {
              let ps = lines.filter(function (e) {
                return e.indexOf(srv) != -1
              });
              data.push({
                'name': srv,
                'running': ps.length &gt; 0,
                'pcpu': parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(' ')[0]);
                }, 0)).toFixed(2)),
                'pmem': parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(' ')[1]);
                }, 0)).toFixed(2))
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          } else {
            srvs.forEach(function (srv) {
              data.push({
                'name': srv,
                'running': false,
                'pcpu': 0,
                'pmem': 0
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          }
        });
      } else {
        if (callback) { callback(data) }
        resolve(data);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.<span class="apidocCodeKeywordSpan">services</span>('mysql, apache2', cb) | X | X |  | pass comma separated string
 of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.shell" id="apidoc.module.systeminformation.shell">module systeminformation.shell</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.shell.shell" id="apidoc.element.systeminformation.shell.shell">
        function <span class="apidocSignatureSpan">systeminformation.</span>shell
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shell(callback) {
  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = '';
      exec("echo $SHELL", function (error, stdout) {
        if (!error) {
          result = stdout.toString().split('\n')[0];
        }
        if (callback) {
          callback(result)
        }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. 'apple', 'debian', 'fedora', ... |
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.<span class="apidocCodeKeywordSpan">shell</span>(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.system" id="apidoc.module.systeminformation.system">module systeminformation.system</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.system.system" id="apidoc.element.systeminformation.system.system">
        function <span class="apidocSignatureSpan">systeminformation.</span>system
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">system = function (callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {

      let result = {
        manufacturer: '',
        model: 'Computer',
        version: '',
        serial: '-',
        uuid: '-'
      };

      if (_linux) {
        exec("dmidecode -t system", function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split('\n');
            lines.forEach(function (line) {
              if (line.indexOf(':') != -1) {
                if (line.toLowerCase().indexOf('manufacturer') != -1) result.manufacturer = result.manufacturer || line.split(':')[
1].trim();
                if (line.toLowerCase().indexOf('product name') != -1) result.model = line.split(':')[1].trim();
                if (line.toLowerCase().indexOf('version') != -1) result.version = result.version || line.split(':')[1].trim();
                if (line.toLowerCase().indexOf('serial number') != -1) result.serial = line.split(':')[1].trim();
                if (line.toLowerCase().indexOf('uuid') != -1) result.uuid = line.split(':')[1].trim();
              }
            });
            if (result.serial.toLowerCase().indexOf('o.e.m.') != -1) result.serial = '-';
            if (result.manufacturer.toLowerCase().indexOf('o.e.m.') != -1) result.manufacturer = '';
            if (result.model.toLowerCase().indexOf('o.e.m.') != -1) result.model = 'Computer';
            if (result.version.toLowerCase().indexOf('o.e.m.') != -1) result.version = '-';

            if (result.manufacturer == '' &amp;&amp; result.model == 'Computer' &amp;&amp; result.version == '-') {
              // Check Raspberry Pi
              exec("grep Hardware /proc/cpuinfo; grep Serial /proc/cpuinfo; grep Revision /proc/cpuinfo", function (error, stdout
) {
                if (!error) {
                  let lines = stdout.toString().split('\n');
                  lines.forEach(function (line) {
                    if (line.indexOf(':') != -1) {
                      if (line.toLowerCase().indexOf('hardware') != -1) result.model = line.split(':')[1].trim();
                      if (line.toLowerCase().indexOf('revision') != -1) result.version = line.split(':')[1].trim();
                      if (line.toLowerCase().indexOf('serial') != -1) result.serial = line.split(':')[1].trim();
                    }
                  });
                  if (result.model == 'BCM2709') {
                    result.manufacturer = 'Raspberry Pi Foundation';
                    result.model = result.model + ' - Pi 2 Model B';
                    if (['a01041', 'a21041'].indexOf(result.version) &gt;= 0) {
                      result.version = result.version + ' - Rev. 1.1'
                    }
                  }
                  if (result.model == 'BCM2708') {
                    result.manufacturer = 'Raspberry Pi Foundation';
                    if (['0002', '0003'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model B';
                      result.version = result.version + ' - Rev 1.0';
                    }
                    if (['0007', '0008', '0009'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model A';
                      result.version = result.version + ' - Rev 2.0';
                    }
                    if (['0004', '0005', '0006', '000d', '000e', '000f'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model B';
                      result.version = result.version + ' - Rev 2.0';
                    }
                    if (['0012'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model A+';
                      result.version = result.version + ' - Rev 1.0';
                    }
                    if (['0010'].indexOf(result.version) &gt;= 0) {
                      result.model = result.model + ' - Pi Model B+';
                      result.version = result.version + ' - Rev 1.0';
                    }
                    if (['0013'].indexOf(result.ver ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.time() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.<span class="apidocCodeKeywordSpan">system</span>(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.osInfo(cb) | X | X | X | OS information |
| - platform   | X | X | X | 'Linux', 'Darwin', 'Windows' |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.time" id="apidoc.module.systeminformation.time">module systeminformation.time</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.time.time" id="apidoc.element.systeminformation.time.time">
        function <span class="apidocSignatureSpan">systeminformation.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time() {
  return {
    current: Date.now(),
    uptime: os.uptime()
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.<span class="apidocCodeKeywordSpan">time</span>() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
| - serial | X | X | X | serial number |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.users" id="apidoc.module.systeminformation.users">module systeminformation.users</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.users.users" id="apidoc.element.systeminformation.users.users">
        function <span class="apidocSignatureSpan">systeminformation.</span>users
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function users(callback) {

  return new Promise((resolve, reject) =&gt; {
    process.nextTick(() =&gt; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];

      // linux
      if (_linux) {
        exec("who --ips; echo '---'; w | tail -n +2", function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split('\n');
            result = parseUsers1(lines);
            if (result.length == 0) {
              exec("who; echo '---'; w | tail -n +2", function (error, stdout) {
                if (!error) {
                  // lines / split
                  lines = stdout.toString().split('\n');
                  result = parseUsers1(lines);
                  if (callback) { callback(result) }
                  resolve(result);
                } else {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
            } else {
              if (callback) { callback(result) }
              resolve(result);
            }
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

      if (_darwin) {
        exec("who; echo '---'; w -ih", function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split('\n');
            result = parseUsers2(lines);

            if (callback) { callback(result) }
            resolve(result);
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.processLoad('apache2',cb) | X | X |  | detailed information about given process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">users</span>(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.util" id="apidoc.module.systeminformation.util">module systeminformation.util</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.util.cores" id="apidoc.element.systeminformation.util.cores">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>cores
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cores() {
  if (_cores == 0) {
    _cores = os.cpus().length;
  }
  return _cores;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return new Promise((resolve) =&gt; {
process.nextTick(() =&gt; {
  let result = {
    manufacturer: 'unknown',
    brand: 'unknown',
    speed: '0.00',
    cores: util.<span class="apidocCodeKeywordSpan">cores</span>()
  };
  if (_darwin) {
    exec("sysctl -n machdep.cpu.brand_string", function (error, stdout) {
      if (!error) {
        let lines = stdout.toString().split('\n');
        result.brand = lines[0].split('@')[0].trim();
        result.speed = lines[0].split('@')[1].trim();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.util.isFunction" id="apidoc.element.systeminformation.util.isFunction">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>isFunction
        <span class="apidocSignatureSpan">(functionToCheck)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(functionToCheck) {
  let getType = {};
  return functionToCheck &amp;&amp; getType.toString.call(functionToCheck) === '[object Function]';
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    return (obj.Id &amp;&amp; (obj.Id == id))
  });
  return (filtered.length &gt; 0);
}

// fallback - if only callback is given
if (util.<span class="apidocCodeKeywordSpan">isFunction</span>(all) &amp;&amp; !callback) {
  callback = all;
  all = false;
}

all = all || false;
let result = [];
return new Promise((resolve, reject) =&gt; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.util.sortByKey" id="apidoc.element.systeminformation.util.sortByKey">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>sortByKey
        <span class="apidocSignatureSpan">(array, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortByKey(array, keys) {
  return array.sort(function(a, b) {
    let x ='';
    let y ='';
    keys.forEach(function (key) {
      x = x + a[key]; y = y + b[key];
    });
    return ((x &lt; y) ? -1 : ((x &gt; y) ? 1 : 0));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'serial': disk.serial,
    'removable': disk.rm == '1',
    'protocol': disk.tran
  })
});

data = util.unique(data);
data = util.<span class="apidocCodeKeywordSpan">sortByKey</span>(data, ['type', 'name']);
return data;
}

function blkStdoutToObject(stdout) {
return stdout.toString()
  .replace(/NAME=/g, '{"name":')
  .replace(/FSTYPE=/g, ',"fstype":')
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.util.unique" id="apidoc.element.systeminformation.util.unique">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>unique
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unique(obj){
  let uniques=[];
  let stringify={};
  for(let i=0;i&lt;obj.length;i++){
    let keys=Object.keys(obj[i]);
    keys.sort(function(a,b) {return a-b});
    let str='';
    for(let j=0;j&lt;keys.length;j++){
      str+= JSON.stringify(keys[j]);
      str+= JSON.stringify(obj[i][keys[j]]);
    }
    if(!stringify.hasOwnProperty(str)){
      uniques.push(obj[i]);
      stringify[str]=true;
    }
  }
  return uniques;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    'model': disk.model,
    'serial': disk.serial,
    'removable': disk.rm == '1',
    'protocol': disk.tran
  })
});

data = util.<span class="apidocCodeKeywordSpan">unique</span>(data);
data = util.sortByKey(data, ['type', 'name']);
return data;
}

function blkStdoutToObject(stdout) {
return stdout.toString()
  .replace(/NAME=/g, '{"name":')
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.version" id="apidoc.module.systeminformation.version">module systeminformation.version</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.version.version" id="apidoc.element.systeminformation.version.version">
        function <span class="apidocSignatureSpan">systeminformation.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function version() {
  return lib_version;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
11. Docker
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.<span class="apidocCodeKeywordSpan">version</span>() | X | X | X | library version (no callback/promise) |
| si.time() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. 'MSI' |
| - model | X | X | X | model/product e.g. 'MS-7823' |
| - version | X | X | X | version e.g. '1.0' |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.versions" id="apidoc.module.systeminformation.versions">module systeminformation.versions</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.versions.versions" id="apidoc.element.systeminformation.versions.versions">
        function <span class="apidocSignatureSpan">systeminformation.</span>versions
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function versions(callback) {
  return new Promise((resolve) =&gt; {
    process.nextTick(() =&gt; {
      let result = {
        kernel: os.release(),
        node: process.versions.node,
        v8: process.versions.v8,
        npm: '',
        pm2: '',
        openssl: process.versions.openssl
      };
      let lines = [];
      exec("npm -v", function (error, stdout) {
        if (!error) {
          result.npm = stdout.toString().split('\n')[0];
        }
        exec("pm2 -v", function (error, stdout) {
          if (!error) {
            lines = stdout.toString().split('\n');
            if (lines.length &gt;= 2) {
              result.pm2 = lines[lines.length - 2];
            }
          }
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. 'apple', 'debian', 'fedora', ... |
| si.<span class="apidocCodeKeywordSpan">versions</span>(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. 'Intel(R)' |
| - brand | X | X | X | e.g. 'Core(TM)2 Duo' |
| - speed | X | X | X | in GHz e.g. '3.40' |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>