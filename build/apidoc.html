<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/sebhildebrandt/systeminformation"

    >systeminformation (v3.17.0)</a>
</h1>
<h4>Simple system and OS information library</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation">module systeminformation</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.battery">
            function <span class="apidocSignatureSpan">systeminformation.</span>battery
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.blockDevices">
            function <span class="apidocSignatureSpan">systeminformation.</span>blockDevices
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpu
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuCache">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuCache
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuCurrentspeed">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuCurrentspeed
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuFlags">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuFlags
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpuTemperature">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpuTemperature
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.currentLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>currentLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.disksIO">
            function <span class="apidocSignatureSpan">systeminformation.</span>disksIO
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerAll">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerAll
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainerProcesses">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerProcesses
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainerStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerStats
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.dockerContainers">
            function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainers
            <span class="apidocSignatureSpan">(all, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fsSize">
            function <span class="apidocSignatureSpan">systeminformation.</span>fsSize
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fsStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>fsStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.fullLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>fullLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getAllData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getAllData
            <span class="apidocSignatureSpan">(srv, iface, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getDynamicData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getDynamicData
            <span class="apidocSignatureSpan">(srv, iface, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.getStaticData">
            function <span class="apidocSignatureSpan">systeminformation.</span>getStaticData
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.graphics">
            function <span class="apidocSignatureSpan">systeminformation.</span>graphics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.inetChecksite">
            function <span class="apidocSignatureSpan">systeminformation.</span>inetChecksite
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.inetLatency">
            function <span class="apidocSignatureSpan">systeminformation.</span>inetLatency
            <span class="apidocSignatureSpan">(host, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.mem">
            function <span class="apidocSignatureSpan">systeminformation.</span>mem
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkConnections">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkConnections
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkInterfaceDefault">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaceDefault
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkInterfaces">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaces
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.networkStats">
            function <span class="apidocSignatureSpan">systeminformation.</span>networkStats
            <span class="apidocSignatureSpan">(iface, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osInfo">
            function <span class="apidocSignatureSpan">systeminformation.</span>osInfo
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processLoad">
            function <span class="apidocSignatureSpan">systeminformation.</span>processLoad
            <span class="apidocSignatureSpan">(proc, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processes">
            function <span class="apidocSignatureSpan">systeminformation.</span>processes
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.services">
            function <span class="apidocSignatureSpan">systeminformation.</span>services
            <span class="apidocSignatureSpan">(srv, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.shell">
            function <span class="apidocSignatureSpan">systeminformation.</span>shell
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.system">
            function <span class="apidocSignatureSpan">systeminformation.</span>system
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.time">
            function <span class="apidocSignatureSpan">systeminformation.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.users">
            function <span class="apidocSignatureSpan">systeminformation.</span>users
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.version">
            function <span class="apidocSignatureSpan">systeminformation.</span>version
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.versions">
            function <span class="apidocSignatureSpan">systeminformation.</span>versions
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>docker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>filesystem</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>internet</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>network</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>osinfo</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">systeminformation.</span>util</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.cpu">module systeminformation.cpu</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.cpu">
            function <span class="apidocSignatureSpan">systeminformation.</span>cpu
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.cpuCache">
            function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuCache
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.cpuCurrentspeed">
            function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuCurrentspeed
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.cpuFlags">
            function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuFlags
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.cpuTemperature">
            function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuTemperature
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.currentLoad">
            function <span class="apidocSignatureSpan">systeminformation.cpu.</span>currentLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.cpu.fullLoad">
            function <span class="apidocSignatureSpan">systeminformation.cpu.</span>fullLoad
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.docker">module systeminformation.docker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerAll">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerAll
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerContainerProcesses">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerProcesses
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerContainerStats">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerStats
            <span class="apidocSignatureSpan">(containerID, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.docker.dockerContainers">
            function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainers
            <span class="apidocSignatureSpan">(all, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.filesystem">module systeminformation.filesystem</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.blockDevices">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>blockDevices
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.disksIO">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>disksIO
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.fsSize">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsSize
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.filesystem.fsStats">
            function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsStats
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.graphics">module systeminformation.graphics</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.graphics.graphics">
            function <span class="apidocSignatureSpan">systeminformation.</span>graphics
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.internet">module systeminformation.internet</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.internet.inetChecksite">
            function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetChecksite
            <span class="apidocSignatureSpan">(url, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.internet.inetLatency">
            function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetLatency
            <span class="apidocSignatureSpan">(host, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.network">module systeminformation.network</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.getDefaultNetworkInterface">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>getDefaultNetworkInterface
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkConnections">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkConnections
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkInterfaceDefault">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaceDefault
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkInterfaces">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaces
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.network.networkStats">
            function <span class="apidocSignatureSpan">systeminformation.network.</span>networkStats
            <span class="apidocSignatureSpan">(iface, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.osinfo">module systeminformation.osinfo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.osInfo">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>osInfo
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.shell">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>shell
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.time">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>time
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.osinfo.versions">
            function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>versions
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.processes">module systeminformation.processes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processes.processes">
            function <span class="apidocSignatureSpan">systeminformation.</span>processes
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processes.processLoad">
            function <span class="apidocSignatureSpan">systeminformation.processes.</span>processLoad
            <span class="apidocSignatureSpan">(proc, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.processes.services">
            function <span class="apidocSignatureSpan">systeminformation.processes.</span>services
            <span class="apidocSignatureSpan">(srv, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.users">module systeminformation.users</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.users.users">
            function <span class="apidocSignatureSpan">systeminformation.</span>users
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.systeminformation.util">module systeminformation.util</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.cores">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>cores
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.isFunction">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>isFunction
            <span class="apidocSignatureSpan">(functionToCheck)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.sortByKey">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>sortByKey
            <span class="apidocSignatureSpan">(array, keys)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.systeminformation.util.unique">
            function <span class="apidocSignatureSpan">systeminformation.util.</span>unique
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation" id="apidoc.module.systeminformation">module systeminformation</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.battery" id="apidoc.element.systeminformation.battery">
        function <span class="apidocSignatureSpan">systeminformation.</span>battery
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">battery = function (callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        hasbattery: false,
        cyclecount: 0,
        ischarging: false,
        maxcapacity: 0,
        currentcapacity: 0,
        percent: 0
      };

      if (_linux) {
        let battery_path = &#x27;&#x27;;
        if (fs.existsSync(&#x27;/sys/class/power_supply/BAT1/status&#x27;)) {
          battery_path = &#x27;/sys/class/power_supply/BAT1/&#x27;
        } else if (fs.existsSync(&#x27;/sys/class/power_supply/BAT0/status&#x27;)) {
          battery_path = &#x27;/sys/class/power_supply/BAT0/&#x27;
        }
        if (battery_path) {
          exec(&#x22;cat &#x22; + battery_path + &#x22;status&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              if (lines.length &#x3e; 0 &#x26;&#x26; lines[0]) result.ischarging = (lines[0].trim().toLowerCase() == &#x27;charging&#x27;)
            }
            exec(&#x22;cat &#x22; + battery_path + &#x22;cyclec_ount&#x22;, function (error, stdout) {
              if (!error) {
                let lines = stdout.toString().split(&#x27;\n&#x27;);
                if (lines.length &#x3e; 0 &#x26;&#x26; lines[0]) result.cyclecount = parseFloat(lines[0].trim());
              }
              exec(&#x22;cat &#x22; + battery_path + &#x22;charge_full&#x22;, function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split(&#x27;\n&#x27;);
                  if (lines.length &#x3e; 0 &#x26;&#x26; lines[0]) result.maxcapacity = parseFloat(lines[0].trim());
                }
                exec(&#x22;cat &#x22; + battery_path + &#x22;charge_now&#x22;, function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split(&#x27;\n&#x27;);
                    if (lines.length &#x3e; 0 &#x26;&#x26; lines[0]) result.currentcapacity = parseFloat(lines[0].trim());
                  }
                  if (result.maxcapacity &#x26;&#x26; result.currentcapacity) {
                    result.hasbattery = true;
                    result.percent = 100.0 * result.currentcapacity / result.maxcapacity;
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                })
              })
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      }
      if (_darwin) {
        exec(&#x22;ioreg -n AppleSmartBattery -r | grep &#x27;\&#x22;CycleCount\&#x22;&#x27;;ioreg -n AppleSmartBattery -r | grep &#x27;\&#x22;IsCharging\&#x22;&#x27;;ioreg -
n AppleSmartBattery -r | grep &#x27;\&#x22;MaxCapacity\&#x22;&#x27;;ioreg -n AppleSmartBattery -r | grep &#x27;\&#x22;CurrentCapacity\&#x22;&#x27;&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/ +/g, &#x22;&#x22;).replace(/&#x22;+/g, &#x22;&#x22;).split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              if (line.indexOf(&#x27;=&#x27;) != -1) {
                if (line.toLowerCase().indexOf(&#x27;cyclecount&#x27;) != -1) result.cyclecount = parseFloat(line.split(&#x27;=&#x27;)[1].trim());
                if (line.toLowerCase().indexOf(&#x27;ischarging&#x27;) != -1) result.ischarging = (line.split(&#x27;=&#x27;)[1].trim().toLowerCase() == &#x27;
yes&#x27;);
                if (line.toLowerCase().indexOf(&#x27;maxcapacity&#x27;) != -1) result.maxcapacity = parseFloat(line.split(&#x27;=&#x27;)[1].trim());
                if (line.toLowerCase().indexOf(&#x27;currentcapacity&#x27;) != -1) result.currentcapacity = parseFloat(line.split(&#x27;=&#x27;)[1].
trim());
              }
            });
          }
          if (result.maxcapacity &#x26;&#x26; result.currentcapacity) {
            result.hasbattery = true;
            result.percent = 100.0 * result.currentcapacity / result.maxcapacity;
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - used | X | X | X | used (incl. buffers/cache) |
| - active | X | X | X | used actively (excl. buffers/cache)  |
| - buffcache | X | X |  | used by buffers+cache |
| - available | X | X | X | potentially available (total - active) |
| - swaptotal | X | X |  |  |
| - swapused | X | X |  |  |
| - swapfree | X | X |  |  |
| si.<span class="apidocCodeKeywordSpan">battery</span>(cb) | X | X |  | battery information |
| - hasbattery | X | X |  | indicates presence of battery |
| - ischarging | X | X |  | indicates if battery is charging |
| - maxcapacity | X | X |  | max capacity of battery |
| - currentcapacity | X | X |  | current capacity of battery |
| - percent | X | X |  | charging level in percent |
| si.graphics(cb) | X | X |  | arrays of graphics controllers and displays |
| - controllers[0].model | X | X |  | graphics controller model |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.blockDevices" id="apidoc.element.systeminformation.blockDevices">
        function <span class="apidocSignatureSpan">systeminformation.</span>blockDevices
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function blockDevices(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_linux) {
        // see https://wiki.ubuntuusers.de/lsblk/
        // exec(&#x22;lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-
IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME&#x22;, function (error, stdout) {
        exec(&#x22;lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER&#x22;, function (error, stdout
) {
          let data = [];
          if (!error) {
            let lines = blkStdoutToObject(stdout).split(&#x27;\n&#x27;);
            data = parseBlk(lines);
            if (callback) {
              callback(data)
            }
            resolve(data);
          } else {
            exec(&#x22;lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER&#x22;, function (error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split(&#x27;\n&#x27;);
                data = parseBlk(lines);
              }
              if (callback) {
                callback(data)
              }
              resolve(data);
            });
          }
        });
      }
      if (_darwin) {
        exec(&#x22;diskutil info -all&#x22;, function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            // parse lines into temp array of devices
            data = parseDevices(lines);
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec(&#x27;wmic logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber
 /format:csv&#x27;, function (error, stdout) {
          if (!error) {
            let lines = stdout.split(&#x27;\r\n&#x27;).filter(line =&#x3e; line.trim() != &#x27;&#x27;).filter((line, idx) =&#x3e; idx &#x3e; 0);
            lines.forEach(function (line) {
              if (line != &#x27;&#x27;) {
                line = line.replace(&#x27;\r&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;);
                data.push({
                  name: line[7],
                  identifier: line[1],
                  type: &#x27;disk&#x27;,
                  fstype: line[5].toLowerCase(),
                  mount: line[1],
                  size: line[8],
                  physical: line[4] == &#x27;5&#x27; ? &#x27;CD/DVD&#x27; : &#x27;HDD&#x27;,
                  uuid: line[10],
                  label: line[9],
                  model: &#x27;&#x27;,
                  serial: line[10],
                  removable: line[4] == &#x27;2&#x27;,
                  protocol: &#x27;&#x27;
                });
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.fsSize(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.<span class="apidocCodeKeywordSpan">blockDevices</span>(cb) | X | X | X | returns array of disks, partitions,&#x3c;br&#x3e;
raids and roms |
| - [0].name | X | X | X | name |
| - [0].type | X | X | X | type |
| - [0].fstype | X | X | X | file system type (e.g. ext4) |
| - [0].mount | X | X | X | mount point |
| - [0].size | X | X | X | size in bytes |
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu" id="apidoc.element.systeminformation.cpu">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpu
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpu(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      getCpu().then(result =&#x3e; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

All functions (except `version` and `time`) are implemented as asynchronous functions. Here a small example how to use them:

```
var si = require(&#x27;systeminformation&#x27;);

// callback style
si.<span class="apidocCodeKeywordSpan">cpu</span>(function(data) {
	console.log(&#x27;CPU-Information:&#x27;);
	console.log(data);
})

// promises style - new in version 3
si.cpu()
	.then(data =&#x3e; console.log(data))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuCache" id="apidoc.element.systeminformation.cpuCache">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuCache
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCache(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {};
      if (_linux) {
        exec(&#x22;lscpu&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              let parts = line.split(&#x27;:&#x27;);
              if (parts[0].toUpperCase().indexOf(&#x27;L1D CACHE&#x27;) != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf(&#x27;L1I CACHE&#x27;) != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf(&#x27;L2 CACHE&#x27;) != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf(&#x27;L3 CACHE&#x27;) != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec(&#x22;sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              let parts = line.split(&#x27;:&#x27;);
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l1icachesize&#x27;) != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l1dcachesize&#x27;) != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l2cachesize&#x27;) != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l3cachesize&#x27;) != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.<span class="apidocCodeKeywordSpan">cpuCache</span>(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuCurrentspeed" id="apidoc.element.systeminformation.cpuCurrentspeed">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuCurrentspeed
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCurrentspeed(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = getCpuCurrentSpeedSync();
      if (result == 0 &#x26;&#x26; _cpu_speed != &#x27;0.00&#x27;) result = parseFloat(_cpu_speed);

      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.<span class="apidocCodeKeywordSpan">cpuCurrentspeed</span>(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.cpuTemperature(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuFlags" id="apidoc.element.systeminformation.cpuFlags">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuFlags
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuFlags(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = &#x27;&#x27;;
      if (_linux) {
        exec(&#x22;lscpu&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              if (line.split(&#x27;:&#x27;)[0].toUpperCase().indexOf(&#x27;FLAGS&#x27;) != -1) {
                result = line.split(&#x27;:&#x27;)[1].trim().toLowerCase();
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec(&#x22;sysctl machdep.cpu.features&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            if (lines.length &#x3e; 0 &#x26;&#x26; lines[0].indexOf(&#x27;machdep.cpu.features:&#x27;) != -1) {
              result = lines[0].split(&#x27;:&#x27;)[1].trim().toLowerCase();
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.<span class="apidocCodeKeywordSpan">cpuFlags</span>(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpuTemperature" id="apidoc.element.systeminformation.cpuTemperature">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpuTemperature
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuTemperature(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = {
        main: -1.0,
        cores: [],
        max: -1.0
      };
      if (_linux) {
        exec(&#x22;sensors&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              let regex = /\+([^Â°]*)/g;
              let temps = line.match(regex);
              if (line.split(&#x27;:&#x27;)[0].toUpperCase().indexOf(&#x27;PHYSICAL&#x27;) != -1) {
                result.main = parseFloat(temps);
              }
              if (line.split(&#x27;:&#x27;)[0].toUpperCase().indexOf(&#x27;CORE &#x27;) != -1) {
                result.cores.push(parseFloat(temps));
              }
            });
            if (result.cores.length &#x3e; 0) {
              let maxtmp = Math.max.apply(Math, result.cores);
              result.max = (maxtmp &#x3e; result.main) ? maxtmp : result.main;
            }
            if (callback) { callback(result) }
            resolve(result);
          } else {
            fs.stat(&#x27;/sys/class/thermal/thermal_zone0/temp&#x27;, function(err, stat) {
              if(err == null) {
                exec(&#x22;cat /sys/class/thermal/thermal_zone0/temp&#x22;, function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split(&#x27;\n&#x27;);
                    if (lines.length &#x3e; 0) {
                      result.main = parseFloat(lines[0]) / 1000.0;
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              } else {
                exec(&#x22;/opt/vc/bin/vcgencmd measure_temp&#x22;, function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split(&#x27;\n&#x27;);
                    if (lines.length &#x3e; 0 &#x26;&#x26; lines[0].indexOf(&#x27;=&#x27;)) {
                      result.main = parseFloat(lines[0].split(&#x22;=&#x22;)[1]);
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              }
            });

          }
        });
      }
      if (_darwin) {
        let smc = require(&#x27;../build/Release/smc&#x27;);

        let cores = [&#x27;TC0P&#x27;, &#x27;TC1C&#x27;, &#x27;TC2C&#x27;, &#x27;TC3C&#x27;, &#x27;TC4C&#x27;, &#x27;TC5C&#x27;, &#x27;TC6C&#x27;, &#x27;TC7C&#x27;, &#x27;TC8C&#x27;];
        let sum = 0;
        let id = 0;
        cores.forEach(function(key) {
          let value = smc.get(key);
          if (id == 0) {
            if (value &#x3e; 0) {
              result.main = value;
              result.max = value;
            }
            id = 1;
          } else {
            if (value &#x3e; 0) {
              result.cores.push(value);
              sum = sum + value;
              if (value &#x3e; result.max) result.max = value;
            }
          }
        });
        if (result.cores.length) {
          result.main = sum / result.cores.length;
        }

        if (callback) { callback(result) }
        resolve(result);
      }
      if (_windows) {
        exec(&#x22;wmic /namespace:\\\\root\\wmi PATH MSAcpi_ThermalZoneTemperature get CriticalTripPoint,CurrentTemperature /value&#x22;,
function (error, stdout) {
          if (!error) {
            let sum = 0;
            let lines = stdout.trim().split(/\s\s+/);
            lines.forEach(function (line) {
              if (line.match(&#x27;CriticalTripPoint&#x27;) &#x26;&#x26; !result.max)
                result.max = (parseInt(line.split(&#x27;CriticalTripPoint=&#x27;)[1]) - 2732) / 10;
              else if (line.match(&#x27;CurrentTemperature&#x27;)) {
                let value = (parseInt(line.split(&#x27;CurrentTemperature=&#x27;)[1]) - 2732) / 10;
                sum = sum + value;
                result.cores.push(value);
              }
            });
            if (result.cores.length) {
              result.main = sum / result.cores.length;
            }
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.<span class="apidocCodeKeywordSpan">cpuTemperature</span>(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
| si.mem(cb) | X | X | X | Memory information|
| - total | X | X | X | total memory |
| - free | X | X | X | not used |
| - used | X | X | X | used (incl. buffers/cache) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.currentLoad" id="apidoc.element.systeminformation.currentLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>currentLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function currentLoad(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      getLoad().then(result =&#x3e; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkConnections(cb) | X | X |  | current network network connections&#x3c;br&#x3e;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.<span class="apidocCodeKeywordSpan">currentLoad</span>(cb) | X | X |  | CPU-Load |
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.disksIO" id="apidoc.element.systeminformation.disksIO">
        function <span class="apidocSignatureSpan">systeminformation.</span>disksIO
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disksIO(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: -1,
        wIO_sec: -1,
        tIO_sec: -1,
        ms: 0
      };
      let rIO = 0;
      let wIO = 0;

      if ((_disk_io &#x26;&#x26; !_disk_io.ms) || (_disk_io &#x26;&#x26; _disk_io.ms &#x26;&#x26; Date.now() - _disk_io.ms &#x3e;= 500)) {
        if (_linux) {
          // prints Block layer statistics for all mounted volumes
          // var cmd = &#x22;for mount in `lsblk | grep / | sed -r &#x27;s/â ââ//&#x27; | cut -d &#x27; &#x27; -f 1`; do cat /sys/block/$mount/stat | sed
 -r &#x27;s/ +/;/g&#x27; | sed -r &#x27;s/^;//&#x27;; done&#x22;;
          // var cmd = &#x22;for mount in `lsblk | grep / | sed &#x27;s/[ââââ]//g&#x27; | awk &#x27;{$1=$1};1&#x27; | cut -d &#x27; &#x27; -f 1 | sort -u`; do cat /
sys/block/$mount/stat | sed -r &#x27;s/ +/;/g&#x27; | sed -r &#x27;s/^;//&#x27;; done&#x22;;
          let cmd = &#x22;for mount in `lsblk | grep &#x27; disk &#x27; | sed &#x27;s/[ââââ]//g&#x27; | awk &#x27;{$1=$1};1&#x27; | cut -d &#x27; &#x27; -f 1 | sort -u`; do
cat /sys/block/$mount/stat | sed -r &#x27;s/ +/;/g&#x27; | sed -r &#x27;s/^;//&#x27;; done&#x22;;

          exec(cmd, function (error, stdout) {
            if (!error) {
              let lines = stdout.split(&#x27;\n&#x27;);
              lines.forEach(function (line) {
                // ignore empty lines
                if (!line) return;

                // sum r/wIO of all disks to compute all disks IO
                let stats = line.split(&#x27;;&#x27;);
                rIO += parseInt(stats[0]);
                wIO += parseInt(stats[4]);
              });
              result = calcDiskIO(rIO, wIO);

              if (callback) {
                callback(result)
              }
              resolve(result);
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          });
        }
        if (_darwin) {
          exec(&#x22;ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n &#x27;/IOBlockStorageDriver/,/Statistics/p&#x27; | grep &#x27;Statistics
&#x27; | tr -cd &#x27;01234567890,\n&#x27; | awk -F&#x27;,&#x27; &#x27;{print $1, $11}&#x27;&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              lines.forEach(function (line) {
                line = line.trim();
                if (line != &#x27;&#x27;) {
                  line = line.split(&#x27; &#x27;);

                  rIO += parseInt(line[1]);
                  wIO += parseInt(line[0]);
                }
              });
              result = calcDiskIO(rIO, wIO);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.rIO = _disk_io.rIO;
        result.wIO = _disk_io.wIO;
        result.tIO = _disk_io.rIO + _disk_io.wIO;
        result.ms = _disk_io.last_ms;
        result.rIO_sec = _disk_io.rIO_sec;
        result.wIO_sec = _disk_io.wIO_sec;
        result.tIO_sec = _disk_io.tIO_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">disksIO</span>(cb) | X | X |  | current transfer stats |
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerAll" id="apidoc.element.systeminformation.dockerAll">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerAll
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerAll(callback) {
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      dockerContainers(true).then(result =&#x3e; {
        if (result &#x26;&#x26; Object.prototype.toString.call(result) === &#x27;[object Array]&#x27; &#x26;&#x26; result.length &#x3e; 0) {
          let l = result.length;
          result.forEach(function (element) {
            dockerContainerStats(element.id).then(res =&#x3e; {
              // include stats in array
              element.mem_usage = res.mem_usage;
              element.mem_limit = res.mem_limit;
              element.mem_percent = res.mem_percent;
              element.cpu_percent = res.cpu_percent;
              element.pids = res.pids;
              element.netIO = res.netIO;
              element.blockIO = res.blockIO;
              element.cpu_stats = res.cpu_stats;
              element.precpu_stats = res.precpu_stats;
              element.memory_stats = res.memory_stats;
              element.networks = res.networks;

              dockerContainerProcesses(element.id).then(processes =&#x3e; {
                element.processes = processes;

                l -= 1;
                if (l == 0) {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
              // all done??
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].stat | X | X |  | process state |
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.<span class="apidocCodeKeywordSpan">dockerAll</span>(cb) | X | X |  | list of all containers including their stats&#x3c;br&#
x3e;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainerProcesses" id="apidoc.element.systeminformation.dockerContainerProcesses">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerProcesses
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerProcesses(containerID, callback) {
  containerID = containerID || &#x27;&#x27;;
  let result = [];
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getProcesses(containerID, data =&#x3e; {
<span class="apidocCodeCommentSpan">          /**
           * @namespace
           * @property {Array}  Titles
           * @property {Array}  Processes
           **/
</span>           try {
            if (data &#x26;&#x26; data.Titles &#x26;&#x26; data.Processes) {
              let titles = data.Titles.map(function(value) {
                return value.toUpperCase();
              });
              let pos_pid = titles.indexOf(&#x27;PID&#x27;);
              let pos_ppid = titles.indexOf(&#x27;PPID&#x27;);
              let pos_pgid = titles.indexOf(&#x27;PGID&#x27;);
              let pos_vsz = titles.indexOf(&#x27;VSZ&#x27;);
              let pos_time = titles.indexOf(&#x27;TIME&#x27;);
              let pos_elapsed = titles.indexOf(&#x27;ELAPSED&#x27;);
              let pos_ni = titles.indexOf(&#x27;NI&#x27;);
              let pos_ruser = titles.indexOf(&#x27;RUSER&#x27;);
              let pos_user = titles.indexOf(&#x27;USER&#x27;);
              let pos_rgroup = titles.indexOf(&#x27;RGROUP&#x27;);
              let pos_group = titles.indexOf(&#x27;GROUP&#x27;);
              let pos_stat = titles.indexOf(&#x27;STAT&#x27;);
              let pos_rss = titles.indexOf(&#x27;RSS&#x27;);
              let pos_command = titles.indexOf(&#x27;COMMAND&#x27;);

              data.Processes.forEach(process =&#x3e; {
                result.push({
                  pid_host: (pos_pid &#x3e;= 0 ? process[pos_pid] : &#x27;&#x27;),
                  ppid: (pos_ppid &#x3e;= 0 ? process[pos_ppid] : &#x27;&#x27;),
                  pgid: (pos_pgid &#x3e;= 0 ? process[pos_pgid] : &#x27;&#x27;),
                  user: (pos_user &#x3e;= 0 ? process[pos_user] : &#x27;&#x27;),
                  ruser: (pos_ruser &#x3e;= 0 ? process[pos_ruser] : &#x27;&#x27;),
                  group: (pos_group &#x3e;= 0 ? process[pos_group] : &#x27;&#x27;),
                  rgroup: (pos_rgroup &#x3e;= 0 ? process[pos_rgroup] : &#x27;&#x27;),
                  stat: (pos_stat &#x3e;= 0 ? process[pos_stat] : &#x27;&#x27;),
                  time: (pos_time &#x3e;= 0 ? process[pos_time] : &#x27;&#x27;),
                  elapsed: (pos_elapsed &#x3e;= 0 ? process[pos_elapsed] : &#x27;&#x27;),
                  nice: (pos_ni &#x3e;= 0 ? process[pos_ni] : &#x27;&#x27;),
                  rss: (pos_rss &#x3e;= 0 ? process[pos_rss] : &#x27;&#x27;),
                  vsz: (pos_vsz &#x3e;= 0 ? process[pos_vsz] : &#x27;&#x27;),
                  command: (pos_command &#x3e;= 0 ? process[pos_command] : &#x27;&#x27;)
                })
              })
            }
          } catch (err) {
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - netIO.wx | X | X |  | sent bytes via network |
| - blockIO.r | X | X |  | bytes read from BlockIO |
| - blockIO.w | X | X |  | bytes written to BlockIO |
| - cpu_stats | X | X |  | detailed cpu stats |
| - percpu_stats | X | X |  | detailed per cpu stats |
| - memory_stats | X | X |  | detailed memory stats |
| - networks | X | X |  | detailed network stats per interface |
| si.<span class="apidocCodeKeywordSpan">dockerContainerProcesses</span>(id, cb) | X | X |  | array of processes inside a container
 |
| - [0].pid_host | X | X |  | process ID (host) |
| - [0].ppid | X | X |  | parent process ID |
| - [0].pgid | X | X |  | process group ID |
| - [0].user | X | X |  | effective user name |
| - [0].ruser | X | X |  | real user name |
| - [0].group | X | X |  | effective group name |
| - [0].rgroup | X | X |  | real group name |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainerStats" id="apidoc.element.systeminformation.dockerContainerStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainerStats
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerStats(containerID, callback) {
  containerID = containerID || &#x27;&#x27;;
  let result = {
    id: containerID,
    mem_usage: 0,
    mem_limit: 0,
    mem_percent: 0,
    cpu_percent: 0,
    pids: 0,
    netIO: {
      rx: 0,
      wx: 0
    },
    blockIO: {
      r: 0,
      w: 0
    }
  };
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getStats(containerID, data =&#x3e; {
          // let cmd = &#x22;curl --unix-socket /var/run/docker.sock http:/containers/&#x22; + containerID + &#x22;/stats?stream=0&#x22;;
          // exec(cmd, function (error, stdout) {
          //   if (!error) {
          //     let jsonString = stdout.toString();
          try {
//              let stats = JSON.parse(jsonString);
            let stats = data;
<span class="apidocCodeCommentSpan">            /**
             * @namespace
             * @property {Object}  memory_stats
             * @property {number}  memory_stats.usage
             * @property {number}  memory_stats.limit
             * @property {Object}  cpu_stats
             * @property {Object}  pids_stats
             * @property {number}  pids_stats.current
             * @property {Object}  networks
             * @property {Object}  blkio_stats
             */
</span>
            if (!stats.message) {
              result.mem_usage = (stats.memory_stats &#x26;&#x26; stats.memory_stats.usage ? stats.memory_stats.usage : 0);
              result.mem_limit = (stats.memory_stats &#x26;&#x26; stats.memory_stats.limit ? stats.memory_stats.limit : 0);
              result.mem_percent = (stats.memory_stats &#x26;&#x26; stats.memory_stats.usage &#x26;&#x26; stats.memory_stats.limit ? stats.memory_stats
.usage / stats.memory_stats.limit * 100.0 : 0);
              result.cpu_percent = (stats.cpu_stats ? docker_calcCPUPercent(stats.cpu_stats, containerID) : 0);
              result.pids = (stats.pids_stats &#x26;&#x26; stats.pids_stats.current ? stats.pids_stats.current : 0);
              if (stats.networks) result.netIO = docker_calcNetworkIO(stats.networks);
              if (stats.blkio_stats) result.blockIO = docker_calcBlockIO(stats.blkio_stats);
              result.cpu_stats = (stats.cpu_stats ? stats.cpu_stats : {});
              result.precpu_stats = (stats.precpu_stats ? stats.precpu_stats : {});
              result.memory_stats = (stats.memory_stats ? stats.memory_stats : {});
              result.networks = (stats.networks ? stats.networks : {});
            }
          } catch (err) {
          }
          // }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
| - [0].ports | X | X |  | array of ports |
| - [0].mounts | X | X |  | array of mounts |
| si.<span class="apidocCodeKeywordSpan">dockerContainerStats</span>(id, cb) | X | X |  | statistics for a specific container |
| - id | X | X |  | Container ID |
| - mem_usage | X | X |  | memory usage in bytes |
| - mem_limit | X | X |  | memory limit (max mem) in bytes |
| - mem_percent | X | X |  | memory usage in percent |
| - cpu_percent | X | X |  | cpu usage in percent |
| - pids | X | X |  | number of processes |
| - netIO.rx | X | X |  | received bytes via network |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.dockerContainers" id="apidoc.element.systeminformation.dockerContainers">
        function <span class="apidocSignatureSpan">systeminformation.</span>dockerContainers
        <span class="apidocSignatureSpan">(all, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainers(all, callback) {

  function inContainers(containers, id) {
    let filtered = containers.filter(obj =&#x3e; {
<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {string}  Id
       */
</span>      return (obj.Id &#x26;&#x26; (obj.Id == id))
    });
    return (filtered.length &#x3e; 0);
  }

  // fallback - if only callback is given
  if (util.isFunction(all) &#x26;&#x26; !callback) {
    callback = all;
    all = false;
  }

  all = all || false;
  let result = [];
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      if (!_docker_socket) {
        _docker_socket = new DockerSocket();
      }

      _docker_socket.listContainers(all, data =&#x3e; {
        let docker_containers = {};
        // let cmd = &#x22;curl --unix-socket /var/run/docker.sock http:/containers/json&#x22; + (all ? &#x22;?all=1&#x22; : &#x22;&#x22;);
        // exec(cmd, function (error, stdout) {
        //   if (!error) {
        try {
          //       let jsonString = stdout.toString();
          //       let docker_containers = JSON.parse(jsonString);
          docker_containers = data;
          if (docker_containers &#x26;&#x26; Object.prototype.toString.call(docker_containers) === &#x27;[object Array]&#x27; &#x26;&#x26; docker_containers.length
 &#x3e; 0) {
            docker_containers.forEach(function (element) {
              /**
               * @namespace
               * @property {string}  Id
               * @property {string}  Name
               * @property {string}  Image
               * @property {string}  ImageID
               * @property {string}  Command
               * @property {number}  Created
               * @property {string}  State
               * @property {Array}  Names
               * @property {Array}  Ports
               * @property {Array}  Mounts
               */

              if (element.Names &#x26;&#x26; Object.prototype.toString.call(element.Names) === &#x27;[object Array]&#x27; &#x26;&#x26; element.Names.length &#x3e;
0) {
                element.Name = element.Names[0].replace(/^\/|\/$/g, &#x27;&#x27;);
              }
              result.push({
                id: element.Id,
                name: element.Name,
                image: element.Image,
                imageID: element.ImageID,
                command: element.Command,
                created: element.Created,
                state: element.State,
                ports: element.Ports,
                mounts: element.Mounts,
                // hostconfig: element.HostConfig,
                // network: element.NetworkSettings
              })
            });
          }
        } catch (err) {
        }
        // }

        // GC in _docker_container_stats
        for (let key in _docker_container_stats) {
          if (_docker_container_stats.hasOwnProperty(key)) {
            if (!inContainers(docker_containers, key)) delete _docker_container_stats[key];
          }
        }
        if (callback) { callback(result) }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&#x3c;br&#x3e;host parameter is optional (default
 8.8.8.8)|
| si.<span class="apidocCodeKeywordSpan">dockerContainers</span>(all, cb) | X | X |  | returns array of active/all docker containers
 |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.fsSize" id="apidoc.element.systeminformation.fsSize">
        function <span class="apidocSignatureSpan">systeminformation.</span>fsSize
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsSize(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_linux || _darwin) {
        let cmd = (_darwin ? &#x22;df -lkP | grep ^/&#x22; : &#x22;df -lkPT | grep ^/&#x22;);
        exec(cmd, function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            //lines.splice(0, 1);
            lines.forEach(function (line) {
              if (line != &#x27;&#x27;) {
                line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
                data.push({
                  &#x27;fs&#x27;: line[0],
                  &#x27;type&#x27;: (_linux ? line[1] : &#x27;HFS&#x27;),
                  &#x27;size&#x27;: parseInt((_linux ? line[2] : line[1])) * 1024,
                  &#x27;used&#x27;: parseInt((_linux ? line[3] : line[2])) * 1024,
                  &#x27;use&#x27;: parseFloat((100.0 * (_linux ? line[3] : line[2]) / (_linux ? line[2] : line[1])).toFixed(2)),
                  &#x27;mount&#x27;: line[line.length - 1]
                })
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec(&#x27;wmic logicaldisk get Caption,FileSystem,FreeSpace,Size&#x27;, function (error, stdout) {
          let lines = stdout.split(&#x27;\r\n&#x27;).filter(line =&#x3e; line.trim() != &#x27;&#x27;).filter((line, idx) =&#x3e; idx &#x3e; 0);
          lines.forEach(function (line) {
            if (line != &#x27;&#x27;) {
              line = line.trim().split(/\s\s+/);
              data.push({
                &#x27;fs&#x27;: line[0],
                &#x27;type&#x27;: line[1],
                &#x27;size&#x27;: line[3],
                &#x27;used&#x27;: parseInt(line[3]) - parseInt(line[2]),
                &#x27;use&#x27;: parseFloat((100.0 * (parseInt(line[3]) - parseInt(line[2]))) / parseInt(line[3])),
                &#x27;mount&#x27;: line[0]
              })
            }
          });
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - displays[0].builtin | X | X |  | true if built in monitor |
| - displays[0].connection | X | X |  | e.g. DisplayPort or HDMI |
| - displays[0].resolutionx | X | X |  | pixel horizontal |
| - displays[0].resolutiony | X | X |  | pixel vertical |
| - displays[0].depth | X | X |  | color depth in bits |
| - displays[0].sizex | X | X |  | size in mm horizontal |
| - displays[0].sizey | X | X |  | size in mm vertical |
| si.<span class="apidocCodeKeywordSpan">fsSize</span>(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.blockDevices(cb) | X | X | X | returns array of disks, partitions,&#x3c;br&#x3e;raids and roms |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.fsStats" id="apidoc.element.systeminformation.fsStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>fsStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsStats(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: -1,
        wx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let rx = 0;
      let wx = 0;
      if ((_fs_speed &#x26;&#x26; !_fs_speed.ms) || (_fs_speed &#x26;&#x26; _fs_speed.ms &#x26;&#x26; Date.now() - _fs_speed.ms &#x3e;= 500)) {
        if (_linux) {
//  		  exec(&#x22;df -k | grep /dev/&#x22;, function(error, stdout) {
          exec(&#x22;lsblk | grep /&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              let fs_filter = [];
              lines.forEach(function (line) {
                if (line != &#x27;&#x27;) {
                  line = line.replace(/[ââââ]+/g, &#x22;&#x22;).trim().split(&#x27; &#x27;);
                  if (fs_filter.indexOf(line[0]) == -1) fs_filter.push(line[0])
                }
              });

              let output = fs_filter.join(&#x27;|&#x27;);
              exec(&#x22;cat /proc/diskstats | egrep &#x27;&#x22; + output + &#x22;&#x27;&#x22;, function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split(&#x27;\n&#x27;);
                  lines.forEach(function (line) {
                    line = line.trim();
                    if (line != &#x27;&#x27;) {
                      line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);

                      rx += parseInt(line[5]) * 512;
                      wx += parseInt(line[9]) * 512;
                    }
                  });
                  result = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result)
                }
                resolve(result);
              })
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          })
        }
        if (_darwin) {
          exec(&#x22;ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n &#x27;/IOBlockStorageDriver/,/Statistics/p&#x27; | grep &#x27;Statistics
&#x27; | tr -cd &#x27;01234567890,\n&#x27; | awk -F&#x27;,&#x27; &#x27;{print $3, $10}&#x27;&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              lines.forEach(function (line) {
                line = line.trim();
                if (line != &#x27;&#x27;) {
                  line = line.split(&#x27; &#x27;);

                  rx += parseInt(line[0]);
                  wx += parseInt(line[1]);
                }
              });
              result = calcFsSpeed(rx, wx);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.ms = _fs_speed.last_ms;
        result.rx = _fs_speed.bytes_read;
        result.wx = _fs_speed.bytes_write;
        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
        result.rx_sec = _fs_speed.rx_sec;
        result.wx_sec = _fs_speed.wx_sec;
        result.tx_sec = _fs_speed.tx_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
| - [0].label | X | X | X | label |
| - [0].model | X | X |  | model |
| - [0].serial | X |  | X | serial |
| - [0].removable | X | X | X | serial |
| - [0].protocol | X | X |  | protocol (SATA, PCI-Express, ...) |
| si.<span class="apidocCodeKeywordSpan">fsStats</span>(cb) | X | X |  | current transfer stats |
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.fullLoad" id="apidoc.element.systeminformation.fullLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>fullLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fullLoad(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      getFullLoad().then(result =&#x3e; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.<span class="apidocCodeKeywordSpan">fullLoad</span>(cb) | X | X |  | CPU-full load since bootup in % |
| si.services(&#x27;mysql, apache2&#x27;, cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.getAllData" id="apidoc.element.systeminformation.getAllData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getAllData
        <span class="apidocSignatureSpan">(srv, iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getAllData(srv, iface, callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let data = {};

      getStaticData().then(res =&#x3e; {
        data = res;
        getDynamicData(srv, iface).then(res =&#x3e; {
          for (let key in res) {
            if (res.hasOwnProperty(key)) {
              data[key] = res[key];
            }
          }
          if (callback) { callback(data) }
          resolve(data);
        });
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&#x3c;br&#x3e;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.<span class="apidocCodeKeywordSpan">getAllData</span>(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:

**Callback Style**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.getDynamicData" id="apidoc.element.systeminformation.getDynamicData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getDynamicData
        <span class="apidocSignatureSpan">(srv, iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDynamicData(srv, iface, callback) {

  if (util.isFunction(iface)) {
    callback = iface;
    iface = &#x27;&#x27;;
  }
  if (util.isFunction(srv)) {
    callback = srv;
    srv = &#x27;&#x27;;
  }

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      iface = iface || network.getDefaultNetworkInterface();
      srv = srv || &#x27;&#x27;;

      // use closure to track Æ completion
      let functionProcessed = (function () {
        let totalFunctions = 14;

        return function () {
          if (--totalFunctions === 0) {
            if (callback) { callback(data) }
            resolve(data);
          }
        };
      })();

      // var totalFunctions = 14;
      // function functionProcessed() {
      //   if (--totalFunctions === 0) {
      //     if (callback) { callback(data) }
      //     resolve(data);
      //   }
      // }

      let data = {};

      // get time
      data.time = osInfo.time();

<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {Object}  versions
       * @property {string}  versions.node
       * @property {string}  versions.v8
       */
</span>      data.node = process.versions.node;
      data.v8 = process.versions.v8;

      cpu.cpuCurrentspeed().then(res =&#x3e; {
        data.cpuCurrentspeed = res;
        functionProcessed();
      });

      users.users().then(res =&#x3e; {
        data.users = res;
        functionProcessed();
      });

      processes.processes().then(res =&#x3e; {
        data.processes = res;
        functionProcessed();
      });

      cpu.currentLoad().then(res =&#x3e; {
        data.currentLoad = res;
        functionProcessed();
      });

      cpu.cpuTemperature().then(res =&#x3e; {
        data.temp = res;
        functionProcessed();
      });

      network.networkStats(iface).then(res =&#x3e; {
        data.networkStats = res;
        functionProcessed();
      });

      network.networkConnections().then(res =&#x3e; {
        data.networkConnections = res;
        functionProcessed();
      });

      mem().then(res =&#x3e; {
        data.mem = res;
        functionProcessed();
      });

      battery().then(res =&#x3e; {
        data.battery = res;
        functionProcessed();
      });

      processes.services(srv).then(res =&#x3e; {
        data.services = res;
        functionProcessed();
      });

      filesystem.fsSize().then(res =&#x3e; {
        data.fsSize = res;
        functionProcessed();
      });

      filesystem.fsStats().then(res =&#x3e; {
        data.fsStats = res;
        functionProcessed();
      });

      filesystem.disksIO().then(res =&#x3e; {
        data.disksIO = res;
        functionProcessed();
      });

      internet.inetLatency().then(res =&#x3e; {
        data.inetLatency = res;
        functionProcessed();
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&#x3c;br&#x3e;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.<span class="apidocCodeKeywordSpan">getDynamicData</span>(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:

**Callback Style**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.getStaticData" id="apidoc.element.systeminformation.getStaticData">
        function <span class="apidocSignatureSpan">systeminformation.</span>getStaticData
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getStaticData(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let data = {};

      data.version = version();

      system().then(res =&#x3e; {
        data.system = res;
        osInfo.osInfo().then(res =&#x3e; {
          data.os = res;
          osInfo.versions().then(res =&#x3e; {
            data.versions = res;
            cpu.cpu().then(res =&#x3e; {
              data.cpu = res;
              graphics.graphics().then(res =&#x3e; {
                data.graphics = res;
                network.networkInterfaces().then(res =&#x3e; {
                  data.net = res;
                  if (callback) { callback(data) }
                  resolve(data);
                })
              })
            })
          })
        })
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.dockerAll(cb) | X | X |  | list of all containers including their stats&#x3c;br&#x3e;and processes in one single array |
| si.<span class="apidocCodeKeywordSpan">getStaticData</span>(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.graphics" id="apidoc.element.systeminformation.graphics">
        function <span class="apidocSignatureSpan">systeminformation.</span>graphics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function graphics(callback) {

  function parseLinesDarwin(lines) {
    let starts = [];
    let level = -1;
    let lastlevel = -1;
    let controllers = [];
    let displays = [];
    let currentController = {};
    let currentDisplay = {};
    for (let i = 0; i &#x3c; lines.length; i++) {
      if (&#x27;&#x27; != lines[i].trim()) {
        let start = lines[i].search(/\S|$/);
        if (-1 == starts.indexOf(start)) {
          starts.push(start);
        }
        level = starts.indexOf(start);
        if (level &#x3c; lastlevel) {
          if (Object.keys(currentController).length &#x3e; 0) {// just changed to Displays
            controllers.push(currentController);
            currentController = {};
          }
          if (Object.keys(currentDisplay).length &#x3e; 0) {// just changed to Displays
            displays.push(currentDisplay);
            currentDisplay = {};
          }
        }
        lastlevel = level;
        let parts = lines[i].split(&#x27;:&#x27;);
        if (2 == level) {       // grafics controller level
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;chipsetmodel&#x27;) != -1) currentController.model
 = parts[1].trim();
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;bus&#x27;) != -1) currentController.bus = parts[
1].trim();
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;vendor&#x27;) != -1) currentController.vendor =
parts[1].split(&#x27;(&#x27;)[0].trim();
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;vram(total)&#x27;) != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = false;
          }
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;vram(dynamic,max)&#x27;) != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = true;
          }
        }
        if (3 == level) {       // display controller level
          if (parts.length &#x3e; 1 &#x26;&#x26; &#x27;&#x27; == parts[1]) {
            currentDisplay.model = parts[0].trim();
            currentDisplay.main = false;
            currentDisplay.builtin = false;
            currentDisplay.connection = &#x27;&#x27;;
            currentDisplay.sizex = -1;
            currentDisplay.sizey = -1;
          }
        }
        if (4 == level) {       // display controller details level
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;resolution&#x27;) != -1) {
            let resolution = parts[1].split(&#x27;x&#x27;);
            currentDisplay.resolutionx = (resolution.length &#x3e; 1 ? parseInt(resolution[0]) : 0);
            currentDisplay.resolutiony = (resolution.length &#x3e; 1 ? parseInt(resolution[1]) : 0);
          }
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;pixeldepth&#x27;) != -1) currentDisplay.pixeldepth
 = parseInt(parts[1]); // in BIT
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;maindisplay&#x27;) != -1 &#x26;&#x26; parts[1].replace(/ +/
g, &#x22;&#x22;).toLowerCase() == &#x27;yes&#x27;) currentDisplay.main = true;
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;built-in&#x27;) != -1 &#x26;&#x26; parts[1].replace(/ +/g, &#x22;&#x22;).
toLowerCase() == &#x27;yes&#x27;) {
            currentDisplay.builtin = true;
            currentDisplay.connection = &#x27;&#x27;;
          }
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;connectiontype&#x27;) != -1) {
            currentDisplay.builtin = false;
            currentDisplay.connection = parts[1].trim();
          }
        }
      }
    }
    if (Object.keys(currentController).length &#x3e; 0) {// just changed to Displays
      controllers.push(currentController);
    }
    if (Object.keys(currentDisplay).length &#x3e; 0) {// just changed to Displays
      displays.push(currentDisplay);
    }
    return ({
      controllers: controllers,
      displays: displays
    })
  }

  function parseLinesLinuxControllers(lines) {
    let controllers = [];
    let currentController = {};
    let is_vga = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - swapfree | X | X |  |  |
| si.battery(cb) | X | X |  | battery information |
| - hasbattery | X | X |  | indicates presence of battery |
| - ischarging | X | X |  | indicates if battery is charging |
| - maxcapacity | X | X |  | max capacity of battery |
| - currentcapacity | X | X |  | current capacity of battery |
| - percent | X | X |  | charging level in percent |
| si.<span class="apidocCodeKeywordSpan">graphics</span>(cb) | X | X |  | arrays of graphics controllers and displays |
| - controllers[0].model | X | X |  | graphics controller model |
| - controllers[0].vendor | X | X |  | e.g. ATI |
| - controllers[0].bus | X | X |  | on which bus (e.g. PCIe) |
| - controllers[0].vram | X | X |  | VRAM size (in MB) |
| - controllers[0].vramDynamic | X | X |  | true if dynamicly allocated ram |
| - displays[0].model | X | X |  | Monitor/Display Model |
| - displays[0].main | X | X |  | true if main monitor |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.inetChecksite" id="apidoc.element.systeminformation.inetChecksite">
        function <span class="apidocSignatureSpan">systeminformation.</span>inetChecksite
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetChecksite(url, callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        url: url,
        ok: false,
        status: 404,
        ms: -1
      };
      if (url) {
        let t = Date.now();
        let args = &#x22; -I --connect-timeout 5 -m 5 &#x22; + url + &#x22; 2&#x3e;/dev/null | head -n 1 | cut -d &#x27; &#x27; -f2&#x22;;
        let cmd = &#x22;curl&#x22;;
        exec(cmd + args, function (error, stdout) {
          let statusCode = parseInt(stdout.toString());
          result.status = statusCode || 404;
          result.ok = !error &#x26;&#x26; (statusCode == 200 || statusCode == 301 || statusCode == 302 || statusCode == 304);
          result.ms = (result.ok ? Date.now() - t : -1);
          if (callback) { callback(result) }
          resolve(result);
        })
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.<span class="apidocCodeKeywordSpan">inetChecksite</span>(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&#x3c;br&#x3e;host parameter is optional (default
 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.inetLatency" id="apidoc.element.systeminformation.inetLatency">
        function <span class="apidocSignatureSpan">systeminformation.</span>inetLatency
        <span class="apidocSignatureSpan">(host, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetLatency(host, callback) {

  // fallback - if only callback is given
  if (util.isFunction(host) &#x26;&#x26; !callback) {
    callback = host;
    host = &#x27;&#x27;;
  }

  host = host || &#x27;8.8.8.8&#x27;;

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let t = Date.now();
      let cmd;
      if (_linux) {
        cmd = &#x22;ping -c 2 -w 3 &#x22; + host + &#x22; | grep rtt | cut -d&#x27;/&#x27; -f4 | awk &#x27;{ print $3 }&#x27;&#x22;;
      }
      if (_darwin) {
        cmd = &#x22;ping -c 2 -t 3 &#x22; + host + &#x22; | grep avg | cut -d&#x27;/&#x27; -f4 | awk &#x27;{ print $3 }&#x27;&#x22;;
      }

      exec(cmd, function (error, stdout) {
        let result = -1;
        if (!error) {
          result = parseFloat(stdout.toString());
        }
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.<span class="apidocCodeKeywordSpan">inetLatency</span>(host, cb) | X | X |  | response-time (ms) to external resource&#x3c;
br&#x3e;host parameter is optional (default 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.mem" id="apidoc.element.systeminformation.mem">
        function <span class="apidocSignatureSpan">systeminformation.</span>mem
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mem = function (callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {

      let result = {
        total: os.totalmem(),
        free: os.freemem(),
        used: os.totalmem() - os.freemem(),

        active: os.totalmem() - os.freemem(),     // temporarily (fallback)
        available: os.freemem(),                  // temporarily (fallback)
        buffcache: 0,

        swaptotal: 0,
        swapused: 0,
        swapfree: 0
      };

      if (_linux) {
        exec(&#x22;free -b&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);

            let mem = lines[1].replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
            result.total = parseInt(mem[1]);
            result.free = parseInt(mem[3]);

            if (lines.length === 4) {                   // free (since free von procps-ng 3.3.10)
              result.buffcache = parseInt(mem[5]);
              result.available = parseInt(mem[6]);
              mem = lines[2].replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
            } else {                                    // free (older versions)
              result.buffcache = parseInt(mem[5]) + parseInt(mem[6]);
              result.available = result.free + result.buffcache;
              mem = lines[3].replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
            }
            result.active = result.total - result.free - result.buffcache;

            result.swaptotal = parseInt(mem[1]);
            result.swapfree = parseInt(mem[3]);
            result.swapused = parseInt(mem[2]);

          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec(&#x22;vm_stat | grep &#x27;Pages active&#x27;&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);

            result.active = parseInt(lines[0].split(&#x27;:&#x27;)[1]) * 4096;
            result.buffcache = result.used - result.active;
            result.available = result.free + result.buffcache;
          }
          exec(&#x22;sysctl -n vm.swapusage&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              if (lines.length &#x3e; 0) {
                let line = lines[0].replace(/,/g, &#x22;.&#x22;).replace(/M/g, &#x22;&#x22;);
                line = line.trim().split(&#x27;  &#x27;);
                for (let i = 0; i &#x3c; line.length; i++) {
                  if (line[i].toLowerCase().indexOf(&#x27;total&#x27;) != -1) result.swaptotal = parseFloat(line[i].split(&#x27;=&#x27;)[1].trim()) *
1024 * 1024;
                  if (line[i].toLowerCase().indexOf(&#x27;used&#x27;) != -1) result.swapused = parseFloat(line[i].split(&#x27;=&#x27;)[1].trim()) *
1024 * 1024;
                  if (line[i].toLowerCase().indexOf(&#x27;free&#x27;) != -1) result.swapfree = parseFloat(line[i].split(&#x27;=&#x27;)[1].trim()) *
1024 * 1024;

                }
              }
            }
            if (callback) { callback(result) }
            resolve(result);
          });
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.cpuTemperature(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
| si.<span class="apidocCodeKeywordSpan">mem</span>(cb) | X | X | X | Memory information|
| - total | X | X | X | total memory |
| - free | X | X | X | not used |
| - used | X | X | X | used (incl. buffers/cache) |
| - active | X | X | X | used actively (excl. buffers/cache)  |
| - buffcache | X | X |  | used by buffers+cache |
| - available | X | X | X | potentially available (total - active) |
| - swaptotal | X | X |  |  |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkConnections" id="apidoc.element.systeminformation.networkConnections">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkConnections
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkConnections(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];
      if (_linux) {
        let cmd = &#x22;netstat -tuna | grep &#x27;ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN\\|VERBUNDEN&#x27;&#x22;;
        exec(cmd, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
              if (line.length &#x3e;= 6) {
                let localip = line[3];
                let localport = &#x27;&#x27;;
                let localaddress = line[3].split(&#x27;:&#x27;);
                if (localaddress.length &#x3e; 1) {
                  localport = localaddress[localaddress.length - 1];
                  localaddress.pop();
                  localip = localaddress.join(&#x27;:&#x27;);
                }
                let peerip = line[4];
                let peerport = &#x27;&#x27;;
                let peeraddress = line[4].split(&#x27;:&#x27;);
                if (peeraddress.length &#x3e; 1) {
                  peerport = peeraddress[peeraddress.length - 1];
                  peeraddress.pop();
                  peerip = peeraddress.join(&#x27;:&#x27;);
                }
                let connstate = line[5];
                if (connstate == &#x27;VERBUNDEN&#x27;) connstate = &#x27;ESTABLISHED&#x27;;
                if (connstate) {
                  result.push({
                    protocol: line[0],
                    localaddress: localip,
                    localport: localport,
                    peeraddress: peerip,
                    peerport: peerport,
                    state: connstate
                  })
                }
              }
            });
            if (callback) {
              callback(result)
            }
            resolve(result);
          } else {
            cmd = &#x22;ss -tuna | grep &#x27;ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-
ACK\\|LISTEN\\|CLOSING&#x27;&#x22;;
            exec(cmd, function (error, stdout) {

              if (!error) {
                let lines = stdout.toString().split(&#x27;\n&#x27;);
                lines.forEach(function (line) {
                  line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
                  if (line.length &#x3e;= 6) {
                    let localip = line[4];
                    let localport = &#x27;&#x27;;
                    let localaddress = line[4].split(&#x27;:&#x27;);
                    if (localaddress.length &#x3e; 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(&#x27;:&#x27;);
                    }
                    let peerip = line[5];
                    let peerport = &#x27;&#x27;;
                    let peeraddress = line[5].split(&#x27;:&#x27;);
                    if (peeraddress.length &#x3e; 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(&#x27;:&#x27;);
                    }
                    let connstate = line[1];
                    if (connstate == &#x27;ESTAB&#x27;) connstate = &#x27;ESTABLISHED&#x27;;
                    if (connstate == &#x27;TIME-WAIT&#x27;) connstate = &#x27;TIME_WAIT&#x27;;
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localaddress: localip,
                        localport: localport,
                        peeraddress: peerip,
                        peerport: peerport,
                        state: connstate
                      })
                    }
                  }
                });
              }
              if (callback) {
                callback(result)
              }
              resolve(result);
            })
          }
        })
      }
      if (_darwin) {
        l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkConnections</span>(cb) | X | X |  | current network network connections&#x3c;br&#
x3e;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.currentLoad(cb) | X | X |  | CPU-Load |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkInterfaceDefault" id="apidoc.element.systeminformation.networkInterfaceDefault">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaceDefault
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaceDefault(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = getDefaultNetworkInterface();
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ms | X | X |  | interval length (for per second values) |
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.<span class="apidocCodeKeywordSpan">networkInterfaceDefault</span>(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&#x3c;br&#x3e;iface parameter is optional&#x3c;
br&#x3e;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkInterfaces" id="apidoc.element.systeminformation.networkInterfaces">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkInterfaces
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaces(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let ifaces = os.networkInterfaces();
      let result = [];

      for (let dev in ifaces) {
        let ip4 = &#x27;&#x27;;
        let ip6 = &#x27;&#x27;;
        let mac = &#x27;&#x27;;
        if (ifaces.hasOwnProperty(dev)) {
          ifaces[dev].forEach(function (details) {
            if (details.family == &#x27;IPv4&#x27;) {
              ip4 = details.address
            }
            if (details.family == &#x27;IPv6&#x27;) {
              ip6 = details.address
            }
            mac = details.mac
          });
          let internal = (ifaces[dev] &#x26;&#x26; ifaces[dev][0]) ? ifaces[dev][0].internal : null;
          result.push({ iface: dev, ip4: ip4, ip6: ip6, mac: mac, internal: internal })
        }
      }
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkInterfaces</span>(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&#x3c;br&#x3e;iface parameter is optional&#x3c;
br&#x3e;defaults to first external network interface|
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.networkStats" id="apidoc.element.systeminformation.networkStats">
        function <span class="apidocSignatureSpan">systeminformation.</span>networkStats
        <span class="apidocSignatureSpan">(iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkStats(iface, callback) {

  // fallback - if only callback is given
  if (util.isFunction(iface) &#x26;&#x26; !callback) {
    callback = iface;
    iface = &#x27;&#x27;;
  }

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      _default_iface = _default_iface || getDefaultNetworkInterface();
      iface = iface || _default_iface; // (_darwin ? &#x27;en0&#x27; : &#x27;eth0&#x27;);

      let result = {
        iface: iface,
        operstate: &#x27;unknown&#x27;,
        rx: 0,
        tx: 0,
        rx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let operstate = &#x27;unknown&#x27;;
      let rx = 0;
      let tx = 0;

      let cmd, lines, stats;
      if (!_network[iface] || (_network[iface] &#x26;&#x26; !_network[iface].ms) || (_network[iface] &#x26;&#x26; _network[iface].ms &#x26;&#x26; Date.now() -
_network[iface].ms &#x3e;= 500)) {
        if (_linux) {
          if (fs.existsSync(&#x27;/sys/class/net/&#x27; + iface)) {
            cmd =
              &#x22;cat /sys/class/net/&#x22; + iface + &#x22;/operstate; &#x22; +
              &#x22;cat /sys/class/net/&#x22; + iface + &#x22;/statistics/rx_bytes; &#x22; +
              &#x22;cat /sys/class/net/&#x22; + iface + &#x22;/statistics/tx_bytes; &#x22;;
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split(&#x27;\n&#x27;);
                operstate = lines[0].trim();
                rx = parseInt(lines[1]);
                tx = parseInt(lines[2]);

                result = calcNetworkSpeed(iface, rx, tx, operstate);

              }
              if (callback) { callback(result) }
              resolve(result);
            });
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        }
        if (_darwin) {
          cmd = &#x22;ifconfig &#x22; + iface + &#x22; | grep &#x27;status&#x27;&#x22;;
          exec(cmd, function (error, stdout) {
            result.operstate = (stdout.toString().split(&#x27;:&#x27;)[1] || &#x27;&#x27;).trim();
            result.operstate = (result.operstate || &#x27;&#x27;).toLowerCase();
            result.operstate = (result.operstate == &#x27;active&#x27; ? &#x27;up&#x27; : (result.operstate == &#x27;inactive&#x27; ? &#x27;down&#x27; : &#x27;unknown&#x27;));
            cmd = &#x22;netstat -bI &#x22; + iface;
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split(&#x27;\n&#x27;);
                // if there is less than 2 lines, no information for this interface was found
                if (lines.length &#x3e; 1 &#x26;&#x26; lines[1].trim() != &#x27;&#x27;) {
                  // skip header line
                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address
                  stats = lines[1].replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
                  rx = parseInt(stats[6]);
                  tx = parseInt(stats[9]);

                  result = calcNetworkSpeed(iface, rx, tx, operstate);
                }
              }
              if (callback) { callback(result) }
              resolve(result);
            });
          });
        }
      } else {
        result.rx = _network[iface].rx;
        result.tx = _network[iface].tx;
        result.rx_sec = _network[iface].rx_sec;
        result.tx_sec = _network[iface].tx_sec;
        result.ms = _network[iface].last_ms;
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.<span class="apidocCodeKeywordSpan">networkStats</span>(iface,cb) | X | X |  | current network stats of given interface&#x3c
;br&#x3e;iface parameter is optional&#x3c;br&#x3e;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osInfo" id="apidoc.element.systeminformation.osInfo">
        function <span class="apidocSignatureSpan">systeminformation.</span>osInfo
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function osInfo(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = {

        platform: (_platform == &#x27;Windows_NT&#x27; ? &#x27;Windows&#x27; : _platform),
        distro: &#x27;unknown&#x27;,
        release: &#x27;unknown&#x27;,
        codename: &#x27;&#x27;,
        kernel: os.release(),
        arch: os.arch(),
        hostname: os.hostname(),
        logofile: &#x27;&#x27;
      };

      if (_linux) {

        exec(&#x22;cat /etc<span class="apidocCodeCommentSpan">/*-release&#x22;, function (error, stdout) {
          //if (!error) {
          /**
           * @namespace
           * @property {string}  DISTRIB_ID
           * @property {string}  NAME
           * @property {string}  DISTRIB_RELEASE
           * @property {string}  VERSION_ID
           * @property {string}  DISTRIB_CODENAME
           */
</span>          let release = {};
          let lines = stdout.toString().split(&#x27;\n&#x27;);
          lines.forEach(function (line) {
            if (line.indexOf(&#x27;=&#x27;) != -1) {
              release[line.split(&#x27;=&#x27;)[0].trim().toUpperCase()] = line.split(&#x27;=&#x27;)[1].trim();
            }
          });
          result.distro = (release.DISTRIB_ID || release.NAME || &#x27;unknown&#x27;).replace(/&#x22;/g, &#x27;&#x27;);
          result.logofile = getLogoFile(result.distro);
          result.release = (release.DISTRIB_RELEASE || release.VERSION_ID || &#x27;unknown&#x27;).replace(/&#x22;/g, &#x27;&#x27;);
          result.codename = (release.DISTRIB_CODENAME || &#x27;&#x27;).replace(/&#x22;/g, &#x27;&#x27;);
          //}
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_darwin) {
        exec(&#x22;sw_vers&#x22;, function (error, stdout) {
          let lines = stdout.toString().split(&#x27;\n&#x27;);
          lines.forEach(function (line) {
            if (line.indexOf(&#x27;ProductName&#x27;) != -1) {
              result.distro = line.split(&#x27;:&#x27;)[1].trim();
              result.logofile = getLogoFile(result.distro);
            }
            if (line.indexOf(&#x27;ProductVersion&#x27;) != -1) result.release = line.split(&#x27;:&#x27;)[1].trim();
          });
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_windows) {
        result.logofile = getLogoFile();
        result.release = result.kernel;
        exec(&#x22;wmic os get Caption&#x22;, function (error, stdout) {
          result.distro = result.codename = stdout.slice(stdout.indexOf(&#x27;\r\n&#x27;) + 2).trim();
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. &#x27;MSI&#x27; |
| - model | X | X | X | model/product e.g. &#x27;MS-7823&#x27; |
| - version | X | X | X | version e.g. &#x27;1.0&#x27; |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.<span class="apidocCodeKeywordSpan">osInfo</span>(cb) | X | X | X | OS information |
| - platform   | X | X | X | &#x27;Linux&#x27;, &#x27;Darwin&#x27;, &#x27;Windows&#x27; |
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.processLoad" id="apidoc.element.systeminformation.processLoad">
        function <span class="apidocSignatureSpan">systeminformation.</span>processLoad
        <span class="apidocSignatureSpan">(proc, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processLoad(proc, callback) {

  // fallback - if only callback is given
  if (util.isFunction(proc) &#x26;&#x26; !callback) {
    callback = proc;
    proc = &#x27;&#x27;;
  }

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        &#x27;proc&#x27;: proc,
        &#x27;pid&#x27;: -1,
        &#x27;cpu&#x27;: 0,
        &#x27;mem&#x27;: 0
      };

      if (proc) {
        exec(&#x22;ps aux | grep &#x22; + proc + &#x22; | grep -v grep&#x22;, function (error, stdout) {
          if (!error) {
            let data = stdout.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);

            if (data.length &#x3e; 2) {
              result = {
                &#x27;proc&#x27;: proc,
                &#x27;pid&#x27;: data[1],
                &#x27;cpu&#x27;: parseFloat(data[2].replace(&#x27;,&#x27;, &#x27;.&#x27;)),
                &#x27;mem&#x27;: parseFloat(data[3].replace(&#x27;,&#x27;, &#x27;.&#x27;))
              }
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].priority | X | X |  | process priotity |
| - ...[0].mem_vsz | X | X |  | process virtual memory size |
| - ...[0].mem_rss | X | X |  | process mem resident set size |
| - ...[0].nice | X | X |  | process nice value |
| - ...[0].started | X | X |  | process start time |
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.<span class="apidocCodeKeywordSpan">processLoad</span>(&#x27;apache2&#x27;,cb) | X | X |  | detailed information about given
 process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.processes" id="apidoc.element.systeminformation.processes">
        function <span class="apidocSignatureSpan">systeminformation.</span>processes
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processes(callback) {

  let parsedhead = [];

  function parseHead(head, rights) {
    let space = (rights &#x3e; 0);
    let count = 1;
    let from = 0;
    let to = 0;
    let result = [];
    for (let i = 0; i &#x3c; head.length; i++) {
      if (count &#x3c;= rights) {
        if (head[i] == &#x27; &#x27; &#x26;&#x26; !space) {
          to = i - 1;
          result.push({
            from: from,
            to: to + 1,
            cap: head.substring(from, to + 1)
          });
          from = to + 2;
          count++;
        }
        space = head[i] == &#x27; &#x27;;
      } else {
        if (head[i] != &#x27; &#x27; &#x26;&#x26; space) {
          to = i - 1;
          if (from &#x3c; to) {
            result.push({
              from: from,
              to: to,
              cap: head.substring(from, to)
            });
          }
          from = to + 1;
          count++;
        }
        space = head[i] == &#x27; &#x27;;
      }
    }
    to = 1000;
    result.push({
      from: from,
      to: to,
      cap: head.substring(from, to)
    });
    return result;

  }

  function parseLine(line) {
    let pid = parseInt(line.substring(parsedhead[0].from, parsedhead[0].to));
    let pcpu = parseFloat(line.substring(parsedhead[1].from, parsedhead[1].to).replace(/,/g, &#x22;.&#x22;));
    let pmem = parseFloat(line.substring(parsedhead[2].from, parsedhead[2].to).replace(/,/g, &#x22;.&#x22;));
    let priority = parseInt(line.substring(parsedhead[3].from, parsedhead[3].to));
    let vsz = parseInt(line.substring(parsedhead[4].from, parsedhead[4].to));
    let rss = parseInt(line.substring(parsedhead[5].from, parsedhead[5].to));
    let nice = parseInt(line.substring(parsedhead[6].from, parsedhead[6].to));
    let started = line.substring(parsedhead[7].from, parsedhead[7].to).trim();
    let state = line.substring(parsedhead[8].from, parsedhead[8].to).trim();
    state = (state[0] == &#x27;R&#x27; ? &#x27;running&#x27; : (state[0] == &#x27;S&#x27; ? &#x27;sleeping&#x27; : (state[0] == &#x27;T&#x27; ? &#x27;stopped&#x27; : (state[0] == &#x27;W&#x27; ? &#x27;paging
&#x27; : (state[0] == &#x27;X&#x27; ? &#x27;dead&#x27; : (state[0] == &#x27;Z&#x27; ? &#x27;zombie&#x27; : ((state[0] == &#x27;D&#x27; || state[0] == &#x27;U&#x27;) ? &#x27;blocked&#x27; : &#x27;unknown&#x27;)))))));
    let tty = line.substring(parsedhead[9].from, parsedhead[9].to).trim();
    if (tty == &#x27;?&#x27; || tty == &#x27;??&#x27;) tty = &#x27;&#x27;;
    let user = line.substring(parsedhead[10].from, parsedhead[10].to).trim();
    let command = line.substring(parsedhead[11].from, parsedhead[11].to).trim().replace(/\[/g, &#x22;&#x22;).replace(/]/g, &#x22;&#x22;);

    return ({
      pid: pid,
      pcpu: pcpu,
      pcpuu: 0,
      pcpus: 0,
      pmem: pmem,
      priority: priority,
      mem_vsz: vsz,
      mem_rss: rss,
      nice: nice,
      started: started,
      state: state,
      tty: tty,
      user: user,
      command: command
    })
  }

  function parseProcesses(lines) {
    let result = [];
    if (lines.length &#x3e; 1) {
      let head = lines[0];
      parsedhead = parseHead(head, 7);
      lines.shift();
      lines.forEach(function (line) {
        if (line.trim() != &#x27;&#x27;) {
          result.push(parseLine(line));
        }
      });
    }
    return result;
  }

  function parseProcStat(line) {
    let parts = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
    let user = (parts.length &#x3e;= 2 ? parseInt(parts[1]) : 0);
    let nice = (parts.length &#x3e;= 3 ? parseInt(parts[2]) : 0);
    let system = (parts.length &#x3e;= 4 ? parseInt(parts[3]) : 0);
    let idle = (parts.length &#x3e;= 5 ? parseInt(parts[4]) : 0);
    let iowait = (parts.length &#x3e;= 6 ? parseInt(parts[5]) : 0);
    let irq = (parts.length &#x3e;= 7 ? parseInt(parts[6]) : 0);
    let softirq = (parts.length &#x3e;= 8 ? parseInt(parts[7]) : 0);
    let steal = (parts.length &#x3e;= 9 ? parseInt(parts[8]) : 0);
    let guest = (parts.length &#x3e;= 10 ? parseInt(parts[9]) : 0);
    let guest_nice = (parts.length &#x3e;= 11 ? parseInt(parts[10]) : 0);
    return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
  }

  function parseProcPidStat(line, all) {
    let statparts = line.replace(/ +/g, &#x22; &#x22;).split(&#x27;)&#x27;);
    if (statparts.length &#x3e;= 2) {
      let parts = statparts[1].split(&#x27; &#x27;);
      if (parts.length &#x3e;= 16) {
        let pid = parseInt(statparts[0].split(&#x27; &#x27;)[0]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.services(&#x27;mysql, apache2&#x27;, cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">processes</span>(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
| - blocked | X | X |  | # of all processes blocked |
| - sleeping | X | X |  | # of all processes sleeping |
| - list[] | X | X |  | list of all processes incl. details |
| - ...[0].pid | X | X |  | process PID |
| - ...[0].pcpu | X | X |  | process % CPU usage |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.services" id="apidoc.element.systeminformation.services">
        function <span class="apidocSignatureSpan">systeminformation.</span>services
        <span class="apidocSignatureSpan">(srv, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function services(srv, callback) {

  // fallback - if only callback is given
  if (util.isFunction(srv) &#x26;&#x26; !callback) {
    callback = srv;
    srv = &#x27;&#x27;;
  }

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      srv = srv.trim().replace(/,+/g, &#x22; &#x22;).replace(/  +/g, &#x22; &#x22;).replace(/ +/g, &#x22;|&#x22;);
      let srvs = srv.split(&#x27;|&#x27;);
      let comm = (_darwin) ? &#x22;ps -caxm -o pcpu,pmem,comm&#x22; : &#x22;ps axo pcpu,pmem,comm&#x22;;
      let data = [];
      if (srv != &#x27;&#x27; &#x26;&#x26; srvs.length &#x3e; 0) {
        exec(comm + &#x22; | grep -v grep | egrep &#x27;&#x22; + srv + &#x22;&#x27;&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/ +/g, &#x22; &#x22;).replace(/,+/g, &#x22;.&#x22;).split(&#x27;\n&#x27;);
            srvs.forEach(function (srv) {
              let ps = lines.filter(function (e) {
                return e.indexOf(srv) != -1
              });
              data.push({
                &#x27;name&#x27;: srv,
                &#x27;running&#x27;: ps.length &#x3e; 0,
                &#x27;pcpu&#x27;: parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(&#x27; &#x27;)[0]);
                }, 0)).toFixed(2)),
                &#x27;pmem&#x27;: parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(&#x27; &#x27;)[1]);
                }, 0)).toFixed(2))
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          } else {
            srvs.forEach(function (srv) {
              data.push({
                &#x27;name&#x27;: srv,
                &#x27;running&#x27;: false,
                &#x27;pcpu&#x27;: 0,
                &#x27;pmem&#x27;: 0
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          }
        });
      } else {
        if (callback) { callback(data) }
        resolve(data);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.<span class="apidocCodeKeywordSpan">services</span>(&#x27;mysql, apache2&#x27;, cb) | X | X |  | pass comma separated string
 of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.shell" id="apidoc.element.systeminformation.shell">
        function <span class="apidocSignatureSpan">systeminformation.</span>shell
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shell(callback) {
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = &#x27;&#x27;;
      exec(&#x22;echo $SHELL&#x22;, function (error, stdout) {
        if (!error) {
          result = stdout.toString().split(&#x27;\n&#x27;)[0];
        }
        if (callback) {
          callback(result)
        }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. &#x27;apple&#x27;, &#x27;debian&#x27;, &#x27;fedora&#x27;, ... |
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.<span class="apidocCodeKeywordSpan">shell</span>(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.system" id="apidoc.element.systeminformation.system">
        function <span class="apidocSignatureSpan">systeminformation.</span>system
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">system = function (callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {

      let result = {
        manufacturer: &#x27;&#x27;,
        model: &#x27;Computer&#x27;,
        version: &#x27;&#x27;,
        serial: &#x27;-&#x27;,
        uuid: &#x27;-&#x27;
      };

      if (_linux) {
        exec(&#x22;dmidecode -t system&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              if (line.indexOf(&#x27;:&#x27;) != -1) {
                if (line.toLowerCase().indexOf(&#x27;manufacturer&#x27;) != -1) result.manufacturer = result.manufacturer || line.split(&#x27;:&#x27;)[
1].trim();
                if (line.toLowerCase().indexOf(&#x27;product name&#x27;) != -1) result.model = line.split(&#x27;:&#x27;)[1].trim();
                if (line.toLowerCase().indexOf(&#x27;version&#x27;) != -1) result.version = result.version || line.split(&#x27;:&#x27;)[1].trim();
                if (line.toLowerCase().indexOf(&#x27;serial number&#x27;) != -1) result.serial = line.split(&#x27;:&#x27;)[1].trim();
                if (line.toLowerCase().indexOf(&#x27;uuid&#x27;) != -1) result.uuid = line.split(&#x27;:&#x27;)[1].trim();
              }
            });
            if (result.serial.toLowerCase().indexOf(&#x27;o.e.m.&#x27;) != -1) result.serial = &#x27;-&#x27;;
            if (result.manufacturer.toLowerCase().indexOf(&#x27;o.e.m.&#x27;) != -1) result.manufacturer = &#x27;&#x27;;
            if (result.model.toLowerCase().indexOf(&#x27;o.e.m.&#x27;) != -1) result.model = &#x27;Computer&#x27;;
            if (result.version.toLowerCase().indexOf(&#x27;o.e.m.&#x27;) != -1) result.version = &#x27;-&#x27;;

            if (result.manufacturer == &#x27;&#x27; &#x26;&#x26; result.model == &#x27;Computer&#x27; &#x26;&#x26; result.version == &#x27;-&#x27;) {
              // Check Raspberry Pi
              exec(&#x22;grep Hardware /proc/cpuinfo; grep Serial /proc/cpuinfo; grep Revision /proc/cpuinfo&#x22;, function (error, stdout
) {
                if (!error) {
                  let lines = stdout.toString().split(&#x27;\n&#x27;);
                  lines.forEach(function (line) {
                    if (line.indexOf(&#x27;:&#x27;) != -1) {
                      if (line.toLowerCase().indexOf(&#x27;hardware&#x27;) != -1) result.model = line.split(&#x27;:&#x27;)[1].trim();
                      if (line.toLowerCase().indexOf(&#x27;revision&#x27;) != -1) result.version = line.split(&#x27;:&#x27;)[1].trim();
                      if (line.toLowerCase().indexOf(&#x27;serial&#x27;) != -1) result.serial = line.split(&#x27;:&#x27;)[1].trim();
                    }
                  });
                  if (result.model == &#x27;BCM2709&#x27;) {
                    result.manufacturer = &#x27;Raspberry Pi Foundation&#x27;;
                    result.model = result.model + &#x27; - Pi 2 Model B&#x27;;
                    if ([&#x27;a01041&#x27;, &#x27;a21041&#x27;].indexOf(result.version) &#x3e;= 0) {
                      result.version = result.version + &#x27; - Rev. 1.1&#x27;
                    }
                  }
                  if (result.model == &#x27;BCM2708&#x27;) {
                    result.manufacturer = &#x27;Raspberry Pi Foundation&#x27;;
                    if ([&#x27;0002&#x27;, &#x27;0003&#x27;].indexOf(result.version) &#x3e;= 0) {
                      result.model = result.model + &#x27; - Pi Model B&#x27;;
                      result.version = result.version + &#x27; - Rev 1.0&#x27;;
                    }
                    if ([&#x27;0007&#x27;, &#x27;0008&#x27;, &#x27;0009&#x27;].indexOf(result.version) &#x3e;= 0) {
                      result.model = result.model + &#x27; - Pi Model A&#x27;;
                      result.version = result.version + &#x27; - Rev 2.0&#x27;;
                    }
                    if ([&#x27;0004&#x27;, &#x27;0005&#x27;, &#x27;0006&#x27;, &#x27;000d&#x27;, &#x27;000e&#x27;, &#x27;000f&#x27;].indexOf(result.version) &#x3e;= 0) {
                      result.model = result.model + &#x27; - Pi Model B&#x27;;
                      result.version = result.version + &#x27; - Rev 2.0&#x27;;
                    }
                    if ([&#x27;0012&#x27;].indexOf(result.version) &#x3e;= 0) {
                      result.model = result.model + &#x27; - Pi Model A+&#x27;;
                      result.version = result.version + &#x27; - Rev 1.0&#x27;;
                    }
                    if ([&#x27;0010&#x27;].indexOf(result.version) &#x3e;= 0) {
                      result.model = result.model + &#x27; - Pi Model B+&#x27;;
                      result.version = result.version + &#x27; - Rev 1.0&#x27;;
                    }
                    if ([&#x27;0013&#x27;].indexOf(result.ver ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.time() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.<span class="apidocCodeKeywordSpan">system</span>(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. &#x27;MSI&#x27; |
| - model | X | X | X | model/product e.g. &#x27;MS-7823&#x27; |
| - version | X | X | X | version e.g. &#x27;1.0&#x27; |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.osInfo(cb) | X | X | X | OS information |
| - platform   | X | X | X | &#x27;Linux&#x27;, &#x27;Darwin&#x27;, &#x27;Windows&#x27; |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.time" id="apidoc.element.systeminformation.time">
        function <span class="apidocSignatureSpan">systeminformation.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time() {
  return {
    current: Date.now(),
    uptime: os.uptime()
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.<span class="apidocCodeKeywordSpan">time</span>() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. &#x27;MSI&#x27; |
| - model | X | X | X | model/product e.g. &#x27;MS-7823&#x27; |
| - version | X | X | X | version e.g. &#x27;1.0&#x27; |
| - serial | X | X | X | serial number |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.users" id="apidoc.element.systeminformation.users">
        function <span class="apidocSignatureSpan">systeminformation.</span>users
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function users(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];

      // linux
      if (_linux) {
        exec(&#x22;who --ips; echo &#x27;---&#x27;; w | tail -n +2&#x22;, function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            result = parseUsers1(lines);
            if (result.length == 0) {
              exec(&#x22;who; echo &#x27;---&#x27;; w | tail -n +2&#x22;, function (error, stdout) {
                if (!error) {
                  // lines / split
                  lines = stdout.toString().split(&#x27;\n&#x27;);
                  result = parseUsers1(lines);
                  if (callback) { callback(result) }
                  resolve(result);
                } else {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
            } else {
              if (callback) { callback(result) }
              resolve(result);
            }
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

      if (_darwin) {
        exec(&#x22;who; echo &#x27;---&#x27;; w -ih&#x22;, function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            result = parseUsers2(lines);

            if (callback) { callback(result) }
            resolve(result);
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.processLoad(&#x27;apache2&#x27;,cb) | X | X |  | detailed information about given process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">users</span>(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.version" id="apidoc.element.systeminformation.version">
        function <span class="apidocSignatureSpan">systeminformation.</span>version
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function version() {
  return lib_version;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
11. Docker
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.<span class="apidocCodeKeywordSpan">version</span>() | X | X | X | library version (no callback/promise) |
| si.time() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. &#x27;MSI&#x27; |
| - model | X | X | X | model/product e.g. &#x27;MS-7823&#x27; |
| - version | X | X | X | version e.g. &#x27;1.0&#x27; |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.versions" id="apidoc.element.systeminformation.versions">
        function <span class="apidocSignatureSpan">systeminformation.</span>versions
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function versions(callback) {
  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = {
        kernel: os.release(),
        node: process.versions.node,
        v8: process.versions.v8,
        npm: &#x27;&#x27;,
        pm2: &#x27;&#x27;,
        openssl: process.versions.openssl
      };
      let lines = [];
      exec(&#x22;npm -v&#x22;, function (error, stdout) {
        if (!error) {
          result.npm = stdout.toString().split(&#x27;\n&#x27;)[0];
        }
        exec(&#x22;pm2 -v&#x22;, function (error, stdout) {
          if (!error) {
            lines = stdout.toString().split(&#x27;\n&#x27;);
            if (lines.length &#x3e;= 2) {
              result.pm2 = lines[lines.length - 2];
            }
          }
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. &#x27;apple&#x27;, &#x27;debian&#x27;, &#x27;fedora&#x27;, ... |
| si.<span class="apidocCodeKeywordSpan">versions</span>(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
...</pre></li>
    </ul>














</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.cpu" id="apidoc.module.systeminformation.cpu">module systeminformation.cpu</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.cpu.cpu" id="apidoc.element.systeminformation.cpu.cpu">
        function <span class="apidocSignatureSpan">systeminformation.</span>cpu
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpu(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      getCpu().then(result =&#x3e; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

All functions (except `version` and `time`) are implemented as asynchronous functions. Here a small example how to use them:

```
var si = require(&#x27;systeminformation&#x27;);

// callback style
si.<span class="apidocCodeKeywordSpan">cpu</span>(function(data) {
	console.log(&#x27;CPU-Information:&#x27;);
	console.log(data);
})

// promises style - new in version 3
si.cpu()
	.then(data =&#x3e; console.log(data))
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu.cpuCache" id="apidoc.element.systeminformation.cpu.cpuCache">
        function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuCache
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCache(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {};
      if (_linux) {
        exec(&#x22;lscpu&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              let parts = line.split(&#x27;:&#x27;);
              if (parts[0].toUpperCase().indexOf(&#x27;L1D CACHE&#x27;) != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf(&#x27;L1I CACHE&#x27;) != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf(&#x27;L2 CACHE&#x27;) != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toUpperCase().indexOf(&#x27;L3 CACHE&#x27;) != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec(&#x22;sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              let parts = line.split(&#x27;:&#x27;);
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l1icachesize&#x27;) != -1) {
                result.l1d = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l1dcachesize&#x27;) != -1) {
                result.l1i = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l2cachesize&#x27;) != -1) {
                result.l2 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
              if (parts[0].toLowerCase().indexOf(&#x27;hw.l3cachesize&#x27;) != -1) {
                result.l3 = parseInt(parts[1].trim()) * (parts[1].indexOf(&#x27;K&#x27;) != -1 ? 1024 : 1);
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.<span class="apidocCodeKeywordSpan">cpuCache</span>(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu.cpuCurrentspeed" id="apidoc.element.systeminformation.cpu.cpuCurrentspeed">
        function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuCurrentspeed
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuCurrentspeed(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = getCpuCurrentSpeedSync();
      if (result == 0 &#x26;&#x26; _cpu_speed != &#x27;0.00&#x27;) result = parseFloat(_cpu_speed);

      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.<span class="apidocCodeKeywordSpan">cpuCurrentspeed</span>(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.cpuTemperature(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu.cpuFlags" id="apidoc.element.systeminformation.cpu.cpuFlags">
        function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuFlags
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuFlags(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = &#x27;&#x27;;
      if (_linux) {
        exec(&#x22;lscpu&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              if (line.split(&#x27;:&#x27;)[0].toUpperCase().indexOf(&#x27;FLAGS&#x27;) != -1) {
                result = line.split(&#x27;:&#x27;)[1].trim().toLowerCase();
              }
            });
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
      if (_darwin) {
        exec(&#x22;sysctl machdep.cpu.features&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            if (lines.length &#x3e; 0 &#x26;&#x26; lines[0].indexOf(&#x27;machdep.cpu.features:&#x27;) != -1) {
              result = lines[0].split(&#x27;:&#x27;)[1].trim().toLowerCase();
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.<span class="apidocCodeKeywordSpan">cpuFlags</span>(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
| - l1d | X | X |  | L1D size |
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu.cpuTemperature" id="apidoc.element.systeminformation.cpu.cpuTemperature">
        function <span class="apidocSignatureSpan">systeminformation.cpu.</span>cpuTemperature
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cpuTemperature(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = {
        main: -1.0,
        cores: [],
        max: -1.0
      };
      if (_linux) {
        exec(&#x22;sensors&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              let regex = /\+([^Â°]*)/g;
              let temps = line.match(regex);
              if (line.split(&#x27;:&#x27;)[0].toUpperCase().indexOf(&#x27;PHYSICAL&#x27;) != -1) {
                result.main = parseFloat(temps);
              }
              if (line.split(&#x27;:&#x27;)[0].toUpperCase().indexOf(&#x27;CORE &#x27;) != -1) {
                result.cores.push(parseFloat(temps));
              }
            });
            if (result.cores.length &#x3e; 0) {
              let maxtmp = Math.max.apply(Math, result.cores);
              result.max = (maxtmp &#x3e; result.main) ? maxtmp : result.main;
            }
            if (callback) { callback(result) }
            resolve(result);
          } else {
            fs.stat(&#x27;/sys/class/thermal/thermal_zone0/temp&#x27;, function(err, stat) {
              if(err == null) {
                exec(&#x22;cat /sys/class/thermal/thermal_zone0/temp&#x22;, function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split(&#x27;\n&#x27;);
                    if (lines.length &#x3e; 0) {
                      result.main = parseFloat(lines[0]) / 1000.0;
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              } else {
                exec(&#x22;/opt/vc/bin/vcgencmd measure_temp&#x22;, function (error, stdout) {
                  if (!error) {
                    let lines = stdout.toString().split(&#x27;\n&#x27;);
                    if (lines.length &#x3e; 0 &#x26;&#x26; lines[0].indexOf(&#x27;=&#x27;)) {
                      result.main = parseFloat(lines[0].split(&#x22;=&#x22;)[1]);
                      result.max = result.main
                    }
                  }
                  if (callback) { callback(result) }
                  resolve(result);
                });
              }
            });

          }
        });
      }
      if (_darwin) {
        let smc = require(&#x27;../build/Release/smc&#x27;);

        let cores = [&#x27;TC0P&#x27;, &#x27;TC1C&#x27;, &#x27;TC2C&#x27;, &#x27;TC3C&#x27;, &#x27;TC4C&#x27;, &#x27;TC5C&#x27;, &#x27;TC6C&#x27;, &#x27;TC7C&#x27;, &#x27;TC8C&#x27;];
        let sum = 0;
        let id = 0;
        cores.forEach(function(key) {
          let value = smc.get(key);
          if (id == 0) {
            if (value &#x3e; 0) {
              result.main = value;
              result.max = value;
            }
            id = 1;
          } else {
            if (value &#x3e; 0) {
              result.cores.push(value);
              sum = sum + value;
              if (value &#x3e; result.max) result.max = value;
            }
          }
        });
        if (result.cores.length) {
          result.main = sum / result.cores.length;
        }

        if (callback) { callback(result) }
        resolve(result);
      }
      if (_windows) {
        exec(&#x22;wmic /namespace:\\\\root\\wmi PATH MSAcpi_ThermalZoneTemperature get CriticalTripPoint,CurrentTemperature /value&#x22;,
function (error, stdout) {
          if (!error) {
            let sum = 0;
            let lines = stdout.trim().split(/\s\s+/);
            lines.forEach(function (line) {
              if (line.match(&#x27;CriticalTripPoint&#x27;) &#x26;&#x26; !result.max)
                result.max = (parseInt(line.split(&#x27;CriticalTripPoint=&#x27;)[1]) - 2732) / 10;
              else if (line.match(&#x27;CurrentTemperature&#x27;)) {
                let value = (parseInt(line.split(&#x27;CurrentTemperature=&#x27;)[1]) - 2732) / 10;
                sum = sum + value;
                result.cores.push(value);
              }
            });
            if (result.cores.length) {
              result.main = sum / result.cores.length;
            }
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - l1i | X | X |  | L1I size |
| - l2 | X | X |  | L2 size |
| - l3 | X | X |  | L3 size |
| si.cpuCurrentspeed(cb) | X | X |  | current CPU speed (in GHz)|
| - avg | X | X |  | avg CPU speed (all cores) |
| - min | X | X |  | min CPU speed (all cores) |
| - max | X | X |  | max CPU speed (all cores) |
| si.<span class="apidocCodeKeywordSpan">cpuTemperature</span>(cb) | X | X | X | CPU temperature (if sensors is installed) |
| - main | X | X | X | main temperature |
| - cores | X | X | X | array of temperatures |
| - max | X | X | X | max temperature |
| si.mem(cb) | X | X | X | Memory information|
| - total | X | X | X | total memory |
| - free | X | X | X | not used |
| - used | X | X | X | used (incl. buffers/cache) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu.currentLoad" id="apidoc.element.systeminformation.cpu.currentLoad">
        function <span class="apidocSignatureSpan">systeminformation.cpu.</span>currentLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function currentLoad(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      getLoad().then(result =&#x3e; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkConnections(cb) | X | X |  | current network network connections&#x3c;br&#x3e;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.<span class="apidocCodeKeywordSpan">currentLoad</span>(cb) | X | X |  | CPU-Load |
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.cpu.fullLoad" id="apidoc.element.systeminformation.cpu.fullLoad">
        function <span class="apidocSignatureSpan">systeminformation.cpu.</span>fullLoad
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fullLoad(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      getFullLoad().then(result =&#x3e; {
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - avgload | X | X |  | average load  |
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.<span class="apidocCodeKeywordSpan">fullLoad</span>(cb) | X | X |  | CPU-full load since bootup in % |
| si.services(&#x27;mysql, apache2&#x27;, cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.docker" id="apidoc.module.systeminformation.docker">module systeminformation.docker</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerAll" id="apidoc.element.systeminformation.docker.dockerAll">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerAll
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerAll(callback) {
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      dockerContainers(true).then(result =&#x3e; {
        if (result &#x26;&#x26; Object.prototype.toString.call(result) === &#x27;[object Array]&#x27; &#x26;&#x26; result.length &#x3e; 0) {
          let l = result.length;
          result.forEach(function (element) {
            dockerContainerStats(element.id).then(res =&#x3e; {
              // include stats in array
              element.mem_usage = res.mem_usage;
              element.mem_limit = res.mem_limit;
              element.mem_percent = res.mem_percent;
              element.cpu_percent = res.cpu_percent;
              element.pids = res.pids;
              element.netIO = res.netIO;
              element.blockIO = res.blockIO;
              element.cpu_stats = res.cpu_stats;
              element.precpu_stats = res.precpu_stats;
              element.memory_stats = res.memory_stats;
              element.networks = res.networks;

              dockerContainerProcesses(element.id).then(processes =&#x3e; {
                element.processes = processes;

                l -= 1;
                if (l == 0) {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
              // all done??
            })
          })
        } else {
          if (callback) { callback(result) }
          resolve(result);
        }
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].stat | X | X |  | process state |
| - [0].time | X | X |  | accumulated CPU time |
| - [0].elapsed | X | X |  | elapsed running time |
| - [0].nice | X | X |  | nice value |
| - [0].rss | X | X |  | resident set size |
| - [0].vsz | X | X |  | virtual size in Kbytes |
| - [0].command | X | X |  | command and arguments |
| si.<span class="apidocCodeKeywordSpan">dockerAll</span>(cb) | X | X |  | list of all containers including their stats&#x3c;br&#
x3e;and processes in one single array |
| si.getStaticData(cb)  | X | X |  | all static data at once |
| si.getDynamicData(srv,iface,cb) | X | X |  | all dynamic data at once |
| si.getAllData(srv,iface,cb) | X | X |  | all data at once |

### cb: Asynchronous Function Calls (callback)

Remember: all functions (except `version` and `time`) are implemented as asynchronous functions! There are now two ways to consume
 them:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerContainerProcesses" id="apidoc.element.systeminformation.docker.dockerContainerProcesses">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerProcesses
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerProcesses(containerID, callback) {
  containerID = containerID || &#x27;&#x27;;
  let result = [];
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getProcesses(containerID, data =&#x3e; {
<span class="apidocCodeCommentSpan">          /**
           * @namespace
           * @property {Array}  Titles
           * @property {Array}  Processes
           **/
</span>           try {
            if (data &#x26;&#x26; data.Titles &#x26;&#x26; data.Processes) {
              let titles = data.Titles.map(function(value) {
                return value.toUpperCase();
              });
              let pos_pid = titles.indexOf(&#x27;PID&#x27;);
              let pos_ppid = titles.indexOf(&#x27;PPID&#x27;);
              let pos_pgid = titles.indexOf(&#x27;PGID&#x27;);
              let pos_vsz = titles.indexOf(&#x27;VSZ&#x27;);
              let pos_time = titles.indexOf(&#x27;TIME&#x27;);
              let pos_elapsed = titles.indexOf(&#x27;ELAPSED&#x27;);
              let pos_ni = titles.indexOf(&#x27;NI&#x27;);
              let pos_ruser = titles.indexOf(&#x27;RUSER&#x27;);
              let pos_user = titles.indexOf(&#x27;USER&#x27;);
              let pos_rgroup = titles.indexOf(&#x27;RGROUP&#x27;);
              let pos_group = titles.indexOf(&#x27;GROUP&#x27;);
              let pos_stat = titles.indexOf(&#x27;STAT&#x27;);
              let pos_rss = titles.indexOf(&#x27;RSS&#x27;);
              let pos_command = titles.indexOf(&#x27;COMMAND&#x27;);

              data.Processes.forEach(process =&#x3e; {
                result.push({
                  pid_host: (pos_pid &#x3e;= 0 ? process[pos_pid] : &#x27;&#x27;),
                  ppid: (pos_ppid &#x3e;= 0 ? process[pos_ppid] : &#x27;&#x27;),
                  pgid: (pos_pgid &#x3e;= 0 ? process[pos_pgid] : &#x27;&#x27;),
                  user: (pos_user &#x3e;= 0 ? process[pos_user] : &#x27;&#x27;),
                  ruser: (pos_ruser &#x3e;= 0 ? process[pos_ruser] : &#x27;&#x27;),
                  group: (pos_group &#x3e;= 0 ? process[pos_group] : &#x27;&#x27;),
                  rgroup: (pos_rgroup &#x3e;= 0 ? process[pos_rgroup] : &#x27;&#x27;),
                  stat: (pos_stat &#x3e;= 0 ? process[pos_stat] : &#x27;&#x27;),
                  time: (pos_time &#x3e;= 0 ? process[pos_time] : &#x27;&#x27;),
                  elapsed: (pos_elapsed &#x3e;= 0 ? process[pos_elapsed] : &#x27;&#x27;),
                  nice: (pos_ni &#x3e;= 0 ? process[pos_ni] : &#x27;&#x27;),
                  rss: (pos_rss &#x3e;= 0 ? process[pos_rss] : &#x27;&#x27;),
                  vsz: (pos_vsz &#x3e;= 0 ? process[pos_vsz] : &#x27;&#x27;),
                  command: (pos_command &#x3e;= 0 ? process[pos_command] : &#x27;&#x27;)
                })
              })
            }
          } catch (err) {
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - netIO.wx | X | X |  | sent bytes via network |
| - blockIO.r | X | X |  | bytes read from BlockIO |
| - blockIO.w | X | X |  | bytes written to BlockIO |
| - cpu_stats | X | X |  | detailed cpu stats |
| - percpu_stats | X | X |  | detailed per cpu stats |
| - memory_stats | X | X |  | detailed memory stats |
| - networks | X | X |  | detailed network stats per interface |
| si.<span class="apidocCodeKeywordSpan">dockerContainerProcesses</span>(id, cb) | X | X |  | array of processes inside a container
 |
| - [0].pid_host | X | X |  | process ID (host) |
| - [0].ppid | X | X |  | parent process ID |
| - [0].pgid | X | X |  | process group ID |
| - [0].user | X | X |  | effective user name |
| - [0].ruser | X | X |  | real user name |
| - [0].group | X | X |  | effective group name |
| - [0].rgroup | X | X |  | real group name |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerContainerStats" id="apidoc.element.systeminformation.docker.dockerContainerStats">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainerStats
        <span class="apidocSignatureSpan">(containerID, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainerStats(containerID, callback) {
  containerID = containerID || &#x27;&#x27;;
  let result = {
    id: containerID,
    mem_usage: 0,
    mem_limit: 0,
    mem_percent: 0,
    cpu_percent: 0,
    pids: 0,
    netIO: {
      rx: 0,
      wx: 0
    },
    blockIO: {
      r: 0,
      w: 0
    }
  };
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }
      if (containerID) {

        if (!_docker_socket) {
          _docker_socket = new DockerSocket();
        }

        _docker_socket.getStats(containerID, data =&#x3e; {
          // let cmd = &#x22;curl --unix-socket /var/run/docker.sock http:/containers/&#x22; + containerID + &#x22;/stats?stream=0&#x22;;
          // exec(cmd, function (error, stdout) {
          //   if (!error) {
          //     let jsonString = stdout.toString();
          try {
//              let stats = JSON.parse(jsonString);
            let stats = data;
<span class="apidocCodeCommentSpan">            /**
             * @namespace
             * @property {Object}  memory_stats
             * @property {number}  memory_stats.usage
             * @property {number}  memory_stats.limit
             * @property {Object}  cpu_stats
             * @property {Object}  pids_stats
             * @property {number}  pids_stats.current
             * @property {Object}  networks
             * @property {Object}  blkio_stats
             */
</span>
            if (!stats.message) {
              result.mem_usage = (stats.memory_stats &#x26;&#x26; stats.memory_stats.usage ? stats.memory_stats.usage : 0);
              result.mem_limit = (stats.memory_stats &#x26;&#x26; stats.memory_stats.limit ? stats.memory_stats.limit : 0);
              result.mem_percent = (stats.memory_stats &#x26;&#x26; stats.memory_stats.usage &#x26;&#x26; stats.memory_stats.limit ? stats.memory_stats
.usage / stats.memory_stats.limit * 100.0 : 0);
              result.cpu_percent = (stats.cpu_stats ? docker_calcCPUPercent(stats.cpu_stats, containerID) : 0);
              result.pids = (stats.pids_stats &#x26;&#x26; stats.pids_stats.current ? stats.pids_stats.current : 0);
              if (stats.networks) result.netIO = docker_calcNetworkIO(stats.networks);
              if (stats.blkio_stats) result.blockIO = docker_calcBlockIO(stats.blkio_stats);
              result.cpu_stats = (stats.cpu_stats ? stats.cpu_stats : {});
              result.precpu_stats = (stats.precpu_stats ? stats.precpu_stats : {});
              result.memory_stats = (stats.memory_stats ? stats.memory_stats : {});
              result.networks = (stats.networks ? stats.networks : {});
            }
          } catch (err) {
          }
          // }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
| - [0].ports | X | X |  | array of ports |
| - [0].mounts | X | X |  | array of mounts |
| si.<span class="apidocCodeKeywordSpan">dockerContainerStats</span>(id, cb) | X | X |  | statistics for a specific container |
| - id | X | X |  | Container ID |
| - mem_usage | X | X |  | memory usage in bytes |
| - mem_limit | X | X |  | memory limit (max mem) in bytes |
| - mem_percent | X | X |  | memory usage in percent |
| - cpu_percent | X | X |  | cpu usage in percent |
| - pids | X | X |  | number of processes |
| - netIO.rx | X | X |  | received bytes via network |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.docker.dockerContainers" id="apidoc.element.systeminformation.docker.dockerContainers">
        function <span class="apidocSignatureSpan">systeminformation.docker.</span>dockerContainers
        <span class="apidocSignatureSpan">(all, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dockerContainers(all, callback) {

  function inContainers(containers, id) {
    let filtered = containers.filter(obj =&#x3e; {
<span class="apidocCodeCommentSpan">      /**
       * @namespace
       * @property {string}  Id
       */
</span>      return (obj.Id &#x26;&#x26; (obj.Id == id))
    });
    return (filtered.length &#x3e; 0);
  }

  // fallback - if only callback is given
  if (util.isFunction(all) &#x26;&#x26; !callback) {
    callback = all;
    all = false;
  }

  all = all || false;
  let result = [];
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      if (!_docker_socket) {
        _docker_socket = new DockerSocket();
      }

      _docker_socket.listContainers(all, data =&#x3e; {
        let docker_containers = {};
        // let cmd = &#x22;curl --unix-socket /var/run/docker.sock http:/containers/json&#x22; + (all ? &#x22;?all=1&#x22; : &#x22;&#x22;);
        // exec(cmd, function (error, stdout) {
        //   if (!error) {
        try {
          //       let jsonString = stdout.toString();
          //       let docker_containers = JSON.parse(jsonString);
          docker_containers = data;
          if (docker_containers &#x26;&#x26; Object.prototype.toString.call(docker_containers) === &#x27;[object Array]&#x27; &#x26;&#x26; docker_containers.length
 &#x3e; 0) {
            docker_containers.forEach(function (element) {
              /**
               * @namespace
               * @property {string}  Id
               * @property {string}  Name
               * @property {string}  Image
               * @property {string}  ImageID
               * @property {string}  Command
               * @property {number}  Created
               * @property {string}  State
               * @property {Array}  Names
               * @property {Array}  Ports
               * @property {Array}  Mounts
               */

              if (element.Names &#x26;&#x26; Object.prototype.toString.call(element.Names) === &#x27;[object Array]&#x27; &#x26;&#x26; element.Names.length &#x3e;
0) {
                element.Name = element.Names[0].replace(/^\/|\/$/g, &#x27;&#x27;);
              }
              result.push({
                id: element.Id,
                name: element.Name,
                image: element.Image,
                imageID: element.ImageID,
                command: element.Command,
                created: element.Created,
                state: element.State,
                ports: element.Ports,
                mounts: element.Mounts,
                // hostconfig: element.HostConfig,
                // network: element.NetworkSettings
              })
            });
          }
        } catch (err) {
        }
        // }

        // GC in _docker_container_stats
        for (let key in _docker_container_stats) {
          if (_docker_container_stats.hasOwnProperty(key)) {
            if (!inContainers(docker_containers, key)) delete _docker_container_stats[key];
          }
        }
        if (callback) { callback(result) }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&#x3c;br&#x3e;host parameter is optional (default
 8.8.8.8)|
| si.<span class="apidocCodeKeywordSpan">dockerContainers</span>(all, cb) | X | X |  | returns array of active/all docker containers
 |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
| - [0].state | X | X |  | created, running, exited |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.filesystem" id="apidoc.module.systeminformation.filesystem">module systeminformation.filesystem</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.blockDevices" id="apidoc.element.systeminformation.filesystem.blockDevices">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>blockDevices
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function blockDevices(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_linux) {
        // see https://wiki.ubuntuusers.de/lsblk/
        // exec(&#x22;lsblk -bo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,TRAN,SERIAL,LABEL,MODEL,OWNER,GROUP,MODE,ALIGNMENT,MIN-
IO,OPT-IO,PHY-SEC,LOG-SEC,SCHED,RQ-SIZE,RA,WSAME&#x22;, function (error, stdout) {
        exec(&#x22;lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER&#x22;, function (error, stdout
) {
          let data = [];
          if (!error) {
            let lines = blkStdoutToObject(stdout).split(&#x27;\n&#x27;);
            data = parseBlk(lines);
            if (callback) {
              callback(data)
            }
            resolve(data);
          } else {
            exec(&#x22;lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER&#x22;, function (error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split(&#x27;\n&#x27;);
                data = parseBlk(lines);
              }
              if (callback) {
                callback(data)
              }
              resolve(data);
            });
          }
        });
      }
      if (_darwin) {
        exec(&#x22;diskutil info -all&#x22;, function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            // parse lines into temp array of devices
            data = parseDevices(lines);
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec(&#x27;wmic logicaldisk get Caption,Description,DeviceID,DriveType,FileSystem,FreeSpace,Name,Size,VolumeName,VolumeSerialNumber
 /format:csv&#x27;, function (error, stdout) {
          if (!error) {
            let lines = stdout.split(&#x27;\r\n&#x27;).filter(line =&#x3e; line.trim() != &#x27;&#x27;).filter((line, idx) =&#x3e; idx &#x3e; 0);
            lines.forEach(function (line) {
              if (line != &#x27;&#x27;) {
                line = line.replace(&#x27;\r&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;);
                data.push({
                  name: line[7],
                  identifier: line[1],
                  type: &#x27;disk&#x27;,
                  fstype: line[5].toLowerCase(),
                  mount: line[1],
                  size: line[8],
                  physical: line[4] == &#x27;5&#x27; ? &#x27;CD/DVD&#x27; : &#x27;HDD&#x27;,
                  uuid: line[10],
                  label: line[9],
                  model: &#x27;&#x27;,
                  serial: line[10],
                  removable: line[4] == &#x27;2&#x27;,
                  protocol: &#x27;&#x27;
                });
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.fsSize(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.<span class="apidocCodeKeywordSpan">blockDevices</span>(cb) | X | X | X | returns array of disks, partitions,&#x3c;br&#x3e;
raids and roms |
| - [0].name | X | X | X | name |
| - [0].type | X | X | X | type |
| - [0].fstype | X | X | X | file system type (e.g. ext4) |
| - [0].mount | X | X | X | mount point |
| - [0].size | X | X | X | size in bytes |
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.disksIO" id="apidoc.element.systeminformation.filesystem.disksIO">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>disksIO
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function disksIO(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: -1,
        wIO_sec: -1,
        tIO_sec: -1,
        ms: 0
      };
      let rIO = 0;
      let wIO = 0;

      if ((_disk_io &#x26;&#x26; !_disk_io.ms) || (_disk_io &#x26;&#x26; _disk_io.ms &#x26;&#x26; Date.now() - _disk_io.ms &#x3e;= 500)) {
        if (_linux) {
          // prints Block layer statistics for all mounted volumes
          // var cmd = &#x22;for mount in `lsblk | grep / | sed -r &#x27;s/â ââ//&#x27; | cut -d &#x27; &#x27; -f 1`; do cat /sys/block/$mount/stat | sed
 -r &#x27;s/ +/;/g&#x27; | sed -r &#x27;s/^;//&#x27;; done&#x22;;
          // var cmd = &#x22;for mount in `lsblk | grep / | sed &#x27;s/[ââââ]//g&#x27; | awk &#x27;{$1=$1};1&#x27; | cut -d &#x27; &#x27; -f 1 | sort -u`; do cat /
sys/block/$mount/stat | sed -r &#x27;s/ +/;/g&#x27; | sed -r &#x27;s/^;//&#x27;; done&#x22;;
          let cmd = &#x22;for mount in `lsblk | grep &#x27; disk &#x27; | sed &#x27;s/[ââââ]//g&#x27; | awk &#x27;{$1=$1};1&#x27; | cut -d &#x27; &#x27; -f 1 | sort -u`; do
cat /sys/block/$mount/stat | sed -r &#x27;s/ +/;/g&#x27; | sed -r &#x27;s/^;//&#x27;; done&#x22;;

          exec(cmd, function (error, stdout) {
            if (!error) {
              let lines = stdout.split(&#x27;\n&#x27;);
              lines.forEach(function (line) {
                // ignore empty lines
                if (!line) return;

                // sum r/wIO of all disks to compute all disks IO
                let stats = line.split(&#x27;;&#x27;);
                rIO += parseInt(stats[0]);
                wIO += parseInt(stats[4]);
              });
              result = calcDiskIO(rIO, wIO);

              if (callback) {
                callback(result)
              }
              resolve(result);
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          });
        }
        if (_darwin) {
          exec(&#x22;ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n &#x27;/IOBlockStorageDriver/,/Statistics/p&#x27; | grep &#x27;Statistics
&#x27; | tr -cd &#x27;01234567890,\n&#x27; | awk -F&#x27;,&#x27; &#x27;{print $1, $11}&#x27;&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              lines.forEach(function (line) {
                line = line.trim();
                if (line != &#x27;&#x27;) {
                  line = line.split(&#x27; &#x27;);

                  rIO += parseInt(line[1]);
                  wIO += parseInt(line[0]);
                }
              });
              result = calcDiskIO(rIO, wIO);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.rIO = _disk_io.rIO;
        result.wIO = _disk_io.wIO;
        result.tIO = _disk_io.rIO + _disk_io.wIO;
        result.ms = _disk_io.last_ms;
        result.rIO_sec = _disk_io.rIO_sec;
        result.wIO_sec = _disk_io.wIO_sec;
        result.tIO_sec = _disk_io.tIO_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">disksIO</span>(cb) | X | X |  | current transfer stats |
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.fsSize" id="apidoc.element.systeminformation.filesystem.fsSize">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsSize
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsSize(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_linux || _darwin) {
        let cmd = (_darwin ? &#x22;df -lkP | grep ^/&#x22; : &#x22;df -lkPT | grep ^/&#x22;);
        exec(cmd, function (error, stdout) {
          let data = [];
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            //lines.splice(0, 1);
            lines.forEach(function (line) {
              if (line != &#x27;&#x27;) {
                line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
                data.push({
                  &#x27;fs&#x27;: line[0],
                  &#x27;type&#x27;: (_linux ? line[1] : &#x27;HFS&#x27;),
                  &#x27;size&#x27;: parseInt((_linux ? line[2] : line[1])) * 1024,
                  &#x27;used&#x27;: parseInt((_linux ? line[3] : line[2])) * 1024,
                  &#x27;use&#x27;: parseFloat((100.0 * (_linux ? line[3] : line[2]) / (_linux ? line[2] : line[1])).toFixed(2)),
                  &#x27;mount&#x27;: line[line.length - 1]
                })
              }
            });
          }
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
      if (_windows) {
        exec(&#x27;wmic logicaldisk get Caption,FileSystem,FreeSpace,Size&#x27;, function (error, stdout) {
          let lines = stdout.split(&#x27;\r\n&#x27;).filter(line =&#x3e; line.trim() != &#x27;&#x27;).filter((line, idx) =&#x3e; idx &#x3e; 0);
          lines.forEach(function (line) {
            if (line != &#x27;&#x27;) {
              line = line.trim().split(/\s\s+/);
              data.push({
                &#x27;fs&#x27;: line[0],
                &#x27;type&#x27;: line[1],
                &#x27;size&#x27;: line[3],
                &#x27;used&#x27;: parseInt(line[3]) - parseInt(line[2]),
                &#x27;use&#x27;: parseFloat((100.0 * (parseInt(line[3]) - parseInt(line[2]))) / parseInt(line[3])),
                &#x27;mount&#x27;: line[0]
              })
            }
          });
          if (callback) {
            callback(data)
          }
          resolve(data);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - displays[0].builtin | X | X |  | true if built in monitor |
| - displays[0].connection | X | X |  | e.g. DisplayPort or HDMI |
| - displays[0].resolutionx | X | X |  | pixel horizontal |
| - displays[0].resolutiony | X | X |  | pixel vertical |
| - displays[0].depth | X | X |  | color depth in bits |
| - displays[0].sizex | X | X |  | size in mm horizontal |
| - displays[0].sizey | X | X |  | size in mm vertical |
| si.<span class="apidocCodeKeywordSpan">fsSize</span>(cb) | X | X | X | returns array of mounted file systems |
| - [0].fs | X | X | X | name of file system |
| - [0].type | X | X | X | type of file system |
| - [0].size | X | X | X | sizes in Bytes |
| - [0].used | X | X | X | used in Bytes |
| - [0].use | X | X | X | used in % |
| - [0].mount | X | X | X | mount point |
| si.blockDevices(cb) | X | X | X | returns array of disks, partitions,&#x3c;br&#x3e;raids and roms |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.filesystem.fsStats" id="apidoc.element.systeminformation.filesystem.fsStats">
        function <span class="apidocSignatureSpan">systeminformation.filesystem.</span>fsStats
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fsStats(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: -1,
        wx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let rx = 0;
      let wx = 0;
      if ((_fs_speed &#x26;&#x26; !_fs_speed.ms) || (_fs_speed &#x26;&#x26; _fs_speed.ms &#x26;&#x26; Date.now() - _fs_speed.ms &#x3e;= 500)) {
        if (_linux) {
//  		  exec(&#x22;df -k | grep /dev/&#x22;, function(error, stdout) {
          exec(&#x22;lsblk | grep /&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              let fs_filter = [];
              lines.forEach(function (line) {
                if (line != &#x27;&#x27;) {
                  line = line.replace(/[ââââ]+/g, &#x22;&#x22;).trim().split(&#x27; &#x27;);
                  if (fs_filter.indexOf(line[0]) == -1) fs_filter.push(line[0])
                }
              });

              let output = fs_filter.join(&#x27;|&#x27;);
              exec(&#x22;cat /proc/diskstats | egrep &#x27;&#x22; + output + &#x22;&#x27;&#x22;, function (error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split(&#x27;\n&#x27;);
                  lines.forEach(function (line) {
                    line = line.trim();
                    if (line != &#x27;&#x27;) {
                      line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);

                      rx += parseInt(line[5]) * 512;
                      wx += parseInt(line[9]) * 512;
                    }
                  });
                  result = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result)
                }
                resolve(result);
              })
            } else {
              if (callback) {
                callback(result)
              }
              resolve(result);
            }
          })
        }
        if (_darwin) {
          exec(&#x22;ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n &#x27;/IOBlockStorageDriver/,/Statistics/p&#x27; | grep &#x27;Statistics
&#x27; | tr -cd &#x27;01234567890,\n&#x27; | awk -F&#x27;,&#x27; &#x27;{print $3, $10}&#x27;&#x22;, function (error, stdout) {
            if (!error) {
              let lines = stdout.toString().split(&#x27;\n&#x27;);
              lines.forEach(function (line) {
                line = line.trim();
                if (line != &#x27;&#x27;) {
                  line = line.split(&#x27; &#x27;);

                  rx += parseInt(line[0]);
                  wx += parseInt(line[1]);
                }
              });
              result = calcFsSpeed(rx, wx);
            }
            if (callback) {
              callback(result)
            }
            resolve(result);
          })
        }
      } else {
        result.ms = _fs_speed.last_ms;
        result.rx = _fs_speed.bytes_read;
        result.wx = _fs_speed.bytes_write;
        result.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
        result.rx_sec = _fs_speed.rx_sec;
        result.wx_sec = _fs_speed.wx_sec;
        result.tx_sec = _fs_speed.tx_sec;
        if (callback) {
          callback(result)
        }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].physical | X | X | X | physical type (HDD, SSD, CD/DVD) |
| - [0].uuid | X | X | X | UUID |
| - [0].label | X | X | X | label |
| - [0].model | X | X |  | model |
| - [0].serial | X |  | X | serial |
| - [0].removable | X | X | X | serial |
| - [0].protocol | X | X |  | protocol (SATA, PCI-Express, ...) |
| si.<span class="apidocCodeKeywordSpan">fsStats</span>(cb) | X | X |  | current transfer stats |
| - rx | X | X |  | bytes read since startup |
| - wx | X | X |  | bytes written since startup |
| - tx | X | X |  | total bytes read + written since startup |
| - rx_sec | X | X |  | bytes read / second (* see notes) |
| - wx_sec | X | X |  | bytes written / second (* see notes) |
| - tx_sec | X | X |  | total bytes reads + written / second  |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.graphics" id="apidoc.module.systeminformation.graphics">module systeminformation.graphics</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.graphics.graphics" id="apidoc.element.systeminformation.graphics.graphics">
        function <span class="apidocSignatureSpan">systeminformation.</span>graphics
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function graphics(callback) {

  function parseLinesDarwin(lines) {
    let starts = [];
    let level = -1;
    let lastlevel = -1;
    let controllers = [];
    let displays = [];
    let currentController = {};
    let currentDisplay = {};
    for (let i = 0; i &#x3c; lines.length; i++) {
      if (&#x27;&#x27; != lines[i].trim()) {
        let start = lines[i].search(/\S|$/);
        if (-1 == starts.indexOf(start)) {
          starts.push(start);
        }
        level = starts.indexOf(start);
        if (level &#x3c; lastlevel) {
          if (Object.keys(currentController).length &#x3e; 0) {// just changed to Displays
            controllers.push(currentController);
            currentController = {};
          }
          if (Object.keys(currentDisplay).length &#x3e; 0) {// just changed to Displays
            displays.push(currentDisplay);
            currentDisplay = {};
          }
        }
        lastlevel = level;
        let parts = lines[i].split(&#x27;:&#x27;);
        if (2 == level) {       // grafics controller level
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;chipsetmodel&#x27;) != -1) currentController.model
 = parts[1].trim();
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;bus&#x27;) != -1) currentController.bus = parts[
1].trim();
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;vendor&#x27;) != -1) currentController.vendor =
parts[1].split(&#x27;(&#x27;)[0].trim();
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;vram(total)&#x27;) != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = false;
          }
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;vram(dynamic,max)&#x27;) != -1) {
            currentController.vram = parseInt(parts[1]);    // in MB
            currentController.vramDynamic = true;
          }
        }
        if (3 == level) {       // display controller level
          if (parts.length &#x3e; 1 &#x26;&#x26; &#x27;&#x27; == parts[1]) {
            currentDisplay.model = parts[0].trim();
            currentDisplay.main = false;
            currentDisplay.builtin = false;
            currentDisplay.connection = &#x27;&#x27;;
            currentDisplay.sizex = -1;
            currentDisplay.sizey = -1;
          }
        }
        if (4 == level) {       // display controller details level
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;resolution&#x27;) != -1) {
            let resolution = parts[1].split(&#x27;x&#x27;);
            currentDisplay.resolutionx = (resolution.length &#x3e; 1 ? parseInt(resolution[0]) : 0);
            currentDisplay.resolutiony = (resolution.length &#x3e; 1 ? parseInt(resolution[1]) : 0);
          }
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;pixeldepth&#x27;) != -1) currentDisplay.pixeldepth
 = parseInt(parts[1]); // in BIT
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;maindisplay&#x27;) != -1 &#x26;&#x26; parts[1].replace(/ +/
g, &#x22;&#x22;).toLowerCase() == &#x27;yes&#x27;) currentDisplay.main = true;
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;built-in&#x27;) != -1 &#x26;&#x26; parts[1].replace(/ +/g, &#x22;&#x22;).
toLowerCase() == &#x27;yes&#x27;) {
            currentDisplay.builtin = true;
            currentDisplay.connection = &#x27;&#x27;;
          }
          if (parts.length &#x3e; 1 &#x26;&#x26; parts[0].replace(/ +/g, &#x22;&#x22;).toLowerCase().indexOf(&#x27;connectiontype&#x27;) != -1) {
            currentDisplay.builtin = false;
            currentDisplay.connection = parts[1].trim();
          }
        }
      }
    }
    if (Object.keys(currentController).length &#x3e; 0) {// just changed to Displays
      controllers.push(currentController);
    }
    if (Object.keys(currentDisplay).length &#x3e; 0) {// just changed to Displays
      displays.push(currentDisplay);
    }
    return ({
      controllers: controllers,
      displays: displays
    })
  }

  function parseLinesLinuxControllers(lines) {
    let controllers = [];
    let currentController = {};
    let is_vga = ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - swapfree | X | X |  |  |
| si.battery(cb) | X | X |  | battery information |
| - hasbattery | X | X |  | indicates presence of battery |
| - ischarging | X | X |  | indicates if battery is charging |
| - maxcapacity | X | X |  | max capacity of battery |
| - currentcapacity | X | X |  | current capacity of battery |
| - percent | X | X |  | charging level in percent |
| si.<span class="apidocCodeKeywordSpan">graphics</span>(cb) | X | X |  | arrays of graphics controllers and displays |
| - controllers[0].model | X | X |  | graphics controller model |
| - controllers[0].vendor | X | X |  | e.g. ATI |
| - controllers[0].bus | X | X |  | on which bus (e.g. PCIe) |
| - controllers[0].vram | X | X |  | VRAM size (in MB) |
| - controllers[0].vramDynamic | X | X |  | true if dynamicly allocated ram |
| - displays[0].model | X | X |  | Monitor/Display Model |
| - displays[0].main | X | X |  | true if main monitor |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.internet" id="apidoc.module.systeminformation.internet">module systeminformation.internet</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.internet.inetChecksite" id="apidoc.element.systeminformation.internet.inetChecksite">
        function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetChecksite
        <span class="apidocSignatureSpan">(url, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetChecksite(url, callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        url: url,
        ok: false,
        status: 404,
        ms: -1
      };
      if (url) {
        let t = Date.now();
        let args = &#x22; -I --connect-timeout 5 -m 5 &#x22; + url + &#x22; 2&#x3e;/dev/null | head -n 1 | cut -d &#x27; &#x27; -f2&#x22;;
        let cmd = &#x22;curl&#x22;;
        exec(cmd + args, function (error, stdout) {
          let statusCode = parseInt(stdout.toString());
          result.status = statusCode || 404;
          result.ok = !error &#x26;&#x26; (statusCode == 200 || statusCode == 301 || statusCode == 302 || statusCode == 304);
          result.ms = (result.ok ? Date.now() - t : -1);
          if (callback) { callback(result) }
          resolve(result);
        })
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.<span class="apidocCodeKeywordSpan">inetChecksite</span>(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.inetLatency(host, cb) | X | X |  | response-time (ms) to external resource&#x3c;br&#x3e;host parameter is optional (default
 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.internet.inetLatency" id="apidoc.element.systeminformation.internet.inetLatency">
        function <span class="apidocSignatureSpan">systeminformation.internet.</span>inetLatency
        <span class="apidocSignatureSpan">(host, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inetLatency(host, callback) {

  // fallback - if only callback is given
  if (util.isFunction(host) &#x26;&#x26; !callback) {
    callback = host;
    host = &#x27;&#x27;;
  }

  host = host || &#x27;8.8.8.8&#x27;;

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let t = Date.now();
      let cmd;
      if (_linux) {
        cmd = &#x22;ping -c 2 -w 3 &#x22; + host + &#x22; | grep rtt | cut -d&#x27;/&#x27; -f4 | awk &#x27;{ print $3 }&#x27;&#x22;;
      }
      if (_darwin) {
        cmd = &#x22;ping -c 2 -t 3 &#x22; + host + &#x22; | grep avg | cut -d&#x27;/&#x27; -f4 | awk &#x27;{ print $3 }&#x27;&#x22;;
      }

      exec(cmd, function (error, stdout) {
        let result = -1;
        if (!error) {
          result = parseFloat(stdout.toString());
        }
        if (callback) { callback(result) }
        resolve(result);
      })
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
| - url | X | X |  | given url |
| - ok | X | X |  | status code OK (2xx, 3xx) |
| - status | X | X |  | status code |
| - ms | X | X |  | response time in ms |
| si.<span class="apidocCodeKeywordSpan">inetLatency</span>(host, cb) | X | X |  | response-time (ms) to external resource&#x3c;
br&#x3e;host parameter is optional (default 8.8.8.8)|
| si.dockerContainers(all, cb) | X | X |  | returns array of active/all docker containers |
| - [0].id | X | X |  | ID of container |
| - [0].name | X | X |  | name of container |
| - [0].image | X | X |  | name of image |
| - [0].imageID | X | X |  | ID of image |
| - [0].command | X | X |  | command |
| - [0].created | X | X |  | creation time |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.network" id="apidoc.module.systeminformation.network">module systeminformation.network</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.network.getDefaultNetworkInterface" id="apidoc.element.systeminformation.network.getDefaultNetworkInterface">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>getDefaultNetworkInterface
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getDefaultNetworkInterface() {

  if (!_default_iface) {
    let ifacename = &#x27;&#x27;;
    let cmd = (_linux ? &#x22;route 2&#x3e;/dev/null | grep default | awk &#x27;{print $8}&#x27;&#x22; : &#x22;route get 0.0.0.0 2&#x3e;/dev/null | grep interface: |
awk &#x27;{print $2}&#x27;&#x22;);
    let result = execSync(cmd);
    ifacename = result.toString().split(&#x27;\n&#x27;)[0];

    if (!ifacename) {         // fallback - &#x22;first&#x22; external interface
      const sortObject = o =&#x3e; Object.keys(o).sort().reduce((r, k) =&#x3e; (r[k] = o[k], r), {});

      let ifaces = sortObject(os.networkInterfaces());

      for (let dev in ifaces) {
        if (ifaces.hasOwnProperty(dev)) {
          ifaces[dev].forEach(function (details) {
            if (details &#x26;&#x26; details.internal == false) {
              ifacename = ifacename || dev;
            }
          })
        }
      }
    }
    if (ifacename) _default_iface = ifacename;
  }
  return _default_iface;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkConnections" id="apidoc.element.systeminformation.network.networkConnections">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkConnections
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkConnections(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];
      if (_linux) {
        let cmd = &#x22;netstat -tuna | grep &#x27;ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN\\|VERBUNDEN&#x27;&#x22;;
        exec(cmd, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            lines.forEach(function (line) {
              line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
              if (line.length &#x3e;= 6) {
                let localip = line[3];
                let localport = &#x27;&#x27;;
                let localaddress = line[3].split(&#x27;:&#x27;);
                if (localaddress.length &#x3e; 1) {
                  localport = localaddress[localaddress.length - 1];
                  localaddress.pop();
                  localip = localaddress.join(&#x27;:&#x27;);
                }
                let peerip = line[4];
                let peerport = &#x27;&#x27;;
                let peeraddress = line[4].split(&#x27;:&#x27;);
                if (peeraddress.length &#x3e; 1) {
                  peerport = peeraddress[peeraddress.length - 1];
                  peeraddress.pop();
                  peerip = peeraddress.join(&#x27;:&#x27;);
                }
                let connstate = line[5];
                if (connstate == &#x27;VERBUNDEN&#x27;) connstate = &#x27;ESTABLISHED&#x27;;
                if (connstate) {
                  result.push({
                    protocol: line[0],
                    localaddress: localip,
                    localport: localport,
                    peeraddress: peerip,
                    peerport: peerport,
                    state: connstate
                  })
                }
              }
            });
            if (callback) {
              callback(result)
            }
            resolve(result);
          } else {
            cmd = &#x22;ss -tuna | grep &#x27;ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-
ACK\\|LISTEN\\|CLOSING&#x27;&#x22;;
            exec(cmd, function (error, stdout) {

              if (!error) {
                let lines = stdout.toString().split(&#x27;\n&#x27;);
                lines.forEach(function (line) {
                  line = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
                  if (line.length &#x3e;= 6) {
                    let localip = line[4];
                    let localport = &#x27;&#x27;;
                    let localaddress = line[4].split(&#x27;:&#x27;);
                    if (localaddress.length &#x3e; 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(&#x27;:&#x27;);
                    }
                    let peerip = line[5];
                    let peerport = &#x27;&#x27;;
                    let peeraddress = line[5].split(&#x27;:&#x27;);
                    if (peeraddress.length &#x3e; 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(&#x27;:&#x27;);
                    }
                    let connstate = line[1];
                    if (connstate == &#x27;ESTAB&#x27;) connstate = &#x27;ESTABLISHED&#x27;;
                    if (connstate == &#x27;TIME-WAIT&#x27;) connstate = &#x27;TIME_WAIT&#x27;;
                    if (connstate) {
                      result.push({
                        protocol: line[0],
                        localaddress: localip,
                        localport: localport,
                        peeraddress: peerip,
                        peerport: peerport,
                        state: connstate
                      })
                    }
                  }
                });
              }
              if (callback) {
                callback(result)
              }
              resolve(result);
            })
          }
        })
      }
      if (_darwin) {
        l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkConnections</span>(cb) | X | X |  | current network network connections&#x3c;br&#
x3e;returns an array of all connections|
| - [0].protocol | X | X |  | tcp or udp |
| - [0].localaddress | X | X |  | local address |
| - [0].localport | X | X |  | local port |
| - [0].peeraddress | X | X |  | peer address |
| - [0].peerport | X | X |  | peer port |
| - [0].state | X | X |  | like ESTABLISHED, TIME_WAIT, ... |
| si.currentLoad(cb) | X | X |  | CPU-Load |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkInterfaceDefault" id="apidoc.element.systeminformation.network.networkInterfaceDefault">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaceDefault
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaceDefault(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = getDefaultNetworkInterface();
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ms | X | X |  | interval length (for per second values) |
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.<span class="apidocCodeKeywordSpan">networkInterfaceDefault</span>(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&#x3c;br&#x3e;iface parameter is optional&#x3c;
br&#x3e;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkInterfaces" id="apidoc.element.systeminformation.network.networkInterfaces">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkInterfaces
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkInterfaces(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let ifaces = os.networkInterfaces();
      let result = [];

      for (let dev in ifaces) {
        let ip4 = &#x27;&#x27;;
        let ip6 = &#x27;&#x27;;
        let mac = &#x27;&#x27;;
        if (ifaces.hasOwnProperty(dev)) {
          ifaces[dev].forEach(function (details) {
            if (details.family == &#x27;IPv4&#x27;) {
              ip4 = details.address
            }
            if (details.family == &#x27;IPv6&#x27;) {
              ip6 = details.address
            }
            mac = details.mac
          });
          let internal = (ifaces[dev] &#x26;&#x26; ifaces[dev][0]) ? ifaces[dev][0].internal : null;
          result.push({ iface: dev, ip4: ip4, ip6: ip6, mac: mac, internal: internal })
        }
      }
      if (callback) { callback(result) }
      resolve(result);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - rIO | X | X |  | read IOs on all mounted drives |
| - wIO | X | X |  | write IOs on all mounted drives |
| - tIO | X | X |  | write IOs on all mounted drives |
| - rIO_sec | X | X |  | read IO per sec (* see notes) |
| - wIO_sec | X | X |  | write IO per sec (* see notes) |
| - tIO_sec | X | X |  | total IO per sec (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
| si.<span class="apidocCodeKeywordSpan">networkInterfaces</span>(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.networkStats(iface,cb) | X | X |  | current network stats of given interface&#x3c;br&#x3e;iface parameter is optional&#x3c;
br&#x3e;defaults to first external network interface|
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.network.networkStats" id="apidoc.element.systeminformation.network.networkStats">
        function <span class="apidocSignatureSpan">systeminformation.network.</span>networkStats
        <span class="apidocSignatureSpan">(iface, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function networkStats(iface, callback) {

  // fallback - if only callback is given
  if (util.isFunction(iface) &#x26;&#x26; !callback) {
    callback = iface;
    iface = &#x27;&#x27;;
  }

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      _default_iface = _default_iface || getDefaultNetworkInterface();
      iface = iface || _default_iface; // (_darwin ? &#x27;en0&#x27; : &#x27;eth0&#x27;);

      let result = {
        iface: iface,
        operstate: &#x27;unknown&#x27;,
        rx: 0,
        tx: 0,
        rx_sec: -1,
        tx_sec: -1,
        ms: 0
      };

      let operstate = &#x27;unknown&#x27;;
      let rx = 0;
      let tx = 0;

      let cmd, lines, stats;
      if (!_network[iface] || (_network[iface] &#x26;&#x26; !_network[iface].ms) || (_network[iface] &#x26;&#x26; _network[iface].ms &#x26;&#x26; Date.now() -
_network[iface].ms &#x3e;= 500)) {
        if (_linux) {
          if (fs.existsSync(&#x27;/sys/class/net/&#x27; + iface)) {
            cmd =
              &#x22;cat /sys/class/net/&#x22; + iface + &#x22;/operstate; &#x22; +
              &#x22;cat /sys/class/net/&#x22; + iface + &#x22;/statistics/rx_bytes; &#x22; +
              &#x22;cat /sys/class/net/&#x22; + iface + &#x22;/statistics/tx_bytes; &#x22;;
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split(&#x27;\n&#x27;);
                operstate = lines[0].trim();
                rx = parseInt(lines[1]);
                tx = parseInt(lines[2]);

                result = calcNetworkSpeed(iface, rx, tx, operstate);

              }
              if (callback) { callback(result) }
              resolve(result);
            });
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        }
        if (_darwin) {
          cmd = &#x22;ifconfig &#x22; + iface + &#x22; | grep &#x27;status&#x27;&#x22;;
          exec(cmd, function (error, stdout) {
            result.operstate = (stdout.toString().split(&#x27;:&#x27;)[1] || &#x27;&#x27;).trim();
            result.operstate = (result.operstate || &#x27;&#x27;).toLowerCase();
            result.operstate = (result.operstate == &#x27;active&#x27; ? &#x27;up&#x27; : (result.operstate == &#x27;inactive&#x27; ? &#x27;down&#x27; : &#x27;unknown&#x27;));
            cmd = &#x22;netstat -bI &#x22; + iface;
            exec(cmd, function (error, stdout) {
              if (!error) {
                lines = stdout.toString().split(&#x27;\n&#x27;);
                // if there is less than 2 lines, no information for this interface was found
                if (lines.length &#x3e; 1 &#x26;&#x26; lines[1].trim() != &#x27;&#x27;) {
                  // skip header line
                  // use the second line because it is tied to the NIC instead of the ipv4 or ipv6 address
                  stats = lines[1].replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
                  rx = parseInt(stats[6]);
                  tx = parseInt(stats[9]);

                  result = calcNetworkSpeed(iface, rx, tx, operstate);
                }
              }
              if (callback) { callback(result) }
              resolve(result);
            });
          });
        }
      } else {
        result.rx = _network[iface].rx;
        result.tx = _network[iface].tx;
        result.rx_sec = _network[iface].rx_sec;
        result.tx_sec = _network[iface].tx_sec;
        result.ms = _network[iface].last_ms;
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| si.networkInterfaces(cb) | X | X |  | array of network interfaces |
| - [0].iface | X | X |  | interface name |
| - [0].ip4 | X | X |  | ip4 address |
| - [0].ip6 | X | X |  | ip6 address |
| - [0].mac | X | X |  | MAC address |
| - [0].internal | X | X |  | true if internal interface |
| si.networkInterfaceDefault(cb) | X | X |  | get name of default network interface |
| si.<span class="apidocCodeKeywordSpan">networkStats</span>(iface,cb) | X | X |  | current network stats of given interface&#x3c
;br&#x3e;iface parameter is optional&#x3c;br&#x3e;defaults to first external network interface|
| - iface | X | X |  | interface |
| - operstate | X | X |  | up / down |
| - rx | X | X |  | received bytes overall |
| - tx | X | X |  | transferred bytes overall|
| - rx_sec | X | X |  | received bytes / second (* see notes) |
| - tx_sec | X | X |  | transferred bytes per second (* see notes) |
| - ms | X | X |  | interval length (for per second values) |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.osinfo" id="apidoc.module.systeminformation.osinfo">module systeminformation.osinfo</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.osInfo" id="apidoc.element.systeminformation.osinfo.osInfo">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>osInfo
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function osInfo(callback) {

  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = {

        platform: (_platform == &#x27;Windows_NT&#x27; ? &#x27;Windows&#x27; : _platform),
        distro: &#x27;unknown&#x27;,
        release: &#x27;unknown&#x27;,
        codename: &#x27;&#x27;,
        kernel: os.release(),
        arch: os.arch(),
        hostname: os.hostname(),
        logofile: &#x27;&#x27;
      };

      if (_linux) {

        exec(&#x22;cat /etc<span class="apidocCodeCommentSpan">/*-release&#x22;, function (error, stdout) {
          //if (!error) {
          /**
           * @namespace
           * @property {string}  DISTRIB_ID
           * @property {string}  NAME
           * @property {string}  DISTRIB_RELEASE
           * @property {string}  VERSION_ID
           * @property {string}  DISTRIB_CODENAME
           */
</span>          let release = {};
          let lines = stdout.toString().split(&#x27;\n&#x27;);
          lines.forEach(function (line) {
            if (line.indexOf(&#x27;=&#x27;) != -1) {
              release[line.split(&#x27;=&#x27;)[0].trim().toUpperCase()] = line.split(&#x27;=&#x27;)[1].trim();
            }
          });
          result.distro = (release.DISTRIB_ID || release.NAME || &#x27;unknown&#x27;).replace(/&#x22;/g, &#x27;&#x27;);
          result.logofile = getLogoFile(result.distro);
          result.release = (release.DISTRIB_RELEASE || release.VERSION_ID || &#x27;unknown&#x27;).replace(/&#x22;/g, &#x27;&#x27;);
          result.codename = (release.DISTRIB_CODENAME || &#x27;&#x27;).replace(/&#x22;/g, &#x27;&#x27;);
          //}
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_darwin) {
        exec(&#x22;sw_vers&#x22;, function (error, stdout) {
          let lines = stdout.toString().split(&#x27;\n&#x27;);
          lines.forEach(function (line) {
            if (line.indexOf(&#x27;ProductName&#x27;) != -1) {
              result.distro = line.split(&#x27;:&#x27;)[1].trim();
              result.logofile = getLogoFile(result.distro);
            }
            if (line.indexOf(&#x27;ProductVersion&#x27;) != -1) result.release = line.split(&#x27;:&#x27;)[1].trim();
          });
          if (callback) {
            callback(result)
          }
          resolve(result);
        })
      }
      if (_windows) {
        result.logofile = getLogoFile();
        result.release = result.kernel;
        exec(&#x22;wmic os get Caption&#x22;, function (error, stdout) {
          result.distro = result.codename = stdout.slice(stdout.indexOf(&#x27;\r\n&#x27;) + 2).trim();
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. &#x27;MSI&#x27; |
| - model | X | X | X | model/product e.g. &#x27;MS-7823&#x27; |
| - version | X | X | X | version e.g. &#x27;1.0&#x27; |
| - serial | X | X | X | serial number |
| - uuid | X | X | X | UUID |
| si.<span class="apidocCodeKeywordSpan">osInfo</span>(cb) | X | X | X | OS information |
| - platform   | X | X | X | &#x27;Linux&#x27;, &#x27;Darwin&#x27;, &#x27;Windows&#x27; |
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.shell" id="apidoc.element.systeminformation.osinfo.shell">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>shell
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function shell(callback) {
  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) {
          callback(NOT_SUPPORTED)
        }
        reject(error);
      }

      let result = &#x27;&#x27;;
      exec(&#x22;echo $SHELL&#x22;, function (error, stdout) {
        if (!error) {
          result = stdout.toString().split(&#x27;\n&#x27;)[0];
        }
        if (callback) {
          callback(result)
        }
        resolve(result);
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. &#x27;apple&#x27;, &#x27;debian&#x27;, &#x27;fedora&#x27;, ... |
| si.versions(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.<span class="apidocCodeKeywordSpan">shell</span>(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
| si.cpuCache(cb) | X | X |  | CPU cache sizes |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.time" id="apidoc.element.systeminformation.osinfo.time">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>time
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function time() {
  return {
    current: Date.now(),
    uptime: os.uptime()
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
12. GetAll

### Function Reference and OS Support

| Function        | Linux | OSX | Win | Comments |
| --------------- | ----- | ---- | ------- | -------- |
| si.version() | X | X | X | library version (no callback/promise) |
| si.<span class="apidocCodeKeywordSpan">time</span>() | X | X | X | time information (no callback/promise) |
| - current | X | X | X | local time |
| - uptime | X | X | X | uptime |
| si.system(cb) | X | X | X | hardware information |
| - manufacturer | X | X | X | e.g. &#x27;MSI&#x27; |
| - model | X | X | X | model/product e.g. &#x27;MS-7823&#x27; |
| - version | X | X | X | version e.g. &#x27;1.0&#x27; |
| - serial | X | X | X | serial number |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.osinfo.versions" id="apidoc.element.systeminformation.osinfo.versions">
        function <span class="apidocSignatureSpan">systeminformation.osinfo.</span>versions
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function versions(callback) {
  return new Promise((resolve) =&#x3e; {
    process.nextTick(() =&#x3e; {
      let result = {
        kernel: os.release(),
        node: process.versions.node,
        v8: process.versions.v8,
        npm: &#x27;&#x27;,
        pm2: &#x27;&#x27;,
        openssl: process.versions.openssl
      };
      let lines = [];
      exec(&#x22;npm -v&#x22;, function (error, stdout) {
        if (!error) {
          result.npm = stdout.toString().split(&#x27;\n&#x27;)[0];
        }
        exec(&#x22;pm2 -v&#x22;, function (error, stdout) {
          if (!error) {
            lines = stdout.toString().split(&#x27;\n&#x27;);
            if (lines.length &#x3e;= 2) {
              result.pm2 = lines[lines.length - 2];
            }
          }
          if (callback) {
            callback(result)
          }
          resolve(result);
        });
      });
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - distro | X | X | X |  |
| - release | X | X | X |  |
| - codename | | X |  |  |
| - kernel | X | X | X | kernel release - same as os.release() |
| - arch | X | X | X | same as os.arch() |
| - hostname | X | X | X | same as os.hostname() |
| - logofile | X | X | X | e.g. &#x27;apple&#x27;, &#x27;debian&#x27;, &#x27;fedora&#x27;, ... |
| si.<span class="apidocCodeKeywordSpan">versions</span>(cb) | X | X | X | Version information (kernel, ssl, node, ...) |
| si.shell(cb) | X | X |  | standard shell |
| si.cpu(cb) | X | X | X | CPU information|
| - manufacturer | X | X | X | e.g. &#x27;Intel(R)&#x27; |
| - brand | X | X | X | e.g. &#x27;Core(TM)2 Duo&#x27; |
| - speed | X | X | X | in GHz e.g. &#x27;3.40&#x27; |
| - cores | X | X | X | # cores |
| si.cpuFlags(cb) | X | X |  | CPU flags|
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.processes" id="apidoc.module.systeminformation.processes">module systeminformation.processes</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.processes.processes" id="apidoc.element.systeminformation.processes.processes">
        function <span class="apidocSignatureSpan">systeminformation.</span>processes
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processes(callback) {

  let parsedhead = [];

  function parseHead(head, rights) {
    let space = (rights &#x3e; 0);
    let count = 1;
    let from = 0;
    let to = 0;
    let result = [];
    for (let i = 0; i &#x3c; head.length; i++) {
      if (count &#x3c;= rights) {
        if (head[i] == &#x27; &#x27; &#x26;&#x26; !space) {
          to = i - 1;
          result.push({
            from: from,
            to: to + 1,
            cap: head.substring(from, to + 1)
          });
          from = to + 2;
          count++;
        }
        space = head[i] == &#x27; &#x27;;
      } else {
        if (head[i] != &#x27; &#x27; &#x26;&#x26; space) {
          to = i - 1;
          if (from &#x3c; to) {
            result.push({
              from: from,
              to: to,
              cap: head.substring(from, to)
            });
          }
          from = to + 1;
          count++;
        }
        space = head[i] == &#x27; &#x27;;
      }
    }
    to = 1000;
    result.push({
      from: from,
      to: to,
      cap: head.substring(from, to)
    });
    return result;

  }

  function parseLine(line) {
    let pid = parseInt(line.substring(parsedhead[0].from, parsedhead[0].to));
    let pcpu = parseFloat(line.substring(parsedhead[1].from, parsedhead[1].to).replace(/,/g, &#x22;.&#x22;));
    let pmem = parseFloat(line.substring(parsedhead[2].from, parsedhead[2].to).replace(/,/g, &#x22;.&#x22;));
    let priority = parseInt(line.substring(parsedhead[3].from, parsedhead[3].to));
    let vsz = parseInt(line.substring(parsedhead[4].from, parsedhead[4].to));
    let rss = parseInt(line.substring(parsedhead[5].from, parsedhead[5].to));
    let nice = parseInt(line.substring(parsedhead[6].from, parsedhead[6].to));
    let started = line.substring(parsedhead[7].from, parsedhead[7].to).trim();
    let state = line.substring(parsedhead[8].from, parsedhead[8].to).trim();
    state = (state[0] == &#x27;R&#x27; ? &#x27;running&#x27; : (state[0] == &#x27;S&#x27; ? &#x27;sleeping&#x27; : (state[0] == &#x27;T&#x27; ? &#x27;stopped&#x27; : (state[0] == &#x27;W&#x27; ? &#x27;paging
&#x27; : (state[0] == &#x27;X&#x27; ? &#x27;dead&#x27; : (state[0] == &#x27;Z&#x27; ? &#x27;zombie&#x27; : ((state[0] == &#x27;D&#x27; || state[0] == &#x27;U&#x27;) ? &#x27;blocked&#x27; : &#x27;unknown&#x27;)))))));
    let tty = line.substring(parsedhead[9].from, parsedhead[9].to).trim();
    if (tty == &#x27;?&#x27; || tty == &#x27;??&#x27;) tty = &#x27;&#x27;;
    let user = line.substring(parsedhead[10].from, parsedhead[10].to).trim();
    let command = line.substring(parsedhead[11].from, parsedhead[11].to).trim().replace(/\[/g, &#x22;&#x22;).replace(/]/g, &#x22;&#x22;);

    return ({
      pid: pid,
      pcpu: pcpu,
      pcpuu: 0,
      pcpus: 0,
      pmem: pmem,
      priority: priority,
      mem_vsz: vsz,
      mem_rss: rss,
      nice: nice,
      started: started,
      state: state,
      tty: tty,
      user: user,
      command: command
    })
  }

  function parseProcesses(lines) {
    let result = [];
    if (lines.length &#x3e; 1) {
      let head = lines[0];
      parsedhead = parseHead(head, 7);
      lines.shift();
      lines.forEach(function (line) {
        if (line.trim() != &#x27;&#x27;) {
          result.push(parseLine(line));
        }
      });
    }
    return result;
  }

  function parseProcStat(line) {
    let parts = line.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);
    let user = (parts.length &#x3e;= 2 ? parseInt(parts[1]) : 0);
    let nice = (parts.length &#x3e;= 3 ? parseInt(parts[2]) : 0);
    let system = (parts.length &#x3e;= 4 ? parseInt(parts[3]) : 0);
    let idle = (parts.length &#x3e;= 5 ? parseInt(parts[4]) : 0);
    let iowait = (parts.length &#x3e;= 6 ? parseInt(parts[5]) : 0);
    let irq = (parts.length &#x3e;= 7 ? parseInt(parts[6]) : 0);
    let softirq = (parts.length &#x3e;= 8 ? parseInt(parts[7]) : 0);
    let steal = (parts.length &#x3e;= 9 ? parseInt(parts[8]) : 0);
    let guest = (parts.length &#x3e;= 10 ? parseInt(parts[9]) : 0);
    let guest_nice = (parts.length &#x3e;= 11 ? parseInt(parts[10]) : 0);
    return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
  }

  function parseProcPidStat(line, all) {
    let statparts = line.replace(/ +/g, &#x22; &#x22;).split(&#x27;)&#x27;);
    if (statparts.length &#x3e;= 2) {
      let parts = statparts[1].split(&#x27; &#x27;);
      if (parts.length &#x3e;= 16) {
        let pid = parseInt(statparts[0].split(&#x27; &#x27;)[0]); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.services(&#x27;mysql, apache2&#x27;, cb) | X | X |  | pass comma separated string of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">processes</span>(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
| - blocked | X | X |  | # of all processes blocked |
| - sleeping | X | X |  | # of all processes sleeping |
| - list[] | X | X |  | list of all processes incl. details |
| - ...[0].pid | X | X |  | process PID |
| - ...[0].pcpu | X | X |  | process % CPU usage |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.processes.processLoad" id="apidoc.element.systeminformation.processes.processLoad">
        function <span class="apidocSignatureSpan">systeminformation.processes.</span>processLoad
        <span class="apidocSignatureSpan">(proc, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processLoad(proc, callback) {

  // fallback - if only callback is given
  if (util.isFunction(proc) &#x26;&#x26; !callback) {
    callback = proc;
    proc = &#x27;&#x27;;
  }

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = {
        &#x27;proc&#x27;: proc,
        &#x27;pid&#x27;: -1,
        &#x27;cpu&#x27;: 0,
        &#x27;mem&#x27;: 0
      };

      if (proc) {
        exec(&#x22;ps aux | grep &#x22; + proc + &#x22; | grep -v grep&#x22;, function (error, stdout) {
          if (!error) {
            let data = stdout.replace(/ +/g, &#x22; &#x22;).split(&#x27; &#x27;);

            if (data.length &#x3e; 2) {
              result = {
                &#x27;proc&#x27;: proc,
                &#x27;pid&#x27;: data[1],
                &#x27;cpu&#x27;: parseFloat(data[2].replace(&#x27;,&#x27;, &#x27;.&#x27;)),
                &#x27;mem&#x27;: parseFloat(data[3].replace(&#x27;,&#x27;, &#x27;.&#x27;))
              }
            }
          }
          if (callback) { callback(result) }
          resolve(result);
        });
      } else {
        if (callback) { callback(result) }
        resolve(result);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].priority | X | X |  | process priotity |
| - ...[0].mem_vsz | X | X |  | process virtual memory size |
| - ...[0].mem_rss | X | X |  | process mem resident set size |
| - ...[0].nice | X | X |  | process nice value |
| - ...[0].started | X | X |  | process start time |
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.<span class="apidocCodeKeywordSpan">processLoad</span>(&#x27;apache2&#x27;,cb) | X | X |  | detailed information about given
 process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.users(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.processes.services" id="apidoc.element.systeminformation.processes.services">
        function <span class="apidocSignatureSpan">systeminformation.processes.</span>services
        <span class="apidocSignatureSpan">(srv, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function services(srv, callback) {

  // fallback - if only callback is given
  if (util.isFunction(srv) &#x26;&#x26; !callback) {
    callback = srv;
    srv = &#x27;&#x27;;
  }

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      srv = srv.trim().replace(/,+/g, &#x22; &#x22;).replace(/  +/g, &#x22; &#x22;).replace(/ +/g, &#x22;|&#x22;);
      let srvs = srv.split(&#x27;|&#x27;);
      let comm = (_darwin) ? &#x22;ps -caxm -o pcpu,pmem,comm&#x22; : &#x22;ps axo pcpu,pmem,comm&#x22;;
      let data = [];
      if (srv != &#x27;&#x27; &#x26;&#x26; srvs.length &#x3e; 0) {
        exec(comm + &#x22; | grep -v grep | egrep &#x27;&#x22; + srv + &#x22;&#x27;&#x22;, function (error, stdout) {
          if (!error) {
            let lines = stdout.toString().replace(/ +/g, &#x22; &#x22;).replace(/,+/g, &#x22;.&#x22;).split(&#x27;\n&#x27;);
            srvs.forEach(function (srv) {
              let ps = lines.filter(function (e) {
                return e.indexOf(srv) != -1
              });
              data.push({
                &#x27;name&#x27;: srv,
                &#x27;running&#x27;: ps.length &#x3e; 0,
                &#x27;pcpu&#x27;: parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(&#x27; &#x27;)[0]);
                }, 0)).toFixed(2)),
                &#x27;pmem&#x27;: parseFloat((ps.reduce(function (pv, cv) {
                  return pv + parseFloat(cv.trim().split(&#x27; &#x27;)[1]);
                }, 0)).toFixed(2))
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          } else {
            srvs.forEach(function (srv) {
              data.push({
                &#x27;name&#x27;: srv,
                &#x27;running&#x27;: false,
                &#x27;pcpu&#x27;: 0,
                &#x27;pmem&#x27;: 0
              })
            });
            if (callback) { callback(data) }
            resolve(data);
          }
        });
      } else {
        if (callback) { callback(data) }
        resolve(data);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - currentload | X | X |  | CPU-Load in % |
| - currentload_user | X | X |  | CPU-Load User in % |
| - currentload_nice | X | X |  | CPU-Load Nice in % |
| - currentload_system | X | X |  | CPU-Load System in % |
| - currentload_irq | X | X |  | CPU-Load System in % |
| - cpus[] | X | X |  | current loads per CPU in % |
| si.fullLoad(cb) | X | X |  | CPU-full load since bootup in % |
| si.<span class="apidocCodeKeywordSpan">services</span>(&#x27;mysql, apache2&#x27;, cb) | X | X |  | pass comma separated string
 of services |
| - [0].name | X | X |  | name of service |
| - [0].running | X | X |  | true / false |
| - [0].pcpu | X | X |  | process % CPU |
| - [0].pmem | X | X |  | process % MEM |
| si.processes(cb) | X | X |  | # running processes |
| - all | X | X |  | # of all processes |
| - running | X | X |  | # of all processes running |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.users" id="apidoc.module.systeminformation.users">module systeminformation.users</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.users.users" id="apidoc.element.systeminformation.users.users">
        function <span class="apidocSignatureSpan">systeminformation.</span>users
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function users(callback) {

  return new Promise((resolve, reject) =&#x3e; {
    process.nextTick(() =&#x3e; {
      if (_windows) {
        let error = new Error(NOT_SUPPORTED);
        if (callback) { callback(NOT_SUPPORTED) }
        reject(error);
      }

      let result = [];

      // linux
      if (_linux) {
        exec(&#x22;who --ips; echo &#x27;---&#x27;; w | tail -n +2&#x22;, function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            result = parseUsers1(lines);
            if (result.length == 0) {
              exec(&#x22;who; echo &#x27;---&#x27;; w | tail -n +2&#x22;, function (error, stdout) {
                if (!error) {
                  // lines / split
                  lines = stdout.toString().split(&#x27;\n&#x27;);
                  result = parseUsers1(lines);
                  if (callback) { callback(result) }
                  resolve(result);
                } else {
                  if (callback) { callback(result) }
                  resolve(result);
                }
              });
            } else {
              if (callback) { callback(result) }
              resolve(result);
            }
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

      if (_darwin) {
        exec(&#x22;who; echo &#x27;---&#x27;; w -ih&#x22;, function (error, stdout) {
          if (!error) {
            // lines / split
            let lines = stdout.toString().split(&#x27;\n&#x27;);
            result = parseUsers2(lines);

            if (callback) { callback(result) }
            resolve(result);
          } else {
            if (callback) { callback(result) }
            resolve(result);
          }
        });
      }

    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
| - ...[0].state | X | X |  | process state (e.g. sleeping) |
| - ...[0].tty | X | X |  | tty from which process was started |
| si.processLoad(&#x27;apache2&#x27;,cb) | X | X |  | detailed information about given process |
| - proc | X | X |  | process name |
| - pid | X | X |  | PID |
| - cpu | X | X |  | process % CPU |
| - mem | X | X |  | process % MEM |
| si.<span class="apidocCodeKeywordSpan">users</span>(cb) | X | X |  | array of users online |
| - [0].user | X | X |  | user name |
| - [0].tty | X | X |  | terminal |
| - [0].date | X | X |  | login date |
| - [0].time | X | X |  | login time |
| - [0].ip | X | X |  | ip address (remote login) |
| - [0].command | X | X |  | last command or shell |
| si.inetChecksite(url, cb) | X | X |  | response-time (ms) to fetch given URL |
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.systeminformation.util" id="apidoc.module.systeminformation.util">module systeminformation.util</a></h1>


    <h2>
        <a href="#apidoc.element.systeminformation.util.cores" id="apidoc.element.systeminformation.util.cores">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>cores
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cores() {
  if (_cores == 0) {
    _cores = os.cpus().length;
  }
  return _cores;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  return new Promise((resolve) =&#x3e; {
process.nextTick(() =&#x3e; {
  let result = {
    manufacturer: &#x27;unknown&#x27;,
    brand: &#x27;unknown&#x27;,
    speed: &#x27;0.00&#x27;,
    cores: util.<span class="apidocCodeKeywordSpan">cores</span>()
  };
  if (_darwin) {
    exec(&#x22;sysctl -n machdep.cpu.brand_string&#x22;, function (error, stdout) {
      if (!error) {
        let lines = stdout.toString().split(&#x27;\n&#x27;);
        result.brand = lines[0].split(&#x27;@&#x27;)[0].trim();
        result.speed = lines[0].split(&#x27;@&#x27;)[1].trim();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.util.isFunction" id="apidoc.element.systeminformation.util.isFunction">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>isFunction
        <span class="apidocSignatureSpan">(functionToCheck)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isFunction(functionToCheck) {
  let getType = {};
  return functionToCheck &#x26;&#x26; getType.toString.call(functionToCheck) === &#x27;[object Function]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
     */
    return (obj.Id &#x26;&#x26; (obj.Id == id))
  });
  return (filtered.length &#x3e; 0);
}

// fallback - if only callback is given
if (util.<span class="apidocCodeKeywordSpan">isFunction</span>(all) &#x26;&#x26; !callback) {
  callback = all;
  all = false;
}

all = all || false;
let result = [];
return new Promise((resolve, reject) =&#x3e; {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.util.sortByKey" id="apidoc.element.systeminformation.util.sortByKey">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>sortByKey
        <span class="apidocSignatureSpan">(array, keys)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sortByKey(array, keys) {
  return array.sort(function(a, b) {
    let x =&#x27;&#x27;;
    let y =&#x27;&#x27;;
    keys.forEach(function (key) {
      x = x + a[key]; y = y + b[key];
    });
    return ((x &#x3c; y) ? -1 : ((x &#x3e; y) ? 1 : 0));
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;serial&#x27;: disk.serial,
    &#x27;removable&#x27;: disk.rm == &#x27;1&#x27;,
    &#x27;protocol&#x27;: disk.tran
  })
});

data = util.unique(data);
data = util.<span class="apidocCodeKeywordSpan">sortByKey</span>(data, [&#x27;type&#x27;, &#x27;name&#x27;]);
return data;
}

function blkStdoutToObject(stdout) {
return stdout.toString()
  .replace(/NAME=/g, &#x27;{&#x22;name&#x22;:&#x27;)
  .replace(/FSTYPE=/g, &#x27;,&#x22;fstype&#x22;:&#x27;)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.systeminformation.util.unique" id="apidoc.element.systeminformation.util.unique">
        function <span class="apidocSignatureSpan">systeminformation.util.</span>unique
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function unique(obj){
  let uniques=[];
  let stringify={};
  for(let i=0;i&#x3c;obj.length;i++){
    let keys=Object.keys(obj[i]);
    keys.sort(function(a,b) {return a-b});
    let str=&#x27;&#x27;;
    for(let j=0;j&#x3c;keys.length;j++){
      str+= JSON.stringify(keys[j]);
      str+= JSON.stringify(obj[i][keys[j]]);
    }
    if(!stringify.hasOwnProperty(str)){
      uniques.push(obj[i]);
      stringify[str]=true;
    }
  }
  return uniques;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    &#x27;model&#x27;: disk.model,
    &#x27;serial&#x27;: disk.serial,
    &#x27;removable&#x27;: disk.rm == &#x27;1&#x27;,
    &#x27;protocol&#x27;: disk.tran
  })
});

data = util.<span class="apidocCodeKeywordSpan">unique</span>(data);
data = util.sortByKey(data, [&#x27;type&#x27;, &#x27;name&#x27;]);
return data;
}

function blkStdoutToObject(stdout) {
return stdout.toString()
  .replace(/NAME=/g, &#x27;{&#x22;name&#x22;:&#x27;)
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
